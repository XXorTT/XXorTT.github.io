[{"title":"数据结构与算法Java","path":"/2024/09/08/数据结构与算法/","content":"一. 初识算法1.1 什么是算法？定义在数学和计算机科学领域，算法是一系列有限的严谨指令，通常用于解决一类特定问题或执行计算 In mathematics and computer science, an algorithm (&#x2F;ˈælɡərɪðəm&#x2F;) is a finite sequence of rigorous instructions, typically used to solve a class of specific problems or to perform a computation.[^1] Introduction to Algorithm[^2] 不正式的说，算法就是任何定义优良的计算过程：接收一些值作为输入，在有限的时间内，产生一些值作为输出。 Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time. 1.2 什么是数据结构？定义 在计算机科学领域，数据结构是一种数据组织、管理和存储格式，通常被选择用来高效访问数据 In computer science, a data structure is a data organization, management, and storage format that is usually chosen for efficient access to data Introduction to Algorithm[^2] 数据结构是一种存储和组织数据的方式，旨在便于访问和修改 A data structure is a way to store and organize data in order to facilitate access and modifications 可以说，程序 &#x3D; 数据结构 + 算法，它们是每一位程序员的基本功，下来我们通过对一个非常著名的二分查找算法的讲解来认识一下算法 1.3 二分查找 [^3]二分查找算法也称折半查找，是一种非常高效的工作于有序数组的查找算法。后续的课程中还会学习更多的查找算法，但在此之前，不妨用它作为入门。 1) 基础版需求：在有序数组 $A$ 内，查找值 $target$ 如果找到返回索引 如果找不到返回 $-1$ 算法描述 前提 给定一个内含 $n$ 个元素的有序数组 $A$，满足 $A_{0}\\leq A_{1}\\leq A_{2}\\leq \\cdots \\leq A_{n-1}$，一个待查值 $target$ 1 设置 $i&#x3D;0$，$j&#x3D;n-1$ 2 如果 $i \\gt j$，结束查找，没找到 3 设置 $m &#x3D; floor(\\frac {i+j}{2})$ ，$m$ 为中间索引，$floor$ 是向下取整（$\\leq \\frac {i+j}{2}$ 的最小整数） 4 如果 $target &lt; A_{m}$ 设置 $j &#x3D; m - 1$，跳到第2步 5 如果 $A_{m} &lt; target$ 设置 $i &#x3D; m + 1$，跳到第2步 6 如果 $A_{m} &#x3D; target$，结束查找，找到了 P.S. 对于一个算法来讲，都有较为严谨的描述，上面是一个例子 后续讲解时，以简明直白为目标，不会总以上面的方式来描述算法 java 实现 1234567891011121314public static int binarySearch(int[] a, int target) &#123; int i = 0, j = a.length - 1; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; // 在左边 j = m - 1; &#125; else if (a[m] &lt; target) &#123; // 在右边 i = m + 1; &#125; else &#123; return m; &#125; &#125; return -1;&#125; $i,j$ 对应着搜索区间 $[0,a.length-1]$（注意是闭合的区间），$i&lt;&#x3D;j$ 意味着搜索区间内还有未比较的元素，$i,j$ 指向的元素也可能是比较的目标 思考：如果不加 $i&#x3D;&#x3D;j$ 行不行？ 回答：不行，因为这意味着 $i,j$ 指向的元素会漏过比较 $m$ 对应着中间位置，中间位置左边和右边的元素可能不相等（差一个），不会影响结果 如果某次未找到，那么缩小后的区间内不包含 $m$ 2) 改变版另一种写法 1234567891011121314public static int binarySearch(int[] a, int target) &#123; int i = 0, j = a.length; while (i &lt; j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; // 在左边 j = m; &#125; else if (a[m] &lt; target) &#123; // 在右边 i = m + 1; &#125; else &#123; return m; &#125; &#125; return -1;&#125; $i,j$ 对应着搜索区间 $[0,a.length)$（注意是左闭右开的区间），$i&lt;j$ 意味着搜索区间内还有未比较的元素，$j$ 指向的一定不是查找目标 思考：为啥这次不加 $i&#x3D;&#x3D;j$ 的条件了？ 回答：这回 $j$ 指向的不是查找目标，如果还加 $i&#x3D;&#x3D;j$ 条件，就意味着 $j$ 指向的还会再次比较，找不到时，会死循环 如果某次要缩小右边界，那么 $j&#x3D;m$，因为此时的 $m$ 已经不是查找目标了 1.4 衡量算法好坏时间复杂度 下面的查找算法也能得出与之前二分查找一样的结果，那你能说出它差在哪里吗？ 123456789101112public static int search(int[] a, int k) &#123; for ( int i = 0; i &lt; a.length; i++ ) &#123; if (a[i] == k) &#123; return i; &#125; &#125; return -1;&#125; 考虑最坏情况下（没找到）例如 [1,2,3,4] 查找 5 int i = 0 只执行一次 i &lt; a.length 受数组元素个数 $n$ 的影响，比较 $n+1$ 次 i++ 受数组元素个数 $n$ 的影响，自增 $n$ 次 a[i] == k 受元素个数 $n$ 的影响，比较 $n$ 次 return -1，执行一次 粗略认为每行代码执行时间是 $t$，假设 $n&#x3D;4$ 那么 总执行时间是 $(1+4+1+4+4+1)*t &#x3D; 15t$ 可以推导出更一般地公式为，$T &#x3D; (3*n+3)t$ 如果套用二分查找算法，还是 [1,2,3,4] 查找 5 1234567891011121314public static int binarySearch(int[] a, int target) &#123; int i = 0, j = a.length - 1; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; // 在左边 j = m - 1; &#125; else if (a[m] &lt; target) &#123; // 在右边 i = m + 1; &#125; else &#123; return m; &#125; &#125; return -1;&#125; int i = 0, j = a.length - 1 各执行 1 次 i &lt;= j 比较 $floor(\\log_{2}(n)+1)$ 再加 1 次 (i + j) &gt;&gt;&gt; 1 计算 $floor(\\log_{2}(n)+1)$ 次 接下来 if() else if() else 会执行 $3* floor(\\log_{2}(n)+1)$ 次，分别为 if 比较 else if 比较 else if 比较成立后的赋值语句 return -1，执行一次 结果： 总执行时间为 $(2 + (1+3) + 3 + 3 * 3 +1)*t &#x3D; 19t$ 更一般地公式为 $(4 + 5 * floor(\\log_{2}(n)+1))*t$ 注意： 左侧未找到和右侧未找到结果不一样，这里不做分析 两个算法比较，可以看到 $n$ 在较小的时候，二者花费的次数差不多 但随着 $n$ 越来越大，比如说 $n&#x3D;1000$ 时，用二分查找算法（红色）也就是 $54t$，而蓝色算法则需要 $3003t$ 画图采用的是 Desmos | 图形计算器 计算机科学中，时间复杂度是用来衡量：一个算法的执行，随数据规模增大，而增长的时间成本 不依赖于环境因素 如何表示时间复杂度呢？ 假设算法要处理的数据规模是 $n$，代码总的执行行数用函数 $f(n)$ 来表示，例如： 线性查找算法的函数 $f(n) &#x3D; 3*n + 3$ 二分查找算法的函数 $f(n) &#x3D; (floor(log_2(n)) + 1) * 5 + 4$ 为了对 $f(n)$ 进行化简，应当抓住主要矛盾，找到一个变化趋势与之相近的表示法 大 $O$ 表示法[^4] 其中 $c, c_1, c_2$ 都为一个常数 $f(n)$ 是实际执行代码行数与 n 的函数 $g(n)$ 是经过化简，变化趋势与 $f(n)$ 一致的 n 的函数 渐进上界 渐进上界（asymptotic upper bound）：从某个常数 $n_0$开始，$c*g(n)$ 总是位于 $f(n)$ 上方，那么记作 $O(g(n))$ 代表算法执行的最差情况 例1 $f(n) &#x3D; 3*n+3$ $g(n) &#x3D; n$ 取 $c&#x3D;4$，在$n_0&#x3D;3$ 之后，$g(n)$ 可以作为 $f(n)$ 的渐进上界，因此表示法写作 $O(n)$ 例2 $f(n) &#x3D; 5*floor(log_2(n)) + 9$ $g(n) &#x3D; log_2(n)$ $O(log_2(n))$ 已知 $f(n)$ 来说，求 $g(n)$ 表达式中相乘的常量，可以省略，如 $f(n) &#x3D; 100*n^2$ 中的 $100$ 多项式中数量规模更小（低次项）的表达式，如 $f(n)&#x3D;n^2+n$ 中的 $n$ $f(n) &#x3D; n^3 + n^2$ 中的 $n^2$ 不同底数的对数，渐进上界可以用一个对数函数 $\\log n$ 表示 例如：$log_2(n)$ 可以替换为 $log_{10}(n)$，因为 $log_2(n) &#x3D; \\frac{log_{10}(n)}{log_{10}(2)}$，相乘的常量 $\\frac{1}{log_{10}(2)}$ 可以省略 类似的，对数的常数次幂可省略 如：$log(n^c) &#x3D; c * log(n)$ 常见大 $O$ 表示法 按时间复杂度从低到高 黑色横线 $O(1)$，常量时间，意味着算法时间并不随数据规模而变化 绿色 $O(log(n))$，对数时间 蓝色 $O(n)$，线性时间，算法时间与数据规模成正比 橙色 $O(n*log(n))$，拟线性时间 红色 $O(n^2)$ 平方时间 黑色朝上 $O(2^n)$ 指数时间 没画出来的 $O(n!)$ 渐进下界 渐进下界（asymptotic lower bound）：从某个常数 $n_0$开始，$c*g(n)$ 总是位于 $f(n)$ 下方，那么记作 $\\Omega(g(n))$ 渐进紧界 渐进紧界（asymptotic tight bounds）：从某个常数 $n_0$开始，$f(n)$ 总是在 $c_1g(n)$ 和 $c_2g(n)$ 之间，那么记作 $\\Theta(g(n))$ 空间复杂度 与时间复杂度类似，一般也使用大 $O$ 表示法来衡量：一个算法执行随数据规模增大，而增长的额外空间成本 1234567891011121314public static int binarySearchBasic(int[] a, int target) &#123; int i = 0, j = a.length - 1; // 设置指针和初值 while (i &lt;= j) &#123; // i~j 范围内有东西 int m = (i + j) &gt;&gt;&gt; 1; if(target &lt; a[m]) &#123; // 目标在左边 j = m - 1; &#125; else if (a[m] &lt; target) &#123; // 目标在右边 i = m + 1; &#125; else &#123; // 找到了 return m; &#125; &#125; return -1;&#125; 二分查找性能 下面分析二分查找算法的性能 时间复杂度 最坏情况：$O(\\log n)$ 最好情况：如果待查找元素恰好在数组中央，只需要循环一次 $O(1)$ 空间复杂度 需要常数个指针 $i,j,m$，因此额外占用的空间是 $O(1)$ 1.5 再看二分查找1) 平衡版123456789101112public static int binarySearchBalance(int[] a, int target) &#123; int i = 0, j = a.length; while (1 &lt; j - i) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; j = m; &#125; else &#123; i = m; &#125; &#125; return (a[i] == target) ? i : -1;&#125; 思想： 左闭右开的区间，$i$ 指向的可能是目标，而 $j$ 指向的不是目标 不奢望循环内通过 $m$ 找出目标, 缩小区间直至剩 1 个, 剩下的这个可能就是要找的（通过 $i$） $j - i &gt; 1$ 的含义是，在范围内待比较的元素个数 &gt; 1 改变 $i$ 边界时，它指向的可能是目标，因此不能 $m+1$ 循环内的平均比较次数减少了 时间复杂度 $\\Theta(log(n))$ 2) Java 版123456789101112131415161718private static int binarySearch0(long[] a, int fromIndex, int toIndex, long key) &#123; int low = fromIndex; int high = toIndex - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; long midVal = a[mid]; if (midVal &lt; key) low = mid + 1; else if (midVal &gt; key) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found.&#125; 例如 $[1,3,5,6]$ 要插入 $2$ 那么就是找到一个位置，这个位置左侧元素都比它小 等循环结束，若没找到，low 左侧元素肯定都比 target 小，因此 low 即插入点 插入点取负是为了与找到情况区分 -1 是为了把索引 0 位置的插入点与找到的情况进行区分 3) Leftmost 与 Rightmost有时我们希望返回的是最左侧的重复元素，如果用 Basic 二分查找 对于数组 $[1, 2, 3, 4, 4, 5, 6, 7]$，查找元素4，结果是索引3 对于数组 $[1, 2, 4, 4, 4, 5, 6, 7]$，查找元素4，结果也是索引3，并不是最左侧的元素 12345678910111213141516public static int binarySearchLeftmost1(int[] a, int target) &#123; int i = 0, j = a.length - 1; int candidate = -1; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; j = m - 1; &#125; else if (a[m] &lt; target) &#123; i = m + 1; &#125; else &#123; candidate = m; // 记录候选位置 j = m - 1; // 继续向左 &#125; &#125; return candidate;&#125; 如果希望返回的是最右侧元素 12345678910111213141516public static int binarySearchRightmost1(int[] a, int target) &#123; int i = 0, j = a.length - 1; int candidate = -1; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; j = m - 1; &#125; else if (a[m] &lt; target) &#123; i = m + 1; &#125; else &#123; candidate = m; // 记录候选位置 i = m + 1; // 继续向右 &#125; &#125; return candidate;&#125; 应用 对于 Leftmost 与 Rightmost，可以返回一个比 -1 更有用的值 Leftmost 改为 123456789101112public static int binarySearchLeftmost(int[] a, int target) &#123; int i = 0, j = a.length - 1; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt;= a[m]) &#123; j = m - 1; &#125; else &#123; i = m + 1; &#125; &#125; return i; &#125; leftmost 返回值的另一层含义：$\\lt target$ 的元素个数 小于等于中间值，都要向左找 Rightmost 改为 123456789101112public static int binarySearchRightmost(int[] a, int target) &#123; int i = 0, j = a.length - 1; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; j = m - 1; &#125; else &#123; i = m + 1; &#125; &#125; return i - 1;&#125; 大于等于中间值，都要向右找 几个名词 范围查询： 查询 $x \\lt 4$，$0 .. leftmost(4) - 1$ 查询 $x \\leq 4$，$0 .. rightmost(4)$ 查询 $4 \\lt x$，$rightmost(4) + 1 .. \\infty $ 查询 $4 \\leq x$， $leftmost(4) .. \\infty$ 查询 $4 \\leq x \\leq 7$，$leftmost(4) .. rightmost(7)$ 查询 $4 \\lt x \\lt 7$，$rightmost(4)+1 .. leftmost(7)-1$ 求排名：$leftmost(target) + 1$ $target$ 可以不存在，如：$leftmost(5)+1 &#x3D; 6$ $target$ 也可以存在，如：$leftmost(4)+1 &#x3D; 3$ 求前任（predecessor）：$leftmost(target) - 1$ $leftmost(3) - 1 &#x3D; 1$，前任 $a_1 &#x3D; 2$ $leftmost(4) - 1 &#x3D; 1$，前任 $a_1 &#x3D; 2$ 求后任（successor）：$rightmost(target)+1$ $rightmost(5) + 1 &#x3D; 5$，后任 $a_5 &#x3D; 7$ $rightmost(4) + 1 &#x3D; 5$，后任 $a_5 &#x3D; 7$ 求最近邻居： 前任和后任距离更近者 习题1) 时间复杂度估算用函数 $f(n)$ 表示算法效率与数据规模的关系，假设每次解决问题需要 1 微秒（$10^{-6}$ 秒），进行估算： 如果 $f(n) &#x3D; n^2$ 那么 1 秒能解决多少次问题？1 天呢？ 如果 $f(n) &#x3D; log_2(n)$ 那么 1 秒能解决多少次问题？1 天呢？ 如果 $f(n) &#x3D; n!$ 那么 1 秒能解决多少次问题？1 天呢？ 参考解答 1秒 $\\sqrt{10^6} &#x3D; 1000$ 次，1 天 $\\sqrt{10^6 * 3600 * 24} \\approx 293938$ 次 1秒 $2^{1,000,000} $ 次，一天 $2^{86,400,000,000}$ 推算如下 $10! &#x3D; 3,628,800$ 1秒能解决 $1,000,000$ 次，因此次数为 9 次 $14!&#x3D;87,178,291,200$，一天能解决 $86,400,000,000$ 次，因此次数为 13 次 2) 耗时估算一台机器对200个单词进行排序花了200秒(使用冒泡排序)，那么花费800秒，大概可以对多少个单词进行排序 a. 400 b. 600 c. 800 d. 1600 答案 a 解释 冒泡排序时间复杂度是 $O(N^2)$ 时间增长 4 倍，而因此能处理的数据量是原来的 $\\sqrt{4} &#x3D; 2$ 倍 3) E01. 二分查找-Leetcode 704要点：减而治之，可以用递归或非递归实现 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1 例如 1234567输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 参考答案：略，可以用讲过的任意一种二分求解 4) E02. 搜索插入位置-Leetcode 35要点：理解谁代表插入位置 给定一个排序数组和一个目标值 在数组中找到目标值，并返回其索引 如果目标值不存在于数组中，返回它将会被按顺序插入的位置 例如 12345678输入: nums = [1,3,5,6], target = 5输出: 2输入: nums = [1,3,5,6], target = 2输出: 1输入: nums = [1,3,5,6], target = 7输出: 4 参考答案1：用二分查找基础版代码改写，基础版中，找到返回 m，没找到 i 代表插入点，因此有 1234567891011121314public int searchInsert(int[] a, int target) &#123; int i = 0, j = a.length - 1; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; j = m - 1; &#125; else if (a[m] &lt; target) &#123; i = m + 1; &#125; else &#123; return m; &#125; &#125; return i; // 原始 return -1&#125; 参考答案2：用二分查找平衡版改写，平衡版中 如果 target &#x3D;&#x3D; a[i] 返回 i 表示找到 如果 target &lt; a[i]，例如 target &#x3D; 2，a[i] &#x3D; 3，这时就应该在 i 位置插入 2 如果 a[i] &lt; target，例如 a[i] &#x3D; 3，target &#x3D; 4，这时就应该在 i+1 位置插入 4 12345678910111213public static int searchInsert(int[] a, int target) &#123; int i = 0, j = a.length; while (1 &lt; j - i) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; j = m; &#125; else &#123; i = m; &#125; &#125; return (target &lt;= a[i]) ? i : i + 1; // 原始 (target == a[i]) ? i : -1;&#125; 参考答案3：用 leftmost 版本解，返回值即为插入位置（并能处理元素重复的情况） 123456789101112public int searchInsert(int[] a, int target) &#123; int i = 0, j = a.length - 1; while(i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if(target &lt;= a[m]) &#123; j = m - 1; &#125; else &#123; i = m + 1; &#125; &#125; return i;&#125; 5) E03. 搜索开始结束位置-Leetcode 34给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题 例如 12345678输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]输入：nums = [], target = 0输出：[-1,-1] 参考答案 123456789101112131415161718192021222324252627282930313233343536373839404142public static int left(int[] a, int target) &#123; int i = 0, j = a.length - 1; int candidate = -1; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; j = m - 1; &#125; else if (a[m] &lt; target) &#123; i = m + 1; &#125; else &#123; candidate = m; j = m - 1; &#125; &#125; return candidate;&#125;public static int right(int[] a, int target) &#123; int i = 0, j = a.length - 1; int candidate = -1; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; j = m - 1; &#125; else if (a[m] &lt; target) &#123; i = m + 1; &#125; else &#123; candidate = m; i = m + 1; &#125; &#125; return candidate;&#125;public static int[] searchRange(int[] nums, int target) &#123; int x = left(nums, target); if(x == -1) &#123; return new int[] &#123;-1, -1&#125;; &#125; else &#123; return new int[] &#123;x, right(nums, target)&#125;; &#125;&#125; 二. 基础数据结构2.1 数组1) 概述定义 在计算机科学中，数组是由一组元素（值或变量）组成的数据结构，每个元素有至少一个索引或键来标识 In computer science, an array is a data structure consisting of a collection of elements (values or variables), each identified by at least one array index or key 因为数组内的元素是连续存储的，所以数组中元素的地址，可以通过其索引计算出来，例如： 1int[] array = &#123;1,2,3,4,5&#125; 知道了数组的数据起始地址 $BaseAddress$，就可以由公式 $BaseAddress + i * size$ 计算出索引 $i$ 元素的地址 $i$ 即索引，在 Java、C 等语言都是从 0 开始 $size$ 是每个元素占用字节，例如 $int$ 占 $4$，$double$ 占 $8$ 小测试 1byte[] array = &#123;1,2,3,4,5&#125; 已知 array 的数据的起始地址是 0x7138f94c8，那么元素 3 的地址是什么？ 答：0x7138f94c8 + 2 * 1 &#x3D; 0x7138f94ca 空间占用 Java 中数组结构为 8 字节 markword 4 字节 class 指针（压缩 class 指针的情况） 4 字节 数组大小（决定了数组最大容量是 $2^{32}$） 数组元素 + 对齐字节（java 中所有对象大小都是 8 字节的整数倍[^12]，不足的要用对齐字节补足） 例如 1int[] array = &#123;1, 2, 3, 4, 5&#125;; 的大小为 40 个字节，组成如下 18 + 4 + 4 + 5*4 + 4(alignment) 随机访问性能 即根据索引查找元素，时间复杂度是 $O(1)$ 2) 动态数组java 版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class DynamicArray implements Iterable&lt;Integer&gt; &#123; private int size = 0; // 逻辑大小 private int capacity = 8; // 容量 private int[] array = &#123;&#125;; /** * 向最后位置 [size] 添加元素 * * @param element 待添加元素 */ public void addLast(int element) &#123; add(size, element); &#125; /** * 向 [0 .. size] 位置添加元素 * * @param index 索引位置 * @param element 待添加元素 */ public void add(int index, int element) &#123; checkAndGrow(); // 添加逻辑 if (index &gt;= 0 &amp;&amp; index &lt; size) &#123; // 向后挪动, 空出待插入位置 System.arraycopy(array, index, array, index + 1, size - index); &#125; array[index] = element; size++; &#125; private void checkAndGrow() &#123; // 容量检查 if (size == 0) &#123; array = new int[capacity]; &#125; else if (size == capacity) &#123; // 进行扩容, 1.5 1.618 2 capacity += capacity &gt;&gt; 1; int[] newArray = new int[capacity]; System.arraycopy(array, 0, newArray, 0, size); array = newArray; &#125; &#125; /** * 从 [0 .. size) 范围删除元素 * * @param index 索引位置 * @return 被删除元素 */ public int remove(int index) &#123; // [0..size) int removed = array[index]; if (index &lt; size - 1) &#123; // 向前挪动 System.arraycopy(array, index + 1, array, index, size - index - 1); &#125; size--; return removed; &#125; /** * 查询元素 * * @param index 索引位置, 在 [0..size) 区间内 * @return 该索引位置的元素 */ public int get(int index) &#123; return array[index]; &#125; /** * 遍历方法1 * * @param consumer 遍历要执行的操作, 入参: 每个元素 */ public void foreach(Consumer&lt;Integer&gt; consumer) &#123; for (int i = 0; i &lt; size; i++) &#123; // 提供 array[i] // 返回 void consumer.accept(array[i]); &#125; &#125; /** * 遍历方法2 - 迭代器遍历 */ @Override public Iterator&lt;Integer&gt; iterator() &#123; return new Iterator&lt;Integer&gt;() &#123; int i = 0; @Override public boolean hasNext() &#123; // 有没有下一个元素 return i &lt; size; &#125; @Override public Integer next() &#123; // 返回当前元素,并移动到下一个元素 return array[i++]; &#125; &#125;; &#125; /** * 遍历方法3 - stream 遍历 * * @return stream 流 */ public IntStream stream() &#123; return IntStream.of(Arrays.copyOfRange(array, 0, size)); &#125;&#125; 这些方法实现，都简化了 index 的有效性判断，假设输入的 index 都是合法的 插入或删除性能 头部位置，时间复杂度是 $O(n)$ 中间位置，时间复杂度是 $O(n)$ 尾部位置，时间复杂度是 $O(1)$（均摊来说） 3) 二维数组12345int[][] array = &#123; &#123;11, 12, 13, 14, 15&#125;, &#123;21, 22, 23, 24, 25&#125;, &#123;31, 32, 33, 34, 35&#125;,&#125;; 内存图如下 二维数组占 32 个字节，其中 array[0]，array[1]，array[2] 三个元素分别保存了指向三个一维数组的引用 三个一维数组各占 40 个字节 它们在内层布局上是连续的 更一般的，对一个二维数组 $Array[m][n]$ $m$ 是外层数组的长度，可以看作 row 行 $n$ 是内层数组的长度，可以看作 column 列 当访问 $Array[i][j]$，$0\\leq i \\lt m, 0\\leq j \\lt n$时，就相当于 先找到第 $i$ 个内层数组（行） 再找到此内层数组中第 $j$ 个元素（列） 小测试 Java 环境下（不考虑类指针和引用压缩，此为默认情况），有下面的二维数组 12345byte[][] array = &#123; &#123;11, 12, 13, 14, 15&#125;, &#123;21, 22, 23, 24, 25&#125;, &#123;31, 32, 33, 34, 35&#125;,&#125;; 已知 array 对象起始地址是 0x1000，那么 23 这个元素的地址是什么？ 答： 起始地址 0x1000 外层数组大小：16字节对象头 + 3元素 * 每个引用4字节 + 4 对齐字节 &#x3D; 32 &#x3D; 0x20 第一个内层数组大小：16字节对象头 + 5元素 * 每个byte1字节 + 3 对齐字节 &#x3D; 24 &#x3D; 0x18 第二个内层数组，16字节对象头 &#x3D; 0x10，待查找元素索引为 2 最后结果 &#x3D; 0x1000 + 0x20 + 0x18 + 0x10 + 2*1 &#x3D; 0x104a 4) 局部性原理这里只讨论空间局部性 cpu 读取内存（速度慢）数据后，会将其放入高速缓存（速度快）当中，如果后来的计算再用到此数据，在缓存中能读到的话，就不必读内存了 缓存的最小存储单位是缓存行（cache line），一般是 64 bytes，一次读的数据少了不划算啊，因此最少读 64 bytes 填满一个缓存行，因此读入某个数据时也会读取其临近的数据，这就是所谓空间局部性 对效率的影响 比较下面 ij 和 ji 两个方法的执行效率 123456789101112int rows = 1000000;int columns = 14;int[][] a = new int[rows][columns];StopWatch sw = new StopWatch();sw.start(&quot;ij&quot;);ij(a, rows, columns);sw.stop();sw.start(&quot;ji&quot;);ji(a, rows, columns);sw.stop();System.out.println(sw.prettyPrint()); ij 方法 123456789public static void ij(int[][] a, int rows, int columns) &#123; long sum = 0L; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; sum += a[i][j]; &#125; &#125; System.out.println(sum);&#125; ji 方法 123456789public static void ji(int[][] a, int rows, int columns) &#123; long sum = 0L; for (int j = 0; j &lt; columns; j++) &#123; for (int i = 0; i &lt; rows; i++) &#123; sum += a[i][j]; &#125; &#125; System.out.println(sum);&#125; 执行结果 1234567800StopWatch &#x27;&#x27;: running time = 96283300 ns---------------------------------------------ns % Task name---------------------------------------------016196200 017% ij080087100 083% ji 可以看到 ij 的效率比 ji 快很多，为什么呢？ 缓存是有限的，当新数据来了后，一些旧的缓存行数据就会被覆盖 如果不能充分利用缓存的数据，就会造成效率低下 以 ji 执行为例，第一次内循环要读入 $[0,0]$ 这条数据，由于局部性原理，读入 $[0,0]$ 的同时也读入了 $[0,1] … [0,13]$，如图所示 但很遗憾，第二次内循环要的是 $[1,0]$ 这条数据，缓存中没有，于是再读入了下图的数据 这显然是一种浪费，因为 $[0,1] … [0,13]$ 包括 $[1,1] … [1,13]$ 这些数据虽然读入了缓存，却没有及时用上，而缓存的大小是有限的，等执行到第九次内循环时 缓存的第一行数据已经被新的数据 $[8,0] … [8,13]$ 覆盖掉了，以后如果再想读，比如 $[0,1]$，又得到内存去读了 同理可以分析 ij 函数则能充分利用局部性原理加载到的缓存数据 举一反三 I&#x2F;O 读写时同样可以体现局部性原理 数组可以充分利用局部性原理，那么链表呢？ 答：链表不行，因为链表的元素并非相邻存储 5) 越界检查java 中对数组元素的读写都有越界检查，类似于下面的代码 1234bool is_within_bounds(int index) const &#123; return 0 &lt;= index &amp;&amp; index &lt; length(); &#125; 代码位置：openjdk\\src\\hotspot\\share\\oops\\arrayOop.hpp 只不过此检查代码，不需要由程序员自己来调用，JVM 会帮我们调用 习题E01. 合并有序数组 - 对应 Leetcode 88将数组内两个区间内的有序元素合并 例 1[1, 5, 6, 2, 4, 10, 11] 可以视作两个有序区间 1[1, 5, 6] 和 [2, 4, 10, 11] 合并后，结果仍存储于原有空间 1[1, 2, 4, 5, 6, 10, 11] 方法1 递归 每次递归把更小的元素复制到结果数组 12345678910111213merge(left=[1,5,6],right=[2,4,10,11],a2=[])&#123; merge(left=[5,6],right=[2,4,10,11],a2=[1])&#123; merge(left=[5,6],right=[4,10,11],a2=[1,2])&#123; merge(left=[5,6],right=[10,11],a2=[1,2,4])&#123; merge(left=[6],right=[10,11],a2=[1,2,4,5])&#123; merge(left=[],right=[10,11],a2=[1,2,4,5,6])&#123; // 拷贝10，11 &#125; &#125; &#125; &#125; &#125;&#125; 代码 123456789101112131415161718public static void merge(int[] a1, int i, int iEnd, int j, int jEnd, int[] a2, int k) &#123; if (i &gt; iEnd) &#123; System.arraycopy(a1, j, a2, k, jEnd - j + 1); return; &#125; if (j &gt; jEnd) &#123; System.arraycopy(a1, i, a2, k, iEnd - i + 1); return; &#125; if (a1[i] &lt; a1[j]) &#123; a2[k] = a1[i]; merge(a1, i + 1, iEnd, j, jEnd, a2, k + 1); &#125; else &#123; a2[k] = a1[j]; merge(a1, i, iEnd, j + 1, jEnd, a2, k + 1); &#125;&#125; 测试 123int[] a1 = &#123;1, 5, 6, 2, 4, 10, 11&#125;;int[] a2 = new int[a1.length];merge(a1, 0, 2, 3, 6, a2, 0); 方法2 代码 123456789101112131415161718192021public static void merge(int[] a1, int i, int iEnd, int j, int jEnd, int[] a2) &#123; int k = i; while (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) &#123; if (a1[i] &lt; a1[j]) &#123; a2[k] = a1[i]; i++; &#125; else &#123; a2[k] = a1[j]; j++; &#125; k++; &#125; if (i &gt; iEnd) &#123; System.arraycopy(a1, j, a2, k, jEnd - j + 1); &#125; if (j &gt; jEnd) &#123; System.arraycopy(a1, i, a2, k, iEnd - i + 1); &#125;&#125; 测试 123int[] a1 = &#123;1, 5, 6, 2, 4, 10, 11&#125;;int[] a2 = new int[a3.length];merge(a1, 0, 2, 3, 6, a2); 2.2 链表1) 概述定义 在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续 In computer science, a linked list is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next. 可以分类为[^5] 单向链表，每个元素只知道其下一个元素是谁 双向链表，每个元素知道其上一个元素和下一个元素 循环链表，通常的链表尾节点 tail 指向的都是 null，而循环链表的 tail 指向的是头节点 head 链表内还有一种特殊的节点称为哨兵（Sentinel）节点，也叫做哑元（ Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断，如下图所示 随机访问性能 根据 index 查找，时间复杂度 $O(n)$ 插入或删除性能 起始位置：$O(1)$ 结束位置：如果已知 tail 尾节点是 $O(1)$，不知道 tail 尾节点是 $O(n)$ 中间位置：根据 index 查找时间 + $O(1)$ 2) 单向链表根据单向链表的定义，首先定义一个存储 value 和 next 指针的类 Node，和一个描述头部节点的引用 1234567891011121314public class SinglyLinkedList &#123; private Node head; // 头部节点 private static class Node &#123; // 节点类 int value; Node next; public Node(int value, Node next) &#123; this.value = value; this.next = next; &#125; &#125;&#125; Node 定义为内部类，是为了对外隐藏实现细节，没必要让类的使用者关心 Node 结构 定义为 static 内部类，是因为 Node 不需要与 SinglyLinkedList 实例相关，多个 SinglyLinkedList实例能共用 Node 类定义 头部添加 123456public class SinglyLinkedList &#123; // ... public void addFirst(int value) &#123; this.head = new Node(value, this.head); &#125;&#125; 如果 this.head &#x3D;&#x3D; null，新增节点指向 null，并作为新的 this.head 如果 this.head !&#x3D; null，新增节点指向原来的 this.head，并作为新的 this.head 注意赋值操作执行顺序是从右到左 while 遍历 12345678910public class SinglyLinkedList &#123; // ... public void loop() &#123; Node curr = this.head; while (curr != null) &#123; // 做一些事 curr = curr.next; &#125; &#125;&#125; for 遍历 12345678public class SinglyLinkedList &#123; // ... public void loop() &#123; for (Node curr = this.head; curr != null; curr = curr.next) &#123; // 做一些事 &#125; &#125;&#125; 以上两种遍历都可以把要做的事以 Consumer 函数的方式传递进来 Consumer 的规则是一个参数，无返回值，因此像 System.out::println 方法等都是 Consumer 调用 Consumer 时，将当前节点 curr.value 作为参数传递给它 迭代器遍历 1234567891011121314151617181920public class SinglyLinkedList implements Iterable&lt;Integer&gt; &#123; // ... private class NodeIterator implements Iterator&lt;Integer&gt; &#123; Node curr = head; public boolean hasNext() &#123; return curr != null; &#125; public Integer next() &#123; int value = curr.value; curr = curr.next; return value; &#125; &#125; public Iterator&lt;Integer&gt; iterator() &#123; return new NodeIterator(); &#125;&#125; hasNext 用来判断是否还有必要调用 next next 做两件事 返回当前节点的 value 指向下一个节点 NodeIterator 要定义为非 static 内部类，是因为它与 SinglyLinkedList 实例相关，是对某个 SinglyLinkedList 实例的迭代 递归遍历 123456789101112131415public class SinglyLinkedList implements Iterable&lt;Integer&gt; &#123; // ... public void loop() &#123; recursion(this.head); &#125; private void recursion(Node curr) &#123; if (curr == null) &#123; return; &#125; // 前面做些事 recursion(curr.next); // 后面做些事 &#125;&#125; 尾部添加 12345678910111213141516171819202122public class SinglyLinkedList &#123; // ... private Node findLast() &#123; if (this.head == null) &#123; return null; &#125; Node curr; for (curr = this.head; curr.next != null; ) &#123; curr = curr.next; &#125; return curr; &#125; public void addLast(int value) &#123; Node last = findLast(); if (last == null) &#123; addFirst(value); return; &#125; last.next = new Node(value, null); &#125;&#125; 注意，找最后一个节点，终止条件是 curr.next &#x3D;&#x3D; null 分成两个方法是为了代码清晰，而且 findLast() 之后还能复用 尾部添加多个 12345678910111213141516171819public class SinglyLinkedList &#123; // ...\tpublic void addLast(int first, int... rest) &#123; Node sublist = new Node(first, null); Node curr = sublist; for (int value : rest) &#123; curr.next = new Node(value, null); curr = curr.next; &#125; Node last = findLast(); if (last == null) &#123; this.head = sublist; return; &#125; last.next = sublist; &#125;&#125; 先串成一串 sublist 再作为一个整体添加 根据索引获取 123456789101112131415161718192021222324public class SinglyLinkedList &#123; // ...\tprivate Node findNode(int index) &#123; int i = 0; for (Node curr = this.head; curr != null; curr = curr.next, i++) &#123; if (index == i) &#123; return curr; &#125; &#125; return null; &#125; private IllegalArgumentException illegalIndex(int index) &#123; return new IllegalArgumentException(String.format(&quot;index [%d] 不合法%n&quot;, index)); &#125; public int get(int index) &#123; Node node = findNode(index); if (node != null) &#123; return node.value; &#125; throw illegalIndex(index); &#125;&#125; 同样，分方法可以实现复用 插入 1234567891011121314public class SinglyLinkedList &#123; // ...\tpublic void insert(int index, int value) &#123; if (index == 0) &#123; addFirst(value); return; &#125; Node prev = findNode(index - 1); // 找到上一个节点 if (prev == null) &#123; // 找不到 throw illegalIndex(index); &#125; prev.next = new Node(value, prev.next); &#125;&#125; 插入包括下面的删除，都必须找到上一个节点 删除 1234567891011121314151617181920public class SinglyLinkedList &#123; // ...\tpublic void remove(int index) &#123; if (index == 0) &#123; if (this.head != null) &#123; this.head = this.head.next; return; &#125; else &#123; throw illegalIndex(index); &#125; &#125; Node prev = findNode(index - 1); Node curr; if (prev != null &amp;&amp; (curr = prev.next) != null) &#123; prev.next = curr.next; &#125; else &#123; throw illegalIndex(index); &#125; &#125;&#125; 第一个 if 块对应着 removeFirst 情况 最后一个 if 块对应着至少得两个节点的情况 不仅仅判断上一个节点非空，还要保证当前节点非空 3) 单向链表（带哨兵）观察之前单向链表的实现，发现每个方法内几乎都有判断是不是 head 这样的代码，能不能简化呢？ 用一个不参与数据存储的特殊 Node 作为哨兵，它一般被称为哨兵或哑元，拥有哨兵节点的链表称为带头链表 1234public class SinglyLinkedListSentinel &#123; // ... private Node head = new Node(Integer.MIN_VALUE, null);&#125; 具体存什么值无所谓，因为不会用到它的值 加入哨兵节点后，代码会变得比较简单，先看几个工具方法 1234567891011121314151617181920212223public class SinglyLinkedListSentinel &#123; // ... // 根据索引获取节点 private Node findNode(int index) &#123; int i = -1; for (Node curr = this.head; curr != null; curr = curr.next, i++) &#123; if (i == index) &#123; return curr; &#125; &#125; return null; &#125; // 获取最后一个节点 private Node findLast() &#123; Node curr; for (curr = this.head; curr.next != null; ) &#123; curr = curr.next; &#125; return curr; &#125;&#125; findNode 与之前类似，只是 i 初始值设置为 -1 对应哨兵，实际传入的 index 也是 $[-1, \\infty)$ findLast 绝不会返回 null 了，就算没有其它节点，也会返回哨兵作为最后一个节点 这样，代码简化为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SinglyLinkedListSentinel &#123; // ... public void addLast(int value) &#123; Node last = findLast(); /* 改动前 if (last == null) &#123; this.head = new Node(value, null); return; &#125; */ last.next = new Node(value, null); &#125; public void insert(int index, int value) &#123; /* 改动前 if (index == 0) &#123; this.head = new Node(value, this.head); return; &#125; */ // index 传入 0 时，返回的是哨兵 Node prev = findNode(index - 1); if (prev != null) &#123; prev.next = new Node(value, prev.next); &#125; else &#123; throw illegalIndex(index); &#125; &#125; public void remove(int index) &#123; /* 改动前 if (index == 0) &#123; if (this.head != null) &#123; this.head = this.head.next; return; &#125; else &#123; throw illegalIndex(index); &#125; &#125; */ // index 传入 0 时，返回的是哨兵 Node prev = findNode(index - 1); Node curr; if (prev != null &amp;&amp; (curr = prev.next) != null) &#123; prev.next = curr.next; &#125; else &#123; throw illegalIndex(index); &#125; &#125; public void addFirst(int value) &#123; /* 改动前 this.head = new Node(value, this.head); */ this.head.next = new Node(value, this.head.next); // 也可以视为 insert 的特例, 即 insert(0, value); &#125;&#125; 对于删除，前面说了【最后一个 if 块对应着至少得两个节点的情况】，现在有了哨兵，就凑足了两个节点 4) 双向链表（带哨兵）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class DoublyLinkedListSentinel implements Iterable&lt;Integer&gt; &#123; private final Node head; private final Node tail; public DoublyLinkedListSentinel() &#123; head = new Node(null, 666, null); tail = new Node(null, 888, null); head.next = tail; tail.prev = head; &#125; private Node findNode(int index) &#123; int i = -1; for (Node p = head; p != tail; p = p.next, i++) &#123; if (i == index) &#123; return p; &#125; &#125; return null; &#125; public void addFirst(int value) &#123; insert(0, value); &#125; public void removeFirst() &#123; remove(0); &#125; public void addLast(int value) &#123; Node prev = tail.prev; Node added = new Node(prev, value, tail); prev.next = added; tail.prev = added; &#125; public void removeLast() &#123; Node removed = tail.prev; if (removed == head) &#123; throw illegalIndex(0); &#125; Node prev = removed.prev; prev.next = tail; tail.prev = prev; &#125; public void insert(int index, int value) &#123; Node prev = findNode(index - 1); if (prev == null) &#123; throw illegalIndex(index); &#125; Node next = prev.next; Node inserted = new Node(prev, value, next); prev.next = inserted; next.prev = inserted; &#125; public void remove(int index) &#123; Node prev = findNode(index - 1); if (prev == null) &#123; throw illegalIndex(index); &#125; Node removed = prev.next; if (removed == tail) &#123; throw illegalIndex(index); &#125; Node next = removed.next; prev.next = next; next.prev = prev; &#125; private IllegalArgumentException illegalIndex(int index) &#123; return new IllegalArgumentException( String.format(&quot;index [%d] 不合法%n&quot;, index)); &#125; @Override public Iterator&lt;Integer&gt; iterator() &#123; return new Iterator&lt;Integer&gt;() &#123; Node p = head.next; @Override public boolean hasNext() &#123; return p != tail; &#125; @Override public Integer next() &#123; int value = p.value; p = p.next; return value; &#125; &#125;; &#125; static class Node &#123; Node prev; int value; Node next; public Node(Node prev, int value, Node next) &#123; this.prev = prev; this.value = value; this.next = next; &#125; &#125;&#125; 5) 环形链表（带哨兵）双向环形链表带哨兵，这时哨兵既作为头，也作为尾 参考实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class DoublyLinkedListSentinel implements Iterable&lt;Integer&gt; &#123; @Override public Iterator&lt;Integer&gt; iterator() &#123; return new Iterator&lt;&gt;() &#123; Node p = sentinel.next; @Override public boolean hasNext() &#123; return p != sentinel; &#125; @Override public Integer next() &#123; int value = p.value; p = p.next; return value; &#125; &#125;; &#125; static class Node &#123; Node prev; int value; Node next; public Node(Node prev, int value, Node next) &#123; this.prev = prev; this.value = value; this.next = next; &#125; &#125; private final Node sentinel = new Node(null, -1, null); // 哨兵 public DoublyLinkedListSentinel() &#123; sentinel.next = sentinel; sentinel.prev = sentinel; &#125; /** * 添加到第一个 * @param value 待添加值 */ public void addFirst(int value) &#123; Node next = sentinel.next; Node prev = sentinel; Node added = new Node(prev, value, next); prev.next = added; next.prev = added; &#125; /** * 添加到最后一个 * @param value 待添加值 */ public void addLast(int value) &#123; Node prev = sentinel.prev; Node next = sentinel; Node added = new Node(prev, value, next); prev.next = added; next.prev = added; &#125; /** * 删除第一个 */ public void removeFirst() &#123; Node removed = sentinel.next; if (removed == sentinel) &#123; throw new IllegalArgumentException(&quot;非法&quot;); &#125; Node a = sentinel; Node b = removed.next; a.next = b; b.prev = a; &#125; /** * 删除最后一个 */ public void removeLast() &#123; Node removed = sentinel.prev; if (removed == sentinel) &#123; throw new IllegalArgumentException(&quot;非法&quot;); &#125; Node a = removed.prev; Node b = sentinel; a.next = b; b.prev = a; &#125; /** * 根据值删除节点 * &lt;p&gt;假定 value 在链表中作为 key, 有唯一性&lt;/p&gt; * @param value 待删除值 */ public void removeByValue(int value) &#123; Node removed = findNodeByValue(value); if (removed != null) &#123; Node prev = removed.prev; Node next = removed.next; prev.next = next; next.prev = prev; &#125; &#125; private Node findNodeByValue(int value) &#123; Node p = sentinel.next; while (p != sentinel) &#123; if (p.value == value) &#123; return p; &#125; p = p.next; &#125; return null; &#125;&#125; 习题E01. 反转单向链表-Leetcode 206对应力扣题目 206. 反转链表 - 力扣（LeetCode） 12345678输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]输入：[1,2]输出：[2,1]输入：[]输出：[] 方法1 构造一个新链表，从旧链表依次拿到每个节点，创建新节点添加至新链表头部，完成后新链表即是倒序的 123456789public ListNode reverseList(ListNode o1) &#123; ListNode n1 = null; ListNode p = o1; while (p != null) &#123; n1 = new ListNode(p.val, n1); p = p.next; &#125; return n1;&#125; 评价：简单直白，就是得新创建节点对象 方法2 与方法1 类似，构造一个新链表，从旧链表头部移除节点，添加到新链表头部，完成后新链表即是倒序的，区别在于原题目未提供节点外层的容器类，这里提供一个，另外一个区别是并不去构造新节点 1234567891011121314151617181920static class List &#123; ListNode head; public List(ListNode head) &#123; this.head = head; &#125; public ListNode removeFirst()&#123; ListNode first = head; if (first != null) &#123; head = first.next; &#125; return first; &#125; public void addFirst(ListNode first) &#123; first.next = head; head = first; &#125;&#125; 代码 123456789public ListNode reverseList(ListNode head) &#123; List list1 = new List(head); List list2 = new List(null); ListNode first; while ((first = list1.removeFirst()) != null) &#123; list2.addFirst(first); &#125; return list2.head;&#125; 评价：更加面向对象，如果实际写代码而非刷题，更多会这么做 方法3 递归，在归时让 $5 \\rightarrow 4$，$4 \\rightarrow 3$ … 首先，写一个递归方法，返回值用来拿到最后一个节点 1234567public ListNode reverseList(ListNode p) &#123; if (p == null || p.next == null) &#123; // 不足两个节点 return p; // 最后一个节点 &#125; ListNode last = reverseList(p.next); return last;&#125; 注意1：递归终止条件是 curr.next &#x3D;&#x3D; null，目的是到最后一个节点就结束递归，与之前递归遍历不一样 注意2：需要考虑空链表即 p &#x3D;&#x3D; null 的情况 可以先测试一下 1234567ListNode o5 = new ListNode(5, null);ListNode o4 = new ListNode(4, o5);ListNode o3 = new ListNode(3, o4);ListNode o2 = new ListNode(2, o3);ListNode o1 = new ListNode(1, o2);ListNode n1 = new E01Leetcode206().reverseList(o1);System.out.println(n1); 会打印 1[5] 下面为伪码调用过程，假设节点分别是 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow null$，先忽略返回值 1234567891011121314151617reverseList(ListNode p = 1) &#123; reverseList(ListNode p = 2) &#123; reverseList(ListNode p = 3) &#123; reverseList(ListNode p = 4) &#123; reverseList(ListNode p = 5) &#123; if (p == null || p.next == null) &#123; return p; // 返回5 &#125; &#125; // 此时p是4, p.next是5 &#125; // 此时p是3, p.next是4 &#125; // 此时p是2, p.next是3\t&#125; // 此时p是1, p.next是2&#125; 接下来，从 p &#x3D; 4 开始，要让 $5 \\rightarrow 4$，$4 \\rightarrow 3$ … 123456789101112131415161718reverseList(ListNode p = 1) &#123; reverseList(ListNode p = 2) &#123; reverseList(ListNode p = 3) &#123; reverseList(ListNode p = 4) &#123; reverseList(ListNode p = 5) &#123; if (p == null || p.next == null) &#123; return p; // 返回5 &#125; &#125; // 此时p是4, p.next是5, 要让5指向4,代码写成 p.next.next=p // 还要注意4要指向 null, 否则就死链了 &#125; // 此时p是3, p.next是4 &#125; // 此时p是2, p.next是3\t&#125; // 此时p是1, p.next是2&#125; 最终代码为： 123456789public ListNode reverseList(ListNode p) &#123; if (p == null || p.next == null) &#123; // 不足两个节点 return p; // 最后一个节点 &#125; ListNode last = reverseList(p.next); p.next.next = p; p.next = null; return last;&#125; Q：为啥不能在递的过程中倒序？ A：比如 $ 1 \\rightarrow 2 \\rightarrow 3 $ 如果递的过程中让 $2 \\rightarrow 1$ 那么此时 $2 \\rightarrow 3$ 就被覆盖，不知道接下来递给谁 而归的时候让 $3 \\rightarrow 2$ 不会影响上一层的 $1 \\rightarrow 2$ 评价：单向链表没有 prev 指针，但利用递归的特性【记住了】链表每次调用时相邻两个节点是谁 方法4 从链表每次拿到第二个节点，将其从链表断开，插入头部，直至它为 null 结束 设置指针 o1(旧头)、n1(新头)、o2(旧老二)，分别指向第一，第一，第二节点 $\\frac{n1 \\ o1}{1} \\rightarrow \\frac{o2}{2} \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow null$ 将 o2 节点从链表断开，即 o1 节点指向第三节点 $ \\frac{n1 \\ o1}{1} \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow null$ ，$\\frac{o2}{2}$ o2 节点链入链表头部，即 $\\frac{o2}{2} \\rightarrow \\frac{n1 \\ o1}{1} \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow null$ n1 指向 o2 $\\frac{n1 \\ o2}{2} \\rightarrow \\frac{o1}{1} \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow null$ o2 指向 o1 的下一个节点，即 $\\frac{n1}{2} \\rightarrow \\frac{o1}{1} \\rightarrow \\frac{o2}{3} \\rightarrow 4 \\rightarrow 5 \\rightarrow null$ 重复以上 $2\\sim5$ 步，直到 o2 指向 null 还应当考虑边界条件，即链表中不满两个元素时，无需走以上逻辑 参考答案 1234567891011121314public ListNode reverseList(ListNode o1) &#123; if (o1 == null || o1.next == null) &#123; // 不足两个节点 return o1; &#125; ListNode o2 = o1.next; ListNode n1 = o1; while (o2 != null) &#123; o1.next = o2.next; o2.next = n1; n1 = o2; o2 = o1.next; &#125; return n1;&#125; 方法5 要点：把链表分成两部分，思路就是不断从链表2的头，往链表1的头搬移 n1 指向 null，代表新链表一开始没有元素，o1 指向原链表的首节点 $\\frac{n1}{null}$，$\\frac{o1}{1} \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow null$ 开始循环，o2 指向原链表次节点 $\\frac{n1}{null}$，$\\frac{o1}{1} \\rightarrow \\frac{o2}{2} \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow null$ 搬移 $\\frac{o1}{1} \\rightarrow \\frac{n1}{null}$ ， $\\frac{o2}{2} \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow null$ 指针复位 $\\frac{n1}{1} \\rightarrow null$ ， $\\frac{o1 \\ o2}{2} \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow null$ 重复 $2\\sim4$ 步 当 o1 &#x3D; null 时退出循环 参考答案 12345678910111213public ListNode reverseList(ListNode o1) &#123; if (o1 == null || o1.next == null) &#123; return o1; &#125; ListNode n1 = null; while (o1 != null) &#123; ListNode o2 = o1.next; o1.next = n1; n1 = o1; o1 = o2; &#125; return n1;&#125; 评价：本质上与方法2 相同，只是方法2更为面向对象 E02. 根据值删除节点-Leetcode 203例如 12345678输入：head = [1,2,6,3,6], val = 6输出：[1,2,3]输入：head = [], val = 1输出：[]输入：head = [7,7,7,7], val = 7输出：[] 方法1 图中 s 代表 sentinel 哨兵（如果不加哨兵，则删除第一个节点要特殊处理），例如要删除 6 12p1 p2s -&gt; 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 6 -&gt; null 如果 p2 不等于目标，则 p1，p2 不断后移 12345 p1 p2s -&gt; 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 6 -&gt; null p1 p2s -&gt; 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 6 -&gt; null p2 &#x3D;&#x3D; 6，删除它，注意 p1 此时保持不变，p2 后移 12 p1 p2s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; null p2 不等于目标，则 p1，p2 不断后移 12 p1 p2s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; null p2 &#x3D;&#x3D; 6，删除它，注意 p1 此时保持不变，p2 后移 12 p1 p2s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; null p2 &#x3D;&#x3D; null 退出循环 最后代码 12345678910111213public ListNode removeElements(ListNode head, int val) &#123; ListNode sentinel = new ListNode(-1, head); ListNode p1 = sentinel; ListNode p2; while ((p2 = p1.next) != null) &#123; if (p2.val == val) &#123; p1.next = p2.next; &#125; else &#123; p1 = p1.next; &#125; &#125; return sentinel.next;&#125; 方法2 思路，递归函数负责返回：从当前节点（我）开始，完成删除的子链表 若我与 v 相等，应该返回下一个节点递归结果 若我与 v 不等，应该返回我，但我的 next 应该更新（让我能带上后续删过的子链表） 1234567891011121314151617removeElements(ListNode p=1, int v=6)&#123; 1.next=removeElements(ListNode p=2, int v=6)&#123; 2.next=removeElements(ListNode p=6, int v=6)&#123; removeElements(ListNode p=3, int v=6)&#123; 3.next=removeElements(ListNode p=6, int v=6)&#123; removeElements(ListNode p=null, int v=6)&#123; // 没有节点,返回 return null &#125; &#125; return 3 &#125; &#125; return 2 &#125; return 1&#125; 代码 1234567891011public ListNode removeElements(ListNode head, int val) &#123; if (head == null) &#123; return null; &#125; if (head.val == val) &#123; return removeElements(head.next, val); &#125; else &#123; head.next = removeElements(head.next, val); return head; &#125;&#125; E03. 删除倒数节点-Leetcode 19例如 12345678输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]输入：head = [1], n = 1输出：[]输入：head = [1,2], n = 1输出：[1] 另外题目提示 链表至少一个节点 n 只会在合理范围 方法1 思路，写一个递归函数，用来返回下一个节点的倒数序号 123456789101112131415161718192021recursion(ListNode p=1, int n=2) &#123; recursion(ListNode p=2, int n=2) &#123; recursion(ListNode p=3, int n=2) &#123; recursion(ListNode p=4, int n=2) &#123; recursion(ListNode p=5, int n=2) &#123; recursion(ListNode p=null, int n=2) &#123; return 0; // 最内层序号0 &#125; return 1; // 上一次返回值+1 &#125; return 2; &#125; if(返回值 == n == 2) &#123; // 删除 next &#125; return 3; &#125; return 4;\t&#125; return 5;&#125; 但上述代码有一个问题，就是若删除的是第一个节点，它没有上一个节点，因此可以加一个哨兵来解决 代码 12345678910111213141516public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode sentinel = new ListNode(-1, head); recursion(sentinel, n); return sentinel.next;&#125;public int recursion(ListNode p, int n) &#123; if (p == null) &#123; return 0; &#125; int nth = recursion(p.next, n); if (nth == n) &#123; p.next = p.next.next; &#125; return nth + 1;&#125; Q：p.next.next 不怕空指针吗？ A： p 是待删除节点的上一个节点，如果能递归回到 p，那么 p.next 肯定有值，不会是 null 且题目说明了 n &gt;&#x3D;1，不会因为 nth &#x3D;&#x3D; 0 而让 p.next 指向最后的 null 方法2 快慢指针，p1 指向待删节点的上一个，p2 先走 n + 1 步 123456789101112131415161718i=0p2s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null i=1 p2s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null i=2 p2s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null i=3 从此开始 p1 p2 依次向右平移, 直到 p2 移动到末尾p1 p2s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null p1 p2s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null 代码 1234567891011121314public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode s = new ListNode(-1, head); ListNode p1 = s; ListNode p2 = s; for (int i = 0; i &lt; n + 1; i++) &#123; p2 = p2.next; &#125; while (p2 != null) &#123; p1 = p1.next; p2 = p2.next; &#125; p1.next = p1.next.next; return s.next;&#125; 方法3 123456789101112131415161718192021222324252627public ListNode removeNthFromEnd(ListNode head, int n) &#123; Composite c = recursion(head, n); return c.node;&#125;static class Composite &#123; ListNode node; int nth; public Composite(ListNode node, int nth) &#123; this.node = node; this.nth = nth; &#125;&#125;public Composite recursion(ListNode p, int n) &#123; if (p == null) &#123; return new Composite(null, 1); &#125; Composite c = recursion(p.next, n); if (c.nth != n) &#123; p.next = c.node; c.node = p; &#125; c.nth +=1; return c;&#125; E04. 有序链表去重-Leetcode 83例如 12345输入：head = [1,1,2]输出：[1,2]输入：head = [1,1,2,3,3]输出：[1,2,3] 注意：重复元素保留一个 方法1 12p1 p21 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; null p1.val &#x3D;&#x3D; p2.val 那么删除 p2，注意 p1 此时保持不变 12p1 p21 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; null p1.val !&#x3D; p2.val 那么 p1，p2 向后移动 12345 p1 p21 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; null p1 p21 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; null p1.val &#x3D;&#x3D; p2.val 那么删除 p2 12 p1 p21 -&gt; 2 -&gt; 3 -&gt; null 当 p2 &#x3D;&#x3D; null 退出循环 代码 1234567891011121314151617public ListNode deleteDuplicates(ListNode head) &#123; // 链表节点 &lt; 2 if (head == null || head.next == null) &#123; return head; &#125; // 链表节点 &gt;= 2 ListNode p1 = head; ListNode p2; while ((p2 = p1.next) != null) &#123; if (p1.val == p2.val) &#123; p1.next = p2.next; &#125; else &#123; p1 = p1.next; &#125; &#125; return head;&#125; 方法2 递归函数负责返回：从当前节点（我）开始，完成去重的链表 若我与 next 重复，返回 next 若我与 next 不重复，返回我，但 next 应当更新 1234567891011121314deleteDuplicates(ListNode p=1) &#123; deleteDuplicates(ListNode p=1) &#123; 1.next=deleteDuplicates(ListNode p=2) &#123; 2.next=deleteDuplicates(ListNode p=3) &#123; deleteDuplicates(ListNode p=3) &#123; // 只剩一个节点，返回 return 3 &#125; &#125; return 2 &#125; return 1 &#125;&#125; 代码 1234567891011public ListNode deleteDuplicates(ListNode p) &#123; if (p == null || p.next == null) &#123; return p; &#125; if(p.val == p.next.val) &#123; return deleteDuplicates(p.next); &#125; else &#123; p.next = deleteDuplicates(p.next); return p; &#125;&#125; E05. 有序链表去重-Leetcode 82例如 12345输入：head = [1,2,3,3,4,4,5]输出：[1,2,5]输入：head = [1,1,1,2,3]输出：[2,3] 注意：重复元素一个不留 方法1 递归函数负责返回：从当前节点（我）开始，完成去重的链表 若我与 next 重复，一直找到下一个不重复的节点，以它的返回结果为准 若我与 next 不重复，返回我，同时更新 next 1234567891011121314deleteDuplicates(ListNode p = 1) &#123; // 找下个不重复的\tdeleteDuplicates(ListNode p = 1) &#123; deleteDuplicates(ListNode p = 1) &#123; deleteDuplicates(ListNode p = 2) &#123; 2.next=deleteDuplicates(ListNode p = 3) &#123; // 只剩一个节点，返回 return 3 &#125; return 2 &#125; &#125; &#125;&#125; 代码 123456789101112131415public ListNode deleteDuplicates(ListNode p) &#123; if (p == null || p.next == null) &#123; return p; &#125; if (p.val == p.next.val) &#123; ListNode x = p.next.next; while (x != null &amp;&amp; x.val == p.val) &#123; x = x.next; &#125; return deleteDuplicates(x); &#125; else &#123; p.next = deleteDuplicates(p.next); return p; &#125;&#125; 方法2 p1 是待删除的上一个节点，每次循环对比 p2、p3 的值 如果 p2 与 p3 的值重复，那么 p3 继续后移，直到找到与 p2 不重复的节点，p1 指向 p3 完成删除 如果 p2 与 p3 的值不重复，p1，p2，p3 向后平移一位，继续上面的操作 p2 或 p3 为 null 退出循环 p2 为 null 的情况，比如链表为 1 1 1 null 1234567891011121314151617p1 p2 p3s, 1, 1, 1, 2, 3, nullp1 p2 p3s, 1, 1, 1, 2, 3, nullp1 p2 p3s, 1, 1, 1, 2, 3, nullp1 p3s, 2, 3, nullp1 p2 p3s, 2, 3, null p1 p2 p3s, 2, 3, null 代码 123456789101112131415161718192021public ListNode deleteDuplicates(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode s = new ListNode(-1, head); ListNode p1 = s; ListNode p2; ListNode p3; while ((p2 = p1.next) != null &amp;&amp; (p3 = p2.next) != null) &#123; if (p2.val == p3.val) &#123; while ((p3 = p3.next) != null &amp;&amp; p3.val == p2.val) &#123; &#125; p1.next = p3; &#125; else &#123; p1 = p1.next; &#125; &#125; return s.next;&#125; E06. 合并有序链表-Leetcode 21例 12345678输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4] 输入：l1 = [], l2 = []输出：[]输入：l1 = [], l2 = [0]输出：[0] 方法1 谁小，把谁链给 p，p 和小的都向后平移一位 当 p1、p2 有一个为 null，退出循环，把不为 null 的链给 p 12345678p11\t3\t8\t9\tnullp22\t4\tnullp s\tnull 代码 123456789101112131415161718192021public ListNode mergeTwoLists(ListNode p1, ListNode p2) &#123; ListNode s = new ListNode(-1, null); ListNode p = s; while (p1 != null &amp;&amp; p2 != null) &#123; if (p1.val &lt; p2.val) &#123; p.next = p1; p1 = p1.next; &#125; else &#123; p.next = p2; p2 = p2.next; &#125; p = p.next; &#125; if (p1 != null) &#123; p.next = p1; &#125; if (p2 != null) &#123; p.next = p2; &#125; return s.next;&#125; 可以自行验证例中后两种情况 方法2 递归函数应该返回 更小的那个链表节点，并把它剩余节点与另一个链表再次递归 返回之前，更新此节点的 next 123456789101112131415mergeTwoLists(p1=[1,3,8,9], p2=[2,4]) &#123; 1.next=mergeTwoLists(p1=[3,8,9], p2=[2,4]) &#123; 2.next=mergeTwoLists(p1=[3,8,9], p2=[4]) &#123; 3.next=mergeTwoLists(p1=[8,9], p2=[4]) &#123; 4.next=mergeTwoLists(p1=[8,9], p2=null) &#123; return [8,9] &#125; return 4 &#125; return 3 &#125; return 2 &#125;\treturn 1&#125; E07. 合并多个有序链表-Leetcode 23例 12345678910输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 方法1 递归 123456789101112131415161718public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) &#123; return null; &#125; return split(lists, 0, lists.length - 1);&#125;public ListNode split(ListNode[] lists, int i, int j) &#123; System.out.println(i + &quot; &quot; + j); if (j == i) &#123; return lists[i]; &#125; int m = (i + j) &gt;&gt;&gt; 1; return mergeTwoLists( split(lists, i, m), split(lists, m + 1, j) );&#125; 还可以用优先级队列求解，这个放在后面讲 E08. 查找链表中间节点-Leetcode 876例如 12345输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6]) 偶数节点时，中间点是靠右的那个 解法：快慢指针，快指针一次走两步，慢指针一次走一步，当快指针到链表结尾时，慢指针恰好走到链表的一半 12345678910public ListNode middleNode(ListNode head) &#123; ListNode p1 = head;\t// 慢指针，中间点 ListNode p2 = head;\t// 快指针 while (p2 != null &amp;&amp; p2.next != null) &#123; p1 = p1.next; p2 = p2.next; p2 = p2.next; &#125; return p1;&#125; E09. 回文链表-Leetcode 234所谓回文指正着读、反着读，结果一样，例如 12[1,2,2,1][1,2,3,2,1] 它们都是回文链表，不是回文的例子 1[1,2,3,1] --反过来--&gt; [1,3,2,1] 解法 1234567891011121314151617181920212223242526272829303132333435363738/* 步骤1. 找中间点 步骤2. 中间点后半个链表反转 步骤3. 反转后链表与原链表逐一比较*/public boolean isPalindrome(ListNode head) &#123; ListNode middle = middle(head); ListNode newHead = reverse(middle); while (newHead != null) &#123; if (newHead.val != head.val) &#123; return false; &#125; newHead = newHead.next; head = head.next; &#125; return true;&#125;private ListNode reverse(ListNode o1) &#123; ListNode n1 = null; while (o1 != null) &#123; ListNode o2 = o1.next; o1.next = n1; n1 = o1; o1 = o2; &#125; return n1;&#125;private ListNode middle(ListNode head) &#123; ListNode p1 = head; // 慢 ListNode p2 = head; // 快 while (p2 != null &amp;&amp; p2.next != null) &#123; p1 = p1.next; p2 = p2.next.next; &#125; return p1;&#125; 优化后解法 12345678910111213141516171819202122232425262728293031public boolean isPalindrome(ListNode h1) &#123; if (h1 == null || h1.next == null) &#123; return true; &#125; ListNode p1 = h1; // 慢指针，中间点 ListNode p2 = h1; // 快指针 ListNode n1 = null;\t// 新头 ListNode o1 = h1;\t// 旧头 // 快慢指针找中间点 while (p2 != null &amp;&amp; p2.next != null) &#123; p1 = p1.next; p2 = p2.next.next; // 反转前半部分 o1.next = n1; n1 = o1; o1 = p1; &#125; if (p2 != null) &#123; // 节点数为奇数 p1 = p1.next; &#125; // 同步比较新头和后半部分 while (n1 != null) &#123; if (n1.val != p1.val) &#123; return false; &#125; p1 = p1.next; n1 = n1.next; &#125; return true;&#125; E10. 环形链表-Leetcode 141本题以及下题，实际是 Floyd’s Tortoise and Hare Algorithm （Floyd 龟兔赛跑算法）[^15] 除了 Floyd 判环算法外，还有其它的判环算法，详见 https://en.wikipedia.org/wiki/Cycle_detection 如果链表上存在环，那么在环上以不同速度前进的两个指针必定会在某个时刻相遇。算法分为两个阶段 阶段1 龟一次走一步，兔子一次走两步 当兔子能走到终点时，不存在环 当兔子能追上龟时，可以判断存在环 阶段2 从它们第一次相遇开始，龟回到起点，兔子保持原位不变 龟和兔子一次都走一步 当再次相遇时，地点就是环的入口 为什么呢？ 设起点到入口走 a 步（本例是 7），绕环一圈长度为 b（本例是 5）， 那么从起点开始，走 a + 绕环 n 圈，都能找到环入口 第一次相遇时 兔走了 a + 绕环 n 圈（本例 2 圈） + k，k 是它们相遇距环入口位置（本例 3，不重要） 龟走了 a + 绕环 n 圈（本例 0 圈） + k，当然它绕的圈数比兔少 兔走的距离是龟的两倍，所以龟走的 &#x3D; 兔走的 - 龟走的 &#x3D; 绕环 n 圈 而前面分析过，如果走 a + 绕环 n 圈，都能找到环入口，因此从相遇点开始，再走 a 步，就是环入口 阶段1 参考代码（判断是否有环） 123456789101112public boolean hasCycle(ListNode head) &#123; ListNode h = head; // 兔 ListNode t = head; // 龟 while (h != null &amp;&amp; h.next != null) &#123; t = t.next; h = h.next.next; if(h == t)&#123; return true; &#125; &#125; return false;&#125; E11. 环形链表-Leetcode 142阶段2 参考代码（找到环入口） 12345678910111213141516171819public ListNode detectCycle(ListNode head) &#123; ListNode t = head; // 龟 ListNode h = head; // 兔 while (h != null &amp;&amp; h.next != null) &#123; t = t.next; h = h.next.next; if (h == t) &#123; t = head; while (true) &#123; if (h == t) &#123; return h; &#125; h = h.next; t = t.next; &#125; &#125; &#125; return null;&#125; 还有一道扩展题目，也可以用判环算法思想来解：就是 287 题，寻找重复数 Ex1. 删除节点-Leetcode 237这道题目比较简单，留给大家自己练习 例如 123456输入：head = [4,5,1,9], node = 5输出：[4,1,9]输入：head = [4,5,1,9], node = 1输出：[4,5,9] 注意：被删除的节点不是末尾节点 参考答案 123456789101112131415161718192021public class Ex1Leetcode237 &#123; /** * * @param node 待删除节点, 题目已说明肯定不是最后一个节点 */ public void deleteNode(ListNode node) &#123; node.val = node.next.val; // 下一个节点值赋值给待&quot;删除&quot;节点 node.next = node.next.next; // 把下一个节点删除 &#125; public static void main(String[] args) &#123; ListNode o5 = new ListNode(5, null); ListNode o4 = new ListNode(4, o5); ListNode o3 = new ListNode(3, o4); ListNode o2 = new ListNode(2, o3); ListNode o1 = new ListNode(1, o2); System.out.println(o1); new E0xLeetcode237().deleteNode(o3); System.out.println(o1); &#125;&#125; 输出 12[1,2,3,4,5][1,2,4,5] Ex2. 共尾链表-Leetcode 160原题叫做相交链表，个人觉得用共尾链表更形象些，此题更像是一道脑筋急转弯，留给大家练习 例如，下图的两个链表 [1, 2, 4, 5] 与 [3, 4, 5] 它们中 [4, 5] 是相同的，此时应返回节点 4 非共尾的情况，如下图所示，此时返回 null 思路，称两个链表为 a&#x3D;[1, 2, 4, 5]，b&#x3D;[3, 4, 5]，图中用 N 代表 null 遍历 a，遇到 null 时改道遍历 b 与此同时，遍历 b，遇到 null 时改道遍历 a 在此过程中，如果遇到相同的节点，即为找寻目标，返回即可，如下图中的第二次出现的 4 相同节点应该比较其引用值，图中数字只是为了便于区分 121\t2\t4\t5\tN\t3\t4\t5\tN3\t4\t5\tN\t1\t2\t4\t5\tN 如果两个链表长度相同，则可以更早找到目标，例如 a&#x3D;[1, 4, 5]，b&#x3D;[3, 4, 5]，第一次出现 4 时，即可返回 121\t4\t5\tN\t3\t4\t5\tN3\t4\t5\tN\t1\t4\t5\tN 如果是非共尾的情况，如 a&#x3D;[1, 2, 4]，b&#x3D;[3, 5]，可以看到，唯一相等的情况，是遍历到最后那个 N 此时退出循环 121\t2\t4\tN\t3\t5\tN3\t5\tN\t1\t2\t4\tN 代码 12345678910111213141516171819public ListNode getIntersectionNode(ListNode a, ListNode b) &#123; ListNode p1 = a; ListNode p2 = b; while (true) &#123; if (p1 == p2) &#123; return p1; &#125; if (p1 == null) &#123; p1 = b; &#125; else &#123; p1 = p1.next; &#125; if (p2 == null) &#123; p2 = a; &#125; else &#123; p2 = p2.next; &#125; &#125;&#125; 2.3 递归1) 概述定义 计算机科学中，递归是一种解决计算问题的方法，其中解决方案取决于同一类问题的更小子集 In computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem. 比如单链表递归遍历的例子： 12345678void f(Node node) &#123; if(node == null) &#123; return; &#125; println(&quot;before:&quot; + node.value) f(node.next); println(&quot;after:&quot; + node.value)&#125; 说明： 自己调用自己，如果说每个函数对应着一种解决方案，自己调用自己意味着解决方案是一样的（有规律的） 每次调用，函数处理的数据会较上次缩减（子集），而且最后会缩减至无需继续递归 内层函数调用（子集处理）完成，外层函数才能算调用完成 原理 假设链表中有 3 个节点，value 分别为 1，2，3，以上代码的执行流程就类似于下面的伪码 12345678910111213141516171819// 1 -&gt; 2 -&gt; 3 -&gt; null f(1)void f(Node node = 1) &#123; println(&quot;before:&quot; + node.value) // 1 void f(Node node = 2) &#123; println(&quot;before:&quot; + node.value) // 2 void f(Node node = 3) &#123; println(&quot;before:&quot; + node.value) // 3 void f(Node node = null) &#123; if(node == null) &#123; return; &#125; &#125; println(&quot;after:&quot; + node.value) // 3 &#125; println(&quot;after:&quot; + node.value) // 2 &#125; println(&quot;after:&quot; + node.value) // 1&#125; 思路 确定能否使用递归求解 推导出递推关系，即父问题与子问题的关系，以及递归的结束条件 例如之前遍历链表的递推关系为$$f(n) &#x3D;\\begin{cases}停止&amp; n &#x3D; null \\f(n.next) &amp; n eq null\\end{cases}$$ 深入到最里层叫做递 从最里层出来叫做归 在递的过程中，外层函数内的局部变量（以及方法参数）并未消失，归的时候还可以用到 2) 单路递归 Single RecursionE01. 阶乘用递归方法求阶乘 阶乘的定义 $n!&#x3D; 1⋅2⋅3⋯(n-2)⋅(n-1)⋅n$，其中 $n$ 为自然数，当然 $0! &#x3D; 1$ 递推关系 $$f(n) &#x3D;\\begin{cases}1 &amp; n &#x3D; 1 * f(n-1) &amp; n &gt; 1\\end{cases}$$ 代码 123456private static int f(int n) &#123; if (n == 1) &#123; return 1; &#125; return n * f(n - 1);&#125; 拆解伪码如下，假设 n 初始值为 3 123456789f(int n = 3) &#123; // 解决不了,递 return 3 * f(int n = 2) &#123; // 解决不了,继续递 return 2 * f(int n = 1) &#123; if (n == 1) &#123; // 可以解决, 开始归 return 1; &#125; &#125; &#125;&#125; E02. 反向打印字符串用递归反向打印字符串，n 为字符在整个字符串 str 中的索引位置 递：n 从 0 开始，每次 n + 1，一直递到 n &#x3D;&#x3D; str.length() - 1 归：从 n &#x3D;&#x3D; str.length() 开始归，从归打印，自然是逆序的 递推关系$$f(n) &#x3D;\\begin{cases}停止 &amp; n &#x3D; str.length() \\f(n+1) &amp; 0 \\leq n \\leq str.length() - 1\\end{cases}$$代码为 1234567public static void reversePrint(String str, int index) &#123; if (index == str.length()) &#123; return; &#125; reversePrint(str, index + 1); System.out.println(str.charAt(index));&#125; 拆解伪码如下，假设字符串为 “abc” 1234567891011121314void reversePrint(String str, int index = 0) &#123; void reversePrint(String str, int index = 1) &#123; void reversePrint(String str, int index = 2) &#123; void reversePrint(String str, int index = 3) &#123; if (index == str.length()) &#123; return; // 开始归 &#125; &#125; System.out.println(str.charAt(index)); // 打印 c &#125; System.out.println(str.charAt(index)); // 打印 b &#125; System.out.println(str.charAt(index)); // 打印 a&#125; E03. 二分查找（单路递归）1234567891011121314151617public static int binarySearch(int[] a, int target) &#123; return recursion(a, target, 0, a.length - 1);&#125;public static int recursion(int[] a, int target, int i, int j) &#123; if (i &gt; j) &#123; return -1; &#125; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; return recursion(a, target, i, m - 1); &#125; else if (a[m] &lt; target) &#123; return recursion(a, target, m + 1, j); &#125; else &#123; return m; &#125;&#125; E04. 冒泡排序（单路递归）12345678910111213141516171819202122232425public static void main(String[] args) &#123; int[] a = &#123;3, 2, 6, 1, 5, 4, 7&#125;; bubble(a, 0, a.length - 1); System.out.println(Arrays.toString(a));&#125;private static void bubble(int[] a, int low, int high) &#123; if(low == high) &#123; return; &#125; int j = low; for (int i = low; i &lt; high; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; swap(a, i, i + 1); j = i; &#125; &#125; bubble(a, low, j);&#125;private static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t;&#125; low 与 high 为未排序范围 j 表示的是未排序的边界，下一次递归时的 high 发生交换，意味着有无序情况 最后一次交换（以后没有无序）时，左侧 i 仍是无序，右侧 i+1 已然有序 视频中讲解的是只考虑 high 边界的情况，参考以上代码，理解在 low .. high 范围内的处理方法 E05. 插入排序（单路递归）123456789101112131415161718192021public static void main(String[] args) &#123; int[] a = &#123;3, 2, 6, 1, 5, 7, 4&#125;; insertion(a, 1, a.length - 1); System.out.println(Arrays.toString(a));&#125;private static void insertion(int[] a, int low, int high) &#123; if (low &gt; high) &#123; return; &#125; int i = low - 1; int t = a[low]; while (i &gt;= 0 &amp;&amp; a[i] &gt; i) &#123; a[i + 1] = a[i]; i--; &#125; if(i + 1 != low) &#123; a[i + 1] = t; &#125; insertion(a, low + 1, high);&#125; 已排序区域：[0 .. i .. low-1] 未排序区域：[low .. high] 视频中讲解的是只考虑 low 边界的情况，参考以上代码，理解 low-1 .. high 范围内的处理方法 扩展：利用二分查找 leftmost 版本，改进寻找插入位置的代码 E06. 约瑟夫问题[^16]（单路递归）$n$ 个人排成圆圈，从头开始报数，每次数到第 $m$ 个人（$m$ 从 $1$ 开始）杀之，继续从下一个人重复以上过程，求最后活下来的人是谁？ 方法1 根据最后的存活者 a 倒推出它在上一轮的索引号 f(n,m) 本轮索引 为了让 a 是这个索引，上一轮应当这样排 规律 f(1,3) 0 x x x a (0 + 3) % 2 f(2,3) 1 x x x 0 a (1 + 3) % 3 f(3,3) 1 x x x 0 a (1 + 3) % 4 f(4,3) 0 x x x a (0 + 3) % 5 f(5,3) 3 x x x 0 1 2 a (3 + 3) % 6 f(6,3) 0 x x x a 方法2 设 n 为总人数，m 为报数次数，解返回的是这些人的索引，从0开始 f(n, m) 解 规律 f(1, 3) 0 f(2, 3) 0 1 &#x3D;&gt; 1 3%2&#x3D;1 f(3, 3) 0 1 2 &#x3D;&gt; 0 1 3%3&#x3D;0 f(4, 3) 0 1 2 3 &#x3D;&gt; 3 0 1 3%4&#x3D;3 f(5, 3) 0 1 2 3 4 &#x3D;&gt; 3 4 0 1 3%5&#x3D;3 f(6, 3) 0 1 2 3 4 5 &#x3D;&gt; 3 4 5 0 1 3%6&#x3D;3 一. 找出等价函数 规律：下次报数的起点为 $k &#x3D; m % n$ 首次出列人的序号是 $k-1$，剩下的的 $n-1$ 个人重新组成约瑟夫环 下次从 $k$ 开始数，序号如下 $k,\\ k+1, \\ …\\ ,\\ 0,\\ 1,\\ k-2$，如上例中 $3\\ 4\\ 5\\ 0\\ 1$ 这个函数称之为 $g(n-1,m)$，它的最终结果与 $f(n,m)$ 是相同的。 二. 找到映射函数 现在想办法找到 $g(n-1,m)$ 与 $f(n-1, m)$ 的对应关系，即$$3 \\rightarrow 0 \\4 \\rightarrow 1 \\5 \\rightarrow 2 \\0 \\rightarrow 3 \\1 \\rightarrow 4 \\$$映射函数为$$mapping(x) &#x3D;\\begin{cases}x-k &amp; x&#x3D;[k..n-1] \\x+n-k &amp; x&#x3D;[0..k-2]\\end{cases}$$等价于下面函数$$mapping(x) &#x3D; (x + n - k)%{n}$$代入测试一下$$3 \\rightarrow (3+6-3)%6 \\rightarrow 0 \\4 \\rightarrow (4+6-3)%6 \\rightarrow 1 \\5 \\rightarrow (5+6-3)%6 \\rightarrow 2 \\0 \\rightarrow (0+6-3)%6 \\rightarrow 3 \\1 \\rightarrow (1+6-3)%6 \\rightarrow 4 \\$$综上有$$f(n-1,m) &#x3D; mapping(g(n-1,m))$$ 三. 求逆映射函数 映射函数是根据 x 计算 y，逆映射函数即根据 y 得到 x$$mapping^{-1}(x) &#x3D; (x + k)%n$$代入测试一下$$0 \\rightarrow (0+3)%6 \\rightarrow 3 \\1 \\rightarrow (1+3)%6 \\rightarrow 4 \\2 \\rightarrow (2+3)%6 \\rightarrow 5 \\3 \\rightarrow (3+3)%6 \\rightarrow 0 \\4 \\rightarrow (4+3)%6 \\rightarrow 1 \\$$因此可以求得$$g(n-1,m) &#x3D; mapping^{-1}(f(n-1,m))$$ 四. 递推式 代入推导$$\\begin{aligned}f(n,m) &#x3D; \\ &amp; g(n-1,m) \\&#x3D; \\ &amp; mapping^{-1}(f(n-1,m)) \\&#x3D; \\ &amp; (f(n-1,m) + k) % n \\&#x3D; \\ &amp; (f(n-1,m) + m%n) % n \\&#x3D; \\ &amp; (f(n-1,m) + m) % n \\\\end{aligned}$$最后一步化简是利用了模运算法则 $(a+b)%n &#x3D; (a%n + b%n) %n$ 例如 $(6+6)%5 &#x3D; 2 &#x3D; (6+6%5)%5$ $(6+5)%5 &#x3D; 1 &#x3D; (6+5%5)%5$ $(6+4)%5 &#x3D; 0 &#x3D; (6+4%5)%5$ 最终递推式$$f(n,m) &#x3D;\\begin{cases}(f(n-1,m) + m) % n &amp; n&gt;1\\0 &amp; n &#x3D; 1\\end{cases}$$ 3) 多路递归 Multi RecursionE01. 斐波那契数列-Leetcode 70 之前的例子是每个递归函数只包含一个自身的调用，这称之为 single recursion 如果每个递归函数例包含多个自身调用，称之为 multi recursion 递推关系$$f(n) &#x3D;\\begin{cases}0 &amp; n&#x3D;0 \\1 &amp; n&#x3D;1 \\f(n-1) + f(n-2) &amp; n&gt;1\\end{cases}$$ 下面的表格列出了数列的前几项 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 0 1 1 2 3 5 8 13 21 34 55 89 144 233 实现 123456789public static int f(int n) &#123; if (n == 0) &#123; return 0; &#125; if (n == 1) &#123; return 1; &#125; return f(n - 1) + f(n - 2);&#125; 执行流程 绿色代表正在执行（对应递），灰色代表执行结束（对应归） 递不到头，不能归，对应着深度优先搜索 时间复杂度 递归的次数也符合斐波那契规律，$2 * f(n+1)-1$ 时间复杂度推导过程 斐波那契通项公式 $f(n) &#x3D; \\frac{1}{\\sqrt{5}}*({\\frac{1+\\sqrt{5}}{2}}^n - {\\frac{1-\\sqrt{5}}{2}}^n)$ 简化为：$f(n) &#x3D; \\frac{1}{2.236}*({1.618}^n - {(-0.618)}^n)$ 带入递归次数公式 $2\\frac{1}{2.236}({1.618}^{n+1} - {(-0.618)}^{n+1})-1$ 时间复杂度为 $\\Theta(1.618^n)$ 更多 Fibonacci 参考[^8][^9][^10] 以上时间复杂度分析，未考虑大数相加的因素 变体1 - 兔子问题[^8] 第一个月，有一对未成熟的兔子（黑色，注意图中个头较小） 第二个月，它们成熟 第三个月，它们能产下一对新的小兔子（蓝色） 所有兔子遵循相同规律，求第 $n$ 个月的兔子数 分析 兔子问题如何与斐波那契联系起来呢？设第 n 个月兔子数为 $f(n)$ $f(n)$ &#x3D; 上个月兔子数 + 新生的小兔子数 而【新生的小兔子数】实际就是【上个月成熟的兔子数】 因为需要一个月兔子就成熟，所以【上个月成熟的兔子数】也就是【上上个月的兔子数】 上个月兔子数，即 $f(n-1)$ 上上个月的兔子数，即 $f(n-2)$ 因此本质还是斐波那契数列，只是从其第一项开始 变体2 - 青蛙爬楼梯 楼梯有 $n$ 阶 青蛙要爬到楼顶，可以一次跳一阶，也可以一次跳两阶 只能向上跳，问有多少种跳法 分析 n 跳法 规律 1 (1) 暂时看不出 2 (1,1) (2) 暂时看不出 3 (1,1,1) (1,2) (2,1) 暂时看不出 4 (1,1,1,1) (1,2,1) (2,1,1)(1,1,2) (2,2) 最后一跳，跳一个台阶的，基于f(3)最后一跳，跳两个台阶的，基于f(2) 5 … … 因此本质上还是斐波那契数列，只是从其第二项开始 对应 leetcode 题目 70. 爬楼梯 - 力扣（LeetCode） E02. 汉诺塔[^13]（多路递归）Tower of Hanoi，是一个源于印度古老传说：大梵天创建世界时做了三根金刚石柱，在一根柱子从下往上按大小顺序摞着 64 片黄金圆盘，大梵天命令婆罗门把圆盘重新摆放在另一根柱子上，并且规定 一次只能移动一个圆盘 小圆盘上不能放大圆盘 下面的动图演示了4片圆盘的移动方法 使用程序代码模拟圆盘的移动过程，并估算出时间复杂度 思路 假设每根柱子标号 a，b，c，每个圆盘用 1，2，3 … 表示其大小，圆盘初始在 a，要移动到的目标是 c 如果只有一个圆盘，此时是最小问题，可以直接求解 移动圆盘1 $a \\mapsto c$ 如果有两个圆盘，那么 圆盘1 $a \\mapsto b$ 圆盘2 $a \\mapsto c$ 圆盘1 $b \\mapsto c$ 如果有三个圆盘，那么 圆盘12 $a \\mapsto b$ 圆盘3 $a \\mapsto c$ 圆盘12 $b \\mapsto c$ 如果有四个圆盘，那么 圆盘 123 $a \\mapsto b$ 圆盘4 $a \\mapsto c$ 圆盘 123 $b \\mapsto c$ 题解 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class E02HanoiTower &#123; /* 源 借 目 h(4, a, b, c) -&gt; h(3, a, c, b) a -&gt; c h(3, b, a, c) */ static LinkedList&lt;Integer&gt; a = new LinkedList&lt;&gt;(); static LinkedList&lt;Integer&gt; b = new LinkedList&lt;&gt;(); static LinkedList&lt;Integer&gt; c = new LinkedList&lt;&gt;(); static void init(int n) &#123; for (int i = n; i &gt;= 1; i--) &#123; a.add(i); &#125; &#125; static void h(int n, LinkedList&lt;Integer&gt; a, LinkedList&lt;Integer&gt; b, LinkedList&lt;Integer&gt; c) &#123; if (n == 0) &#123; return; &#125; h(n - 1, a, c, b); c.addLast(a.removeLast()); print(); h(n - 1, b, a, c); &#125; private static void print() &#123; System.out.println(&quot;-----------------------&quot;); System.out.println(a); System.out.println(b); System.out.println(c); &#125; public static void main(String[] args) &#123; init(3); print(); h(3, a, b, c); &#125;&#125; E03. 杨辉三角[^6] 分析 把它斜着看 12345 1 1 1 1 2 1 1 3 3 11 4 6 4 1 行 $i$，列 $j$，那么 $[i][j]$ 的取值应为 $[i-1][j-1] + [i-1][j]$ 当 $j&#x3D;0$ 或 $i&#x3D;j$ 时，$[i][j]$ 取值为 $1$ 题解 12345678910111213141516171819public static void print(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; if (i &lt; n - 1) &#123; System.out.printf(&quot;%&quot; + 2 * (n - 1 - i) + &quot;s&quot;, &quot; &quot;); &#125; for (int j = 0; j &lt; i + 1; j++) &#123; System.out.printf(&quot;%-4d&quot;, element(i, j)); &#125; System.out.println(); &#125;&#125;public static int element(int i, int j) &#123; if (j == 0 || i == j) &#123; return 1; &#125; return element(i - 1, j - 1) + element(i - 1, j);&#125; 优化1 是 multiple recursion，因此很多递归调用是重复的，例如 recursion(3, 1) 分解为 recursion(2, 0) + recursion(2, 1) 而 recursion(3, 2) 分解为 recursion(2, 1) + recursion(2, 2) 这里 recursion(2, 1) 就重复调用了，事实上它会重复很多次，可以用 static AtomicInteger counter &#x3D; new AtomicInteger(0) 来查看递归函数的调用总次数 事实上，可以用 memoization 来进行优化： 123456789101112131415161718192021222324public static void print1(int n) &#123; int[][] triangle = new int[n][]; for (int i = 0; i &lt; n; i++) &#123; // 打印空格 triangle[i] = new int[i + 1]; for (int j = 0; j &lt;= i; j++) &#123; System.out.printf(&quot;%-4d&quot;, element1(triangle, i, j)); &#125; System.out.println(); &#125;&#125;public static int element1(int[][] triangle, int i, int j) &#123; if (triangle[i][j] &gt; 0) &#123; return triangle[i][j]; &#125; if (j == 0 || i == j) &#123; triangle[i][j] = 1; return triangle[i][j]; &#125; triangle[i][j] = element1(triangle, i - 1, j - 1) + element1(triangle, i - 1, j); return triangle[i][j];&#125; 将数组作为递归函数内可以访问的遍历，如果 $triangle[i][j]$ 已经有值，说明该元素已经被之前的递归函数计算过，就不必重复计算了 优化2 123456789101112131415161718192021public static void print2(int n) &#123; int[] row = new int[n]; for (int i = 0; i &lt; n; i++) &#123; // 打印空格 createRow(row, i); for (int j = 0; j &lt;= i; j++) &#123; System.out.printf(&quot;%-4d&quot;, row[j]); &#125; System.out.println(); &#125;&#125;private static void createRow(int[] row, int i) &#123; if (i == 0) &#123; row[0] = 1; return; &#125; for (int j = i; j &gt; 0; j--) &#123; row[j] = row[j - 1] + row[j]; &#125;&#125; 注意：还可以通过每一行的前一项计算出下一项，不必借助上一行，这与杨辉三角的另一个特性有关，暂不展开了 其它题目力扣对应题目，但递归不适合在力扣刷高分，因此只列出相关题目，不做刷题讲解了 题号 名称 Leetcode118 杨辉三角 Leetcode119 杨辉三角II 4) 递归优化-记忆法上述代码存在很多重复的计算，例如求 $f(5)$ 递归分解过程 可以看到（颜色相同的是重复的）： $f(3)$ 重复了 2 次 $f(2)$ 重复了 3 次 $f(1)$ 重复了 5 次 $f(0)$ 重复了 3 次 随着 $n$ 的增大，重复次数非常可观，如何优化呢？ Memoization 记忆法（也称备忘录）是一种优化技术，通过存储函数调用结果（通常比较昂贵），当再次出现相同的输入（子问题）时，就能实现加速效果，改进后的代码 1234567891011121314151617public static void main(String[] args) &#123; int n = 13; int[] cache = new int[n + 1]; Arrays.fill(cache, -1); cache[0] = 0; cache[1] = 1; System.out.println(f(cache, n));&#125;public static int f(int[] cache, int n) &#123; if (cache[n] != -1) &#123; return cache[n]; &#125; cache[n] = f(cache, n - 1) + f(cache, n - 2); return cache[n];&#125; 优化后的图示，只要结果被缓存，就不会执行其子问题 改进后的时间复杂度为 $O(n)$ 请自行验证改进后的效果 请自行分析改进后的空间复杂度 注意 记忆法是动态规划的一种情况，强调的是自顶向下的解决 记忆法的本质是空间换时间 5) 递归优化-尾递归爆栈 用递归做 $n + (n-1) + (n-2) … + 1$ 123456public static long sum(long n) &#123; if (n == 1) &#123; return 1; &#125; return n + sum(n - 1);&#125; 在我的机器上 $n &#x3D; 12000$ 时，爆栈了 1234567Exception in thread &quot;main&quot; java.lang.StackOverflowError\tat Test.sum(Test.java:10)\tat Test.sum(Test.java:10)\tat Test.sum(Test.java:10)\tat Test.sum(Test.java:10)\tat Test.sum(Test.java:10)\t... 为什么呢？ 每次方法调用是需要消耗一定的栈内存的，这些内存用来存储方法参数、方法内局部变量、返回地址等等 方法调用占用的内存需要等到方法结束时才会释放 而递归调用我们之前讲过，不到最深不会回头，最内层方法没完成之前，外层方法都结束不了 例如，$sum(3)$ 这个方法内有个需要执行 $3 + sum(2)$，$sum(2)$ 没返回前，加号前面的 $3$ 不能释放 看下面伪码 1234567long sum(long n = 3) &#123; return 3 + long sum(long n = 2) &#123; return 2 + long sum(long n = 1) &#123; return 1; &#125; &#125;&#125; 尾调用 如果函数的最后一步是调用一个函数，那么称为尾调用，例如 123function a() &#123; return b()&#125; 下面三段代码不能叫做尾调用 1234function a() &#123; const c = b() return c&#125; 因为最后一步并非调用函数 123function a() &#123; return b() + 1&#125; 最后一步执行的是加法 123function a(x) &#123; return b() + x&#125; 最后一步执行的是加法 一些语言[^11]的编译器能够对尾调用做优化，例如 123456789101112131415function a() &#123; // 做前面的事 return b() &#125;function b() &#123; // 做前面的事 return c()&#125;function c() &#123; return 1000&#125;a() 没优化之前的伪码 1234567function a() &#123; return function b() &#123; return function c() &#123; return 1000 &#125; &#125;&#125; 优化后伪码如下 123a()b()c() 为何尾递归才能优化？ 调用 a 时 a 返回时发现：没什么可留给 b 的，将来返回的结果 b 提供就可以了，用不着我 a 了，我的内存就可以释放 调用 b 时 b 返回时发现：没什么可留给 c 的，将来返回的结果 c 提供就可以了，用不着我 b 了，我的内存就可以释放 如果调用 a 时 不是尾调用，例如 return b() + 1，那么 a 就不能提前结束，因为它还得利用 b 的结果做加法 尾递归 尾递归是尾调用的一种特例，也就是最后一步执行的是同一个函数 尾递归避免爆栈 安装 Scala Scala 入门 12345object Main &#123; def main(args: Array[String]): Unit = &#123; println(&quot;Hello Scala&quot;) &#125;&#125; Scala 是 java 的近亲，java 中的类都可以拿来重用 类型是放在变量后面的 Unit 表示无返回值，类似于 void 不需要以分号作为结尾，当然加上也对 还是先写一个会爆栈的函数 123456def sum(n: Long): Long = &#123; if (n == 1) &#123; return 1 &#125; return n + sum(n - 1)&#125; Scala 最后一行代码若作为返回值，可以省略 return 不出所料，在 $n &#x3D; 11000$ 时，还是出了异常 12345678println(sum(11000))Exception in thread &quot;main&quot; java.lang.StackOverflowError\tat Main$.sum(Main.scala:25)\tat Main$.sum(Main.scala:25)\tat Main$.sum(Main.scala:25)\tat Main$.sum(Main.scala:25)\t... 这是因为以上代码，还不是尾调用，要想成为尾调用，那么： 最后一行代码，必须是一次函数调用 内层函数必须摆脱与外层函数的关系，内层函数执行后不依赖于外层的变量或常量 123456def sum(n: Long): Long = &#123; if (n == 1) &#123; return 1 &#125; return n + sum(n - 1) // 依赖于外层函数的 n 变量&#125; 如何让它执行后就摆脱对 n 的依赖呢？ 不能等递归回来再做加法，那样就必须保留外层的 n 把 n 当做内层函数的一个参数传进去，这时 n 就属于内层函数了 传参时就完成累加, 不必等回来时累加 1sum(n - 1, n + 累加器) 改写后代码如下 1234567@tailrecdef sum(n: Long, accumulator: Long): Long = &#123; if (n == 1) &#123; return 1 + accumulator &#125; return sum(n - 1, n + accumulator)&#125; accumulator 作为累加器 @tailrec 注解是 scala 提供的，用来检查方法是否符合尾递归 这回 sum(10000000, 0) 也没有问题，打印 50000005000000 执行流程如下，以伪码表示 $sum(4, 0)$ 123456789101112131415161718192021// 首次调用def sum(n = 4, accumulator = 0): Long = &#123; return sum(4 - 1, 4 + accumulator)&#125;// 接下来调用内层 sum, 传参时就完成了累加, 不必等回来时累加，当内层 sum 调用后，外层 sum 空间没必要保留def sum(n = 3, accumulator = 4): Long = &#123; return sum(3 - 1, 3 + accumulator)&#125;// 继续调用内层 sumdef sum(n = 2, accumulator = 7): Long = &#123; return sum(2 - 1, 2 + accumulator)&#125;// 继续调用内层 sum, 这是最后的 sum 调用完就返回最后结果 10, 前面所有其它 sum 的空间早已释放def sum(n = 1, accumulator = 9): Long = &#123; if (1 == 1) &#123; return 1 + accumulator &#125;&#125; 本质上，尾递归优化是将函数的递归调用，变成了函数的循环调用 改循环避免爆栈 12345678public static void main(String[] args) &#123; long n = 100000000; long sum = 0; for (long i = n; i &gt;= 1; i--) &#123; sum += i; &#125; System.out.println(sum);&#125; 6) 递归时间复杂度-Master theorem[^14]若有递归式$$T(n) &#x3D; aT(\\frac{n}{b}) + f(n)$$其中 $T(n)$ 是问题的运行时间，$n$ 是数据规模 $a$ 是子问题个数 $T(\\frac{n}{b})$ 是子问题运行时间，每个子问题被拆成原问题数据规模的 $\\frac{n}{b}$ $f(n)$ 是除递归外执行的计算 令 $x &#x3D; \\log_{b}{a}$，即 $x &#x3D; \\log_{子问题缩小倍数}{子问题个数}$ 那么$$T(n) &#x3D;\\begin{cases}\\Theta(n^x) &amp; f(n) &#x3D; O(n^c) 并且 c \\lt x\\\\Theta(n^x\\log{n}) &amp; f(n) &#x3D; \\Theta(n^x)\\\\Theta(n^c) &amp; f(n) &#x3D; \\Omega(n^c) 并且 c \\gt x\\end{cases}$$ 例1 $T(n) &#x3D; 2T(\\frac{n}{2}) + n^4$ 此时 $x &#x3D; 1 &lt; 4$，由后者决定整个时间复杂度 $\\Theta(n^4)$ 如果觉得对数不好算，可以换为求【$b$ 的几次方能等于 $a$】 例2 $T(n) &#x3D; T(\\frac{7n}{10}) + n$ $a&#x3D;1, b&#x3D;\\frac{10}{7}, x&#x3D;0, c&#x3D;1$ 此时 $x &#x3D; 0 &lt; 1$，由后者决定整个时间复杂度 $\\Theta(n)$ 例3 $T(n) &#x3D; 16T(\\frac{n}{4}) + n^2$ $a&#x3D;16, b&#x3D;4, x&#x3D;2, c&#x3D;2$ 此时 $x&#x3D;2 &#x3D; c$，时间复杂度 $\\Theta(n^2 \\log{n})$ 例4 $T(n)&#x3D;7T(\\frac{n}{3}) + n^2$ $a&#x3D;7, b&#x3D;3, x&#x3D;1.?, c&#x3D;2$ 此时 $x &#x3D; \\log_{3}{7} &lt; 2$，由后者决定整个时间复杂度 $\\Theta(n^2)$ 例5 $T(n) &#x3D; 7T(\\frac{n}{2}) + n^2$ $a&#x3D;7, b&#x3D;2, x&#x3D;2.?, c&#x3D;2$ 此时 $x &#x3D; log_2{7} &gt; 2$，由前者决定整个时间复杂度 $\\Theta(n^{\\log_2{7}})$ 例6 $T(n) &#x3D; 2T(\\frac{n}{4}) + \\sqrt{n}$ $a&#x3D;2, b&#x3D;4, x &#x3D; 0.5, c&#x3D;0.5$ 此时 $x &#x3D; 0.5 &#x3D; c$，时间复杂度 $\\Theta(\\sqrt{n}\\ \\log{n})$ 例7. 二分查找递归 12345678910111213int f(int[] a, int target, int i, int j) &#123; if (i &gt; j) &#123; return -1; &#125; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; return f(a, target, i, m - 1); &#125; else if (a[m] &lt; target) &#123; return f(a, target, m + 1, j); &#125; else &#123; return m; &#125;&#125; 子问题个数 $a &#x3D; 1$ 子问题数据规模缩小倍数 $b &#x3D; 2$ 除递归外执行的计算是常数级 $c&#x3D;0$ $T(n) &#x3D; T(\\frac{n}{2}) + n^0$ 此时 $x&#x3D;0 &#x3D; c$，时间复杂度 $\\Theta(\\log{n})$ 例8. 归并排序递归 12345678910111213void split(B[], i, j, A[])&#123; if (j - i &lt;= 1) return; m = (i + j) / 2; // 递归 split(A, i, m, B); split(A, m, j, B); // 合并 merge(B, i, m, j, A);&#125; 子问题个数 $a&#x3D;2$ 子问题数据规模缩小倍数 $b&#x3D;2$ 除递归外，主要时间花在合并上，它可以用 $f(n) &#x3D; n$ 表示 $T(n) &#x3D; 2T(\\frac{n}{2}) + n$ 此时 $x&#x3D;1&#x3D;c$，时间复杂度 $\\Theta(n\\log{n})$ 例9. 快速排序递归 12345678910algorithm quicksort(A, lo, hi) is if lo &gt;= hi || lo &lt; 0 then return // 分区 p := partition(A, lo, hi) // 递归 quicksort(A, lo, p - 1) quicksort(A, p + 1, hi) 子问题个数 $a&#x3D;2$ 子问题数据规模缩小倍数 如果分区分的好，$b&#x3D;2$ 如果分区没分好，例如分区1 的数据是 0，分区 2 的数据是 $n-1$ 除递归外，主要时间花在分区上，它可以用 $f(n) &#x3D; n$ 表示 情况1 - 分区分的好 $T(n) &#x3D; 2T(\\frac{n}{2}) + n$ 此时 $x&#x3D;1&#x3D;c$，时间复杂度 $\\Theta(n\\log{n})$ 情况2 - 分区没分好 $T(n) &#x3D; T(n-1) + T(1) + n$ 此时不能用主定理求解 7) 递归时间复杂度-展开求解像下面的递归式，都不能用主定理求解 例1 - 递归求和 123456long sum(long n) &#123; if (n == 1) &#123; return 1; &#125; return n + sum(n - 1);&#125; $T(n) &#x3D; T(n-1) + c$，$T(1) &#x3D; c$ 下面为展开过程 $T(n) &#x3D; T(n-2) + c + c$ $T(n) &#x3D; T(n-3) + c + c + c$ … $T(n) &#x3D; T(n-(n-1)) + (n-1)c$ 其中 $T(n-(n-1))$ 即 $T(1)$ 带入求得 $T(n) &#x3D; c + (n-1)c &#x3D; nc$ 时间复杂度为 $O(n)$ 例2 - 递归冒泡排序 1234567891011void bubble(int[] a, int high) &#123; if(0 == high) &#123; return; &#125; for (int i = 0; i &lt; high; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; swap(a, i, i + 1); &#125; &#125; bubble(a, high - 1);&#125; $T(n) &#x3D; T(n-1) + n$，$T(1) &#x3D; c$ 下面为展开过程 $T(n) &#x3D; T(n-2) + (n-1) + n$ $T(n) &#x3D; T(n-3) + (n-2) + (n-1) + n$ … $T(n) &#x3D; T(1) + 2 + … + n &#x3D; T(1) + (n-1)\\frac{2+n}{2} &#x3D; c + \\frac{n^2}{2} + \\frac{n}{2} -1$ 时间复杂度 $O(n^2)$ 注： 等差数列求和为 $个数*\\frac{\\vert首项-末项\\vert}{2}$ 例3 - 递归快排 快速排序分区没分好的极端情况 $T(n) &#x3D; T(n-1) + T(1) + n$，$T(1) &#x3D; c$ $T(n) &#x3D; T(n-1) + c + n$ 下面为展开过程 $T(n) &#x3D; T(n-2) + c + (n-1) + c + n$ $T(n) &#x3D; T(n-3) + c + (n-2) + c + (n-1) + c + n$ … $T(n) &#x3D; T(n-(n-1)) + (n-1)c + 2+…+n &#x3D; \\frac{n^2}{2} + \\frac{2cn+n}{2} -1$ 时间复杂度 $O(n^2)$ 不会推导的同学可以进入 https://www.wolframalpha.com/ 例1 输入 f(n) &#x3D; f(n - 1) + c, f(1) &#x3D; c 例2 输入 f(n) &#x3D; f(n - 1) + n, f(1) &#x3D; c 例3 输入 f(n) &#x3D; f(n - 1) + n + c, f(1) &#x3D; c 2.4 队列1) 概述计算机科学中，queue 是以顺序的方式维护的一组数据集合，在一端添加数据，从另一端移除数据。习惯来说，添加的一端称为尾，移除的一端称为头，就如同生活中的排队买商品 In computer science, a queue is a collection of entities that are maintained in a sequence and can be modified by the addition of entities at one end of the sequence and the removal of entities from the other end of the sequence 先定义一个简化的队列接口 123456789101112131415161718192021222324252627282930313233public interface Queue&lt;E&gt; &#123; /** * 向队列尾插入值 * @param value 待插入值 * @return 插入成功返回 true, 插入失败返回 false */ boolean offer(E value); /** * 从对列头获取值, 并移除 * @return 如果队列非空返回对头值, 否则返回 null */ E poll(); /** * 从对列头获取值, 不移除 * @return 如果队列非空返回对头值, 否则返回 null */ E peek(); /** * 检查队列是否为空 * @return 空返回 true, 否则返回 false */ boolean isEmpty(); /** * 检查队列是否已满 * @return 满返回 true, 否则返回 false */ boolean isFull();&#125; 2) 链表实现下面以单向环形带哨兵链表方式来实现队列 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt;, Iterable&lt;E&gt; &#123; private static class Node&lt;E&gt; &#123; E value; Node&lt;E&gt; next; public Node(E value, Node&lt;E&gt; next) &#123; this.value = value; this.next = next; &#125; &#125; private Node&lt;E&gt; head = new Node&lt;&gt;(null, null); private Node&lt;E&gt; tail = head; private int size = 0; private int capacity = Integer.MAX_VALUE; &#123; tail.next = head; &#125; public LinkedListQueue() &#123; &#125; public LinkedListQueue(int capacity) &#123; this.capacity = capacity; &#125; @Override public boolean offer(E value) &#123; if (isFull()) &#123; return false; &#125; Node&lt;E&gt; added = new Node&lt;&gt;(value, head); tail.next = added; tail = added; size++; return true; &#125; @Override public E poll() &#123; if (isEmpty()) &#123; return null; &#125; Node&lt;E&gt; first = head.next; head.next = first.next; if (first == tail) &#123; tail = head; &#125; size--; return first.value; &#125; @Override public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return head.next.value; &#125; @Override public boolean isEmpty() &#123; return head == tail; &#125; @Override public boolean isFull() &#123; return size == capacity; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new Iterator&lt;E&gt;() &#123; Node&lt;E&gt; p = head.next; @Override public boolean hasNext() &#123; return p != head; &#125; @Override public E next() &#123; E value = p.value; p = p.next; return value; &#125; &#125;; &#125;&#125; 3) 环形数组实现好处 对比普通数组，起点和终点更为自由，不用考虑数据移动 “环”意味着不会存在【越界】问题 数组性能更佳 环形数组比较适合实现有界队列、RingBuffer 等 下标计算 例如，数组长度是 5，当前位置是 3 ，向前走 2 步，此时下标为 $(3 + 2)%5 &#x3D; 0$ $$(cur + step) % length$$ cur 当前指针位置 step 前进步数 length 数组长度 注意： 如果 step &#x3D; 1，也就是一次走一步，可以在 &gt;&#x3D; length 时重置为 0 即可 判断空 判断满 满之后的策略可以根据业务需求决定 例如我们要实现的环形队列，满之后就拒绝入队 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt;, Iterable&lt;E&gt;&#123; private int head = 0; private int tail = 0; private final E[] array; private final int length; @SuppressWarnings(&quot;all&quot;) public ArrayQueue(int capacity) &#123; length = capacity + 1; array = (E[]) new Object[length]; &#125; @Override public boolean offer(E value) &#123; if (isFull()) &#123; return false; &#125; array[tail] = value; tail = (tail + 1) % length; return true; &#125; @Override public E poll() &#123; if (isEmpty()) &#123; return null; &#125; E value = array[head]; head = (head + 1) % length; return value; &#125; @Override public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return array[head]; &#125; @Override public boolean isEmpty() &#123; return tail == head; &#125; @Override public boolean isFull() &#123; return (tail + 1) % length == head; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new Iterator&lt;E&gt;() &#123; int p = head; @Override public boolean hasNext() &#123; return p != tail; &#125; @Override public E next() &#123; E value = array[p]; p = (p + 1) % array.length; return value; &#125; &#125;; &#125;&#125; 判断空、满方法2 引入 size 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ArrayQueue2&lt;E&gt; implements Queue&lt;E&gt;, Iterable&lt;E&gt; &#123; private int head = 0; private int tail = 0; private final E[] array; private final int capacity; private int size = 0; @SuppressWarnings(&quot;all&quot;) public ArrayQueue2(int capacity) &#123; this.capacity = capacity; array = (E[]) new Object[capacity]; &#125; @Override public boolean offer(E value) &#123; if (isFull()) &#123; return false; &#125; array[tail] = value; tail = (tail + 1) % capacity; size++; return true; &#125; @Override public E poll() &#123; if (isEmpty()) &#123; return null; &#125; E value = array[head]; head = (head + 1) % capacity; size--; return value; &#125; @Override public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return array[head]; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean isFull() &#123; return size == capacity; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new Iterator&lt;E&gt;() &#123; int p = head; @Override public boolean hasNext() &#123; return p != tail; &#125; @Override public E next() &#123; E value = array[p]; p = (p + 1) % capacity; return value; &#125; &#125;; &#125;&#125; 判断空、满方法3 head 和 tail 不断递增，用到索引时，再用它们进行计算，两个问题 如何保证 head 和 tail 自增超过正整数最大值的正确性 如何让取模运算性能更高 答案：让 capacity 为 2 的幂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ArrayQueue3&lt;E&gt; implements Queue&lt;E&gt;, Iterable&lt;E&gt; &#123; private int head = 0; private int tail = 0; private final E[] array; private final int capacity; @SuppressWarnings(&quot;all&quot;) public ArrayQueue3(int capacity) &#123; if ((capacity &amp; capacity - 1) != 0) &#123; throw new IllegalArgumentException(&quot;capacity 必须为 2 的幂&quot;); &#125; this.capacity = capacity; array = (E[]) new Object[this.capacity]; &#125; @Override public boolean offer(E value) &#123; if (isFull()) &#123; return false; &#125; array[tail &amp; capacity - 1] = value; tail++; return true; &#125; @Override public E poll() &#123; if (isEmpty()) &#123; return null; &#125; E value = array[head &amp; capacity - 1]; head++; return value; &#125; @Override public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return array[head &amp; capacity - 1]; &#125; @Override public boolean isEmpty() &#123; return tail - head == 0; &#125; @Override public boolean isFull() &#123; return tail - head == capacity; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new Iterator&lt;E&gt;() &#123; int p = head; @Override public boolean hasNext() &#123; return p != tail; &#125; @Override public E next() &#123; E value = array[p &amp; capacity - 1]; p++; return value; &#125; &#125;; &#125;&#125; 习题E01. 二叉树层序遍历-Leetcode 102123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(root == null) &#123; return result; &#125; LinkedListQueue&lt;TreeNode&gt; queue = new LinkedListQueue&lt;&gt;(); queue.offer(root); int c1 = 1; // 本层节点个数 while (!queue.isEmpty()) &#123; int c2 = 0; // 下层节点个数 List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; c1; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) &#123; queue.offer(node.left); c2++; &#125; if (node.right != null) &#123; queue.offer(node.right); c2++; &#125; &#125; c1 = c2; result.add(level); &#125; return result; &#125; // 自定义队列 static class LinkedListQueue&lt;E&gt; &#123; private static class Node&lt;E&gt; &#123; E value; Node&lt;E&gt; next; public Node(E value, Node&lt;E&gt; next) &#123; this.value = value; this.next = next; &#125; &#125; private final Node&lt;E&gt; head = new Node&lt;&gt;(null, null); private Node&lt;E&gt; tail = head; int size = 0; private int capacity = Integer.MAX_VALUE; &#123; tail.next = head; &#125; public LinkedListQueue() &#123; &#125; public LinkedListQueue(int capacity) &#123; this.capacity = capacity; &#125; public boolean offer(E value) &#123; if (isFull()) &#123; return false; &#125; Node&lt;E&gt; added = new Node&lt;&gt;(value, head); tail.next = added; tail = added; size++; return true; &#125; public E poll() &#123; if (isEmpty()) &#123; return null; &#125; Node&lt;E&gt; first = head.next; head.next = first.next; if (first == tail) &#123; tail = head; &#125; size--; return first.value; &#125; public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return head.next.value; &#125; public boolean isEmpty() &#123; return head == tail; &#125; public boolean isFull() &#123; return size == capacity; &#125; &#125;&#125; Ex1. 设计队列-Leetcode 622由于与课堂例题差别不大，这里只给出参考解答 基于链表的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Ex1Leetcode622 &#123; private static class Node &#123; int value; Node next; Node(int value, Node next) &#123; this.value = value; this.next = next; &#125; &#125; private final Node head = new Node(-1, null); private Node tail = head; private int size = 0; private int capacity = 0; &#123; tail.next = head; &#125; public Ex1Leetcode622(int capacity) &#123; this.capacity = capacity; &#125; public boolean enQueue(int value) &#123; if(isFull()) &#123; return false; &#125; Node added = new Node(value, head); tail.next = added; tail = added; size++; return true; &#125; public boolean deQueue() &#123; if(isEmpty()) &#123; return false; &#125; Node first = head.next; head.next = first.next; if (first == tail) &#123; tail = head; &#125; size--; return true; &#125; public int Front() &#123; if(isEmpty()) &#123; return -1; &#125; return head.next.value; &#125; public int Rear() &#123; if(isEmpty()) &#123; return -1; &#125; return tail.value; &#125; public boolean isEmpty() &#123; return head == tail; &#125; public boolean isFull() &#123; return size == capacity; &#125;&#125; 注意： Leetcode 的实现里 deQueue（出队）返回值是布尔值，并不会返回队头元素 它期望用法是先用 Front 返回对头元素，再 deQueue 出队 2.5 栈1) 概述计算机科学中，stack 是一种线性的数据结构，只能在其一端添加数据和移除数据。习惯来说，这一端称之为栈顶，另一端不能操作数据的称之为栈底，就如同生活中的一摞书 先提供一个栈接口 1234567891011121314151617181920212223242526272829303132public interface Stack&lt;E&gt; &#123; /** * 向栈顶压入元素 * @param value 待压入值 * @return 压入成功返回 true, 否则返回 false */ boolean push(E value); /** * 从栈顶弹出元素 * @return 栈非空返回栈顶元素, 栈为空返回 null */ E pop(); /** * 返回栈顶元素, 不弹出 * @return 栈非空返回栈顶元素, 栈为空返回 null */ E peek(); /** * 判断栈是否为空 * @return 空返回 true, 否则返回 false */ boolean isEmpty(); /** * 判断栈是否已满 * @return 满返回 true, 否则返回 false */ boolean isFull();&#125; 2) 链表实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt;, Iterable&lt;E&gt; &#123; private final int capacity; private int size; private final Node&lt;E&gt; head = new Node&lt;&gt;(null, null); public LinkedListStack(int capacity) &#123; this.capacity = capacity; &#125; @Override public boolean push(E value) &#123; if (isFull()) &#123; return false; &#125; head.next = new Node&lt;&gt;(value, head.next); size++; return true; &#125; @Override public E pop() &#123; if (isEmpty()) &#123; return null; &#125; Node&lt;E&gt; first = head.next; head.next = first.next; size--; return first.value; &#125; @Override public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return head.next.value; &#125; @Override public boolean isEmpty() &#123; return head.next == null; &#125; @Override public boolean isFull() &#123; return size == capacity; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new Iterator&lt;E&gt;() &#123; Node&lt;E&gt; p = head.next; @Override public boolean hasNext() &#123; return p != null; &#125; @Override public E next() &#123; E value = p.value; p = p.next; return value; &#125; &#125;; &#125; static class Node&lt;E&gt; &#123; E value; Node&lt;E&gt; next; public Node(E value, Node&lt;E&gt; next) &#123; this.value = value; this.next = next; &#125; &#125;&#125; 3) 数组实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt;, Iterable&lt;E&gt;&#123; private final E[] array; private int top = 0; @SuppressWarnings(&quot;all&quot;) public ArrayStack(int capacity) &#123; this.array = (E[]) new Object[capacity]; &#125; @Override public boolean push(E value) &#123; if (isFull()) &#123; return false; &#125; array[top++] = value; return true; &#125; @Override public E pop() &#123; if (isEmpty()) &#123; return null; &#125; return array[--top]; &#125; @Override public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return array[top-1]; &#125; @Override public boolean isEmpty() &#123; return top == 0; &#125; @Override public boolean isFull() &#123; return top == array.length; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new Iterator&lt;E&gt;() &#123; int p = top; @Override public boolean hasNext() &#123; return p &gt; 0; &#125; @Override public E next() &#123; return array[--p]; &#125; &#125;; &#125;&#125; 4) 应用模拟如下方法调用 1234567891011121314151617181920public static void main(String[] args) &#123; System.out.println(&quot;main1&quot;); System.out.println(&quot;main2&quot;); method1(); method2(); System.out.println(&quot;main3&quot;);&#125;public static void method1() &#123; System.out.println(&quot;method1&quot;); method3();&#125;public static void method2() &#123; System.out.println(&quot;method2&quot;);&#125;public static void method3() &#123; System.out.println(&quot;method3&quot;);&#125; 模拟代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class CPU &#123; static class Frame &#123; int exit; public Frame(int exit) &#123; this.exit = exit; &#125; &#125; static int pc = 1; // 模拟程序计数器 Program counter static ArrayStack&lt;Frame&gt; stack = new ArrayStack&lt;&gt;(100); // 模拟方法调用栈 public static void main(String[] args) &#123; stack.push(new Frame(-1)); while (!stack.isEmpty()) &#123; switch (pc) &#123; case 1 -&gt; &#123; System.out.println(&quot;main1&quot;); pc++; &#125; case 2 -&gt; &#123; System.out.println(&quot;main2&quot;); pc++; &#125; case 3 -&gt; &#123; stack.push(new Frame(pc + 1)); pc = 100; &#125; case 4 -&gt; &#123; stack.push(new Frame(pc + 1)); pc = 200; &#125; case 5 -&gt; &#123; System.out.println(&quot;main3&quot;); pc = stack.pop().exit; &#125; case 100 -&gt; &#123; System.out.println(&quot;method1&quot;); stack.push(new Frame(pc + 1)); pc = 300; &#125; case 101 -&gt; &#123; pc = stack.pop().exit; &#125; case 200 -&gt; &#123; System.out.println(&quot;method2&quot;); pc = stack.pop().exit; &#125; case 300 -&gt; &#123; System.out.println(&quot;method3&quot;); pc = stack.pop().exit; &#125; &#125; &#125; &#125;&#125; 习题E01. 有效的括号-Leetcode 20一个字符串中可能出现 [] () 和 &#123;&#125; 三种括号，判断该括号是否有效 有效的例子 12345()[]&#123;&#125;([&#123;&#125;])() 无效的例子 12345[)([)]([] 思路 遇到左括号, 把要配对的右括号放入栈顶 遇到右括号, 若此时栈为空, 返回 false，否则把它与栈顶元素对比 若相等, 栈顶元素弹出, 继续对比下一组 若不等, 无效括号直接返回 false 循环结束 若栈为空, 表示所有括号都配上对, 返回 true 若栈不为空, 表示右没配对的括号, 应返回 false 答案（用到了课堂案例中的 ArrayStack 类） 1234567891011121314151617181920public boolean isValid(String s) &#123; ArrayStack&lt;Character&gt; stack = new ArrayStack&lt;&gt;(s.length() / 2 + 1); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (c == &#x27;(&#x27;) &#123; stack.push(&#x27;)&#x27;); &#125; else if (c == &#x27;[&#x27;) &#123; stack.push(&#x27;]&#x27;); &#125; else if (c == &#x27;&#123;&#x27;) &#123; stack.push(&#x27;&#125;&#x27;); &#125; else &#123; if (!stack.isEmpty() &amp;&amp; stack.peek() == c) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; &#125; return stack.isEmpty();&#125; E02. 后缀表达式求值-Leetcode 120后缀表达式也称为逆波兰表达式，即运算符写在后面 从左向右进行计算 不必考虑运算符优先级，即不用包含括号 示例 1234567输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9即：(2 + 1) * 3输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]输出：6即：4 + (13 / 5) 题目假设 数字都视为整数 数字和运算符个数给定正确，不会有除零发生 代码 1234567891011121314151617181920212223242526272829public int evalRPN(String[] tokens) &#123; LinkedList&lt;Integer&gt; numbers = new LinkedList&lt;&gt;(); for (String t : tokens) &#123; switch (t) &#123; case &quot;+&quot; -&gt; &#123; Integer b = numbers.pop(); Integer a = numbers.pop(); numbers.push(a + b); &#125; case &quot;-&quot; -&gt; &#123; Integer b = numbers.pop(); Integer a = numbers.pop(); numbers.push(a - b); &#125; case &quot;*&quot; -&gt; &#123; Integer b = numbers.pop(); Integer a = numbers.pop(); numbers.push(a * b); &#125; case &quot;/&quot; -&gt; &#123; Integer b = numbers.pop(); Integer a = numbers.pop(); numbers.push(a / b); &#125; default -&gt; numbers.push(Integer.parseInt(t)); &#125; &#125; return numbers.pop();&#125; E03. 中缀表达式转后缀123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class E03InfixToSuffix &#123; /* 思路 1. 遇到数字, 拼串 2. 遇到 + - * / - 优先级高于栈顶运算符 入栈 - 否则将栈中高级或平级运算符出栈拼串, 本运算符入栈 3. 遍历完成, 栈中剩余运算符出栈拼串 - 先出栈,意味着优先运算 4. 带 () - 左括号直接入栈 - 右括号要将栈中直至左括号为止的运算符出栈拼串 | | | | | | _____ a+b a+b-c a+b*c a*b+c (a+b)*c */ public static void main(String[] args) &#123; System.out.println(infixToSuffix(&quot;a+b&quot;)); System.out.println(infixToSuffix(&quot;a+b-c&quot;)); System.out.println(infixToSuffix(&quot;a+b*c&quot;)); System.out.println(infixToSuffix(&quot;a*b-c&quot;)); System.out.println(infixToSuffix(&quot;(a+b)*c&quot;)); System.out.println(infixToSuffix(&quot;a+b*c+(d*e+f)*g&quot;)); &#125; static String infixToSuffix(String exp) &#123; LinkedList&lt;Character&gt; stack = new LinkedList&lt;&gt;(); StringBuilder sb = new StringBuilder(exp.length()); for (int i = 0; i &lt; exp.length(); i++) &#123; char c = exp.charAt(i); switch (c) &#123; case &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27; -&gt; &#123; if (stack.isEmpty()) &#123; stack.push(c); &#125; else &#123; if (priority(c) &gt; priority(stack.peek())) &#123; stack.push(c); &#125; else &#123; while (!stack.isEmpty() &amp;&amp; priority(stack.peek()) &gt;= priority(c)) &#123; sb.append(stack.pop()); &#125; stack.push(c); &#125; &#125; &#125; case &#x27;(&#x27; -&gt; &#123; stack.push(c); &#125; case &#x27;)&#x27; -&gt; &#123; while (!stack.isEmpty() &amp;&amp; stack.peek() != &#x27;(&#x27;) &#123; sb.append(stack.pop()); &#125; stack.pop(); &#125; default -&gt; &#123; sb.append(c); &#125; &#125; &#125; while (!stack.isEmpty()) &#123; sb.append(stack.pop()); &#125; return sb.toString(); &#125; static int priority(char c) &#123; return switch (c) &#123; case &#x27;(&#x27; -&gt; 0; case &#x27;*&#x27;, &#x27;/&#x27; -&gt; 2; case &#x27;+&#x27;, &#x27;-&#x27; -&gt; 1; default -&gt; throw new IllegalArgumentException(&quot;不合法字符:&quot; + c); &#125;; &#125;&#125; E04. 双栈模拟队列-Leetcode 232给力扣题目用的自实现栈，可以定义为静态内部类 12345678910111213141516171819202122232425262728293031323334353637383940class ArrayStack&lt;E&gt; &#123; private E[] array; private int top; // 栈顶指针 @SuppressWarnings(&quot;all&quot;) public ArrayStack(int capacity) &#123; this.array = (E[]) new Object[capacity]; &#125; public boolean push(E value) &#123; if (isFull()) &#123; return false; &#125; array[top++] = value; return true; &#125; public E pop() &#123; if (isEmpty()) &#123; return null; &#125; return array[--top]; &#125; public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return array[top - 1]; &#125; public boolean isEmpty() &#123; return top == 0; &#125; public boolean isFull() &#123; return top == array.length; &#125;&#125; 参考解答，注意：题目已说明 调用 push、pop 等方法的次数最多 100 12345678910111213141516171819202122232425262728293031323334353637383940414243public class E04Leetcode232 &#123; /* 队列头 队列尾 s1 s2 顶 底 底 顶 abc push(a) push(b) push(c) pop() */ ArrayStack&lt;Integer&gt; s1 = new ArrayStack&lt;&gt;(100); ArrayStack&lt;Integer&gt; s2 = new ArrayStack&lt;&gt;(100); public void push(int x) &#123; s2.push(x); &#125; public int pop() &#123; if (s1.isEmpty()) &#123; while (!s2.isEmpty()) &#123; s1.push(s2.pop()); &#125; &#125; return s1.pop(); &#125; public int peek() &#123; if (s1.isEmpty()) &#123; while (!s2.isEmpty()) &#123; s1.push(s2.pop()); &#125; &#125; return s1.peek(); &#125; public boolean empty() &#123; return s1.isEmpty() &amp;&amp; s2.isEmpty(); &#125;&#125; E05. 单队列模拟栈-Leetcode 225给力扣题目用的自实现队列，可以定义为静态内部类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ArrayQueue3&lt;E&gt; &#123; private final E[] array; int head = 0; int tail = 0; @SuppressWarnings(&quot;all&quot;) public ArrayQueue3(int c) &#123; c -= 1; c |= c &gt;&gt; 1; c |= c &gt;&gt; 2; c |= c &gt;&gt; 4; c |= c &gt;&gt; 8; c |= c &gt;&gt; 16; c += 1; array = (E[]) new Object[c]; &#125; public boolean offer(E value) &#123; if (isFull()) &#123; return false; &#125; array[tail &amp; (array.length - 1)] = value; tail++; return true; &#125; public E poll() &#123; if (isEmpty()) &#123; return null; &#125; E value = array[head &amp; (array.length - 1)]; head++; return value; &#125; public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return array[head &amp; (array.length - 1)]; &#125; public boolean isEmpty() &#123; return head == tail; &#125; public boolean isFull() &#123; return tail - head == array.length; &#125;&#125; 参考解答，注意：题目已说明 调用 push、pop 等方法的次数最多 100 每次调用 pop 和 top 都能保证栈不为空 123456789101112131415161718192021222324252627282930313233public class E05Leetcode225 &#123; /* 队列头 队列尾 cba 顶 底 queue.offer(a) queue.offer(b) queue.offer(c) */ ArrayQueue3&lt;Integer&gt; queue = new ArrayQueue3&lt;&gt;(100); int size = 0; public void push(int x) &#123; queue.offer(x); for (int i = 0; i &lt; size; i++) &#123; queue.offer(queue.poll()); &#125; size++; &#125; public int pop() &#123; size--; return queue.poll(); &#125; public int top() &#123; return queue.peek(); &#125; public boolean empty() &#123; return queue.isEmpty(); &#125;&#125; 2.6 双端队列1) 概述双端队列、队列、栈对比 定义 特点 队列 一端删除（头）另一端添加（尾） First In First Out 栈 一端删除和添加（顶） Last In First Out 双端队列 两端都可以删除、添加 优先级队列 优先级高者先出队 延时队列 根据延时时间确定优先级 并发非阻塞队列 队列空或满时不阻塞 并发阻塞队列 队列空时删除阻塞、队列满时添加阻塞 注1： Java 中 LinkedList 即为典型双端队列实现，不过它同时实现了 Queue 接口，也提供了栈的 push pop 等方法 注2： 不同语言，操作双端队列的方法命名有所不同，参见下表 操作 Java JavaScript C++ leetCode 641 尾部插入 offerLast push push_back insertLast 头部插入 offerFirst unshift push_front insertFront 尾部移除 pollLast pop pop_back deleteLast 头部移除 pollFirst shift pop_front deleteFront 尾部获取 peekLast at(-1) back getRear 头部获取 peekFirst at(0) front getFront 吐槽一下 leetCode 命名比较 low 常见的单词还有 enqueue 入队、dequeue 出队 接口定义 123456789101112131415161718public interface Deque&lt;E&gt; &#123; boolean offerFirst(E e); boolean offerLast(E e); E pollFirst(); E pollLast(); E peekFirst(); E peekLast(); boolean isEmpty(); boolean isFull();&#125; 2) 链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * 基于环形链表的双端队列 * @param &lt;E&gt; 元素类型 */public class LinkedListDeque&lt;E&gt; implements Deque&lt;E&gt;, Iterable&lt;E&gt; &#123; @Override public boolean offerFirst(E e) &#123; if (isFull()) &#123; return false; &#125; size++; Node&lt;E&gt; a = sentinel; Node&lt;E&gt; b = sentinel.next; Node&lt;E&gt; offered = new Node&lt;&gt;(a, e, b); a.next = offered; b.prev = offered; return true; &#125; @Override public boolean offerLast(E e) &#123; if (isFull()) &#123; return false; &#125; size++; Node&lt;E&gt; a = sentinel.prev; Node&lt;E&gt; b = sentinel; Node&lt;E&gt; offered = new Node&lt;&gt;(a, e, b); a.next = offered; b.prev = offered; return true; &#125; @Override public E pollFirst() &#123; if (isEmpty()) &#123; return null; &#125; Node&lt;E&gt; a = sentinel; Node&lt;E&gt; polled = sentinel.next; Node&lt;E&gt; b = polled.next; a.next = b; b.prev = a; size--; return polled.value; &#125; @Override public E pollLast() &#123; if (isEmpty()) &#123; return null; &#125; Node&lt;E&gt; polled = sentinel.prev; Node&lt;E&gt; a = polled.prev; Node&lt;E&gt; b = sentinel; a.next = b; b.prev = a; size--; return polled.value; &#125; @Override public E peekFirst() &#123; if (isEmpty()) &#123; return null; &#125; return sentinel.next.value; &#125; @Override public E peekLast() &#123; if (isEmpty()) &#123; return null; &#125; return sentinel.prev.value; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean isFull() &#123; return size == capacity; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new Iterator&lt;E&gt;() &#123; Node&lt;E&gt; p = sentinel.next; @Override public boolean hasNext() &#123; return p != sentinel; &#125; @Override public E next() &#123; E value = p.value; p = p.next; return value; &#125; &#125;; &#125; static class Node&lt;E&gt; &#123; Node&lt;E&gt; prev; E value; Node&lt;E&gt; next; public Node(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next) &#123; this.prev = prev; this.value = value; this.next = next; &#125; &#125; Node&lt;E&gt; sentinel = new Node&lt;&gt;(null, null, null); int capacity; int size; public LinkedListDeque(int capacity) &#123; sentinel.next = sentinel; sentinel.prev = sentinel; this.capacity = capacity; &#125;&#125; 3) 数组实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * 基于循环数组实现, 特点 * &lt;ul&gt; * &lt;li&gt;tail 停下来的位置不存储, 会浪费一个位置&lt;/li&gt; * &lt;/ul&gt; * @param &lt;E&gt; */public class ArrayDeque1&lt;E&gt; implements Deque&lt;E&gt;, Iterable&lt;E&gt; &#123; /* h t 0 1 2 3 b a */ @Override public boolean offerFirst(E e) &#123; if (isFull()) &#123; return false; &#125; head = dec(head, array.length); array[head] = e; return true; &#125; @Override public boolean offerLast(E e) &#123; if (isFull()) &#123; return false; &#125; array[tail] = e; tail = inc(tail, array.length); return true; &#125; @Override public E pollFirst() &#123; if (isEmpty()) &#123; return null; &#125; E e = array[head]; array[head] = null; head = inc(head, array.length); return e; &#125; @Override public E pollLast() &#123; if (isEmpty()) &#123; return null; &#125; tail = dec(tail, array.length); E e = array[tail]; array[tail] = null; return e; &#125; @Override public E peekFirst() &#123; if (isEmpty()) &#123; return null; &#125; return array[head]; &#125; @Override public E peekLast() &#123; if (isEmpty()) &#123; return null; &#125; return array[dec(tail, array.length)]; &#125; @Override public boolean isEmpty() &#123; return head == tail; &#125; @Override public boolean isFull() &#123; if (tail &gt; head) &#123; return tail - head == array.length - 1; &#125; else if (tail &lt; head) &#123; return head - tail == 1; &#125; else &#123; return false; &#125; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new Iterator&lt;E&gt;() &#123; int p = head; @Override public boolean hasNext() &#123; return p != tail; &#125; @Override public E next() &#123; E e = array[p]; p = inc(p, array.length); return e; &#125; &#125;; &#125; E[] array; int head; int tail; @SuppressWarnings(&quot;unchecked&quot;) public ArrayDeque1(int capacity) &#123; array = (E[]) new Object[capacity + 1]; &#125; static int inc(int i, int length) &#123; if (i + 1 &gt;= length) &#123; return 0; &#125; return i + 1; &#125; static int dec(int i, int length) &#123; if (i - 1 &lt; 0) &#123; return length - 1; &#125; return i - 1; &#125;&#125; 数组实现中，如果存储的是基本类型，那么无需考虑内存释放，例如 但如果存储的是引用类型，应当设置该位置的引用为 null，以便内存及时释放 习题E01. 二叉树 Z 字层序遍历-Leetcode 103123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class E01Leetcode103 &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); boolean leftToRight = true; int c1 = 1; while (!queue.isEmpty()) &#123; int c2 = 0; LinkedList&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; c1; i++) &#123; TreeNode n = queue.poll(); if (leftToRight) &#123; deque.offerLast(n.val); &#125; else &#123; deque.offerFirst(n.val); &#125; if (n.left != null) &#123; queue.offer(n.left); c2++; &#125; if (n.right != null) &#123; queue.offer(n.right); c2++; &#125; &#125; c1 = c2; leftToRight = !leftToRight; result.add(deque); &#125; return result; &#125; public static void main(String[] args) &#123; TreeNode root = new TreeNode( new TreeNode( new TreeNode(4), 2, new TreeNode(5) ), 1, new TreeNode( new TreeNode(6), 3, new TreeNode(7) ) ); List&lt;List&lt;Integer&gt;&gt; lists = new E01Leetcode103().zigzagLevelOrder(root); for (List&lt;Integer&gt; list : lists) &#123; System.out.println(list); &#125; &#125;&#125; Ex1. 设计双端队列-Leetcode 641与课堂例题也是差别不大，略 2.7 优先级队列1) 无序数组实现要点 入队保持顺序 出队前找到优先级最高的出队，相当于一次选择排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class PriorityQueue1&lt;E extends Priority&gt; implements Queue&lt;E&gt; &#123; Priority[] array; int size; public PriorityQueue1(int capacity) &#123; array = new Priority[capacity]; &#125; @Override // O(1) public boolean offer(E e) &#123; if (isFull()) &#123; return false; &#125; array[size++] = e; return true; &#125; // 返回优先级最高的索引值 private int selectMax() &#123; int max = 0; for (int i = 1; i &lt; size; i++) &#123; if (array[i].priority() &gt; array[max].priority()) &#123; max = i; &#125; &#125; return max; &#125; @Override // O(n) public E poll() &#123; if (isEmpty()) &#123; return null; &#125; int max = selectMax(); E e = (E) array[max]; remove(max); return e; &#125; private void remove(int index) &#123; if (index &lt; size - 1) &#123; System.arraycopy(array, index + 1, array, index, size - 1 - index); &#125; array[--size] = null; // help GC &#125; @Override public E peek() &#123; if (isEmpty()) &#123; return null; &#125; int max = selectMax(); return (E) array[max]; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean isFull() &#123; return size == array.length; &#125;&#125; 视频中忘记了 help GC，注意一下 2) 有序数组实现要点 入队后排好序，优先级最高的排列在尾部 出队只需删除尾部元素即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class PriorityQueue2&lt;E extends Priority&gt; implements Queue&lt;E&gt; &#123; Priority[] array; int size; public PriorityQueue2(int capacity) &#123; array = new Priority[capacity]; &#125; // O(n) @Override public boolean offer(E e) &#123; if (isFull()) &#123; return false; &#125; insert(e); size++; return true; &#125; // 一轮插入排序 private void insert(E e) &#123; int i = size - 1; while (i &gt;= 0 &amp;&amp; array[i].priority() &gt; e.priority()) &#123; array[i + 1] = array[i]; i--; &#125; array[i + 1] = e; &#125; // O(1) @Override public E poll() &#123; if (isEmpty()) &#123; return null; &#125; E e = (E) array[size - 1]; array[--size] = null; // help GC return e; &#125; @Override public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return (E) array[size - 1]; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean isFull() &#123; return size == array.length; &#125;&#125; 3) 堆实现计算机科学中，堆是一种基于树的数据结构，通常用完全二叉树实现。堆的特性如下 在大顶堆中，任意节点 C 与它的父节点 P 符合 $P.value \\geq C.value$ 而小顶堆中，任意节点 C 与它的父节点 P 符合 $P.value \\leq C.value$ 最顶层的节点（没有父亲）称之为 root 根节点 In computer science, a heap is a specialized tree-based data structure which is essentially an almost complete tree that satisfies the heap property: in a max heap, for any given node C, if P is a parent node of C, then the key (the value) of P is greater than or equal to the key of C. In a min heap, the key of P is less than or equal to the key of C. The node at the “top” of the heap (with no parents) is called the root node 例1 - 满二叉树（Full Binary Tree）特点：每一层都是填满的 例2 - 完全二叉树（Complete Binary Tree）特点：最后一层可能未填满，靠左对齐 例3 - 大顶堆 例4 - 小顶堆 完全二叉树可以使用数组来表示 特征 如果从索引 0 开始存储节点数据 节点 $i$ 的父节点为 $floor((i-1)&#x2F;2)$，当 $i&gt;0$ 时 节点 $i$ 的左子节点为 $2i+1$，右子节点为 $2i+2$，当然它们得 $&lt; size$ 如果从索引 1 开始存储节点数据 节点 $i$ 的父节点为 $floor(i&#x2F;2)$，当 $i &gt; 1$ 时 节点 $i$ 的左子节点为 $2i$，右子节点为 $2i+1$，同样得 $&lt; size$ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class PriorityQueue4&lt;E extends Priority&gt; implements Queue&lt;E&gt; &#123; Priority[] array; int size; public PriorityQueue4(int capacity) &#123; array = new Priority[capacity]; &#125; @Override public boolean offer(E offered) &#123; if (isFull()) &#123; return false; &#125; int child = size++; int parent = (child - 1) / 2; while (child &gt; 0 &amp;&amp; offered.priority() &gt; array[parent].priority()) &#123; array[child] = array[parent]; child = parent; parent = (child - 1) / 2; &#125; array[child] = offered; return true; &#125; private void swap(int i, int j) &#123; Priority t = array[i]; array[i] = array[j]; array[j] = t; &#125; @Override public E poll() &#123; if (isEmpty()) &#123; return null; &#125; swap(0, size - 1); size--; Priority e = array[size]; array[size] = null; shiftDown(0); return (E) e; &#125; void shiftDown(int parent) &#123; int left = 2 * parent + 1; int right = left + 1; int max = parent; if (left &lt; size &amp;&amp; array[left].priority() &gt; array[max].priority()) &#123; max = left; &#125; if (right &lt; size &amp;&amp; array[right].priority() &gt; array[max].priority()) &#123; max = right; &#125; if (max != parent) &#123; swap(max, parent); shiftDown(max); &#125; &#125; @Override public E peek() &#123; if (isEmpty()) &#123; return null; &#125; return (E) array[0]; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public boolean isFull() &#123; return size == array.length; &#125;&#125; 习题E01. 合并多个有序链表-Leetcode 23这道题目之前解答过，现在用刚学的优先级队列来实现一下 题目中要从小到大排列，因此选择用小顶堆来实现，自定义小顶堆如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MinHeap &#123; ListNode[] array; int size; public MinHeap(int capacity) &#123; array = new ListNode[capacity]; &#125; public void offer(ListNode offered) &#123; int child = size++; int parent = (child - 1) / 2; while (child &gt; 0 &amp;&amp; offered.val &lt; array[parent].val) &#123; array[child] = array[parent]; child = parent; parent = (child - 1) / 2; &#125; array[child] = offered; &#125; public ListNode poll() &#123; if (isEmpty()) &#123; return null; &#125; swap(0, size - 1); size--; ListNode e = array[size]; array[size] = null; // help GC down(0); return e; &#125; private void down(int parent) &#123; int left = 2 * parent + 1; int right = left + 1; int min = parent; if (left &lt; size &amp;&amp; array[left].val &lt; array[min].val) &#123; min = left; &#125; if (right &lt; size &amp;&amp; array[right].val &lt; array[min].val) &#123; min = right; &#125; if (min != parent) &#123; swap(min, parent); down(min); &#125; &#125; private void swap(int i, int j) &#123; ListNode t = array[i]; array[i] = array[j]; array[j] = t; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; 代码 123456789101112131415161718192021222324public class E01Leetcode23 &#123; public ListNode mergeKLists(ListNode[] lists) &#123; // 1. 使用 jdk 的优先级队列实现// PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.val)); // 2. 使用自定义小顶堆实现 MinHeap queue = new MinHeap(lists.length); for (ListNode head : lists) &#123; if (head != null) &#123; queue.offer(head); &#125; &#125; ListNode s = new ListNode(-1, null); ListNode p = s; while (!queue.isEmpty()) &#123; ListNode node = queue.poll(); p.next = node; p = node; if (node.next != null) &#123; queue.offer(node.next); &#125; &#125; return s.next; &#125;&#125; 提问： 能否将每个链表的所有元素全部加入堆，再一个个从堆顶移除？ 回答： 可以是可以，但对空间占用就高了，堆的一个优点就是用有限的空间做事情 2.8 阻塞队列之前的队列在很多场景下都不能很好地工作，例如 大部分场景要求分离向队列放入（生产者）、从队列拿出（消费者）两个角色、它们得由不同的线程来担当，而之前的实现根本没有考虑线程安全问题 队列为空，那么在之前的实现里会返回 null，如果就是硬要拿到一个元素呢？只能不断循环尝试 队列为满，那么再之前的实现里会返回 false，如果就是硬要塞入一个元素呢？只能不断循环尝试 因此我们需要解决的问题有 用锁保证线程安全 用条件变量让等待非空线程与等待不满线程进入等待状态，而不是不断循环尝试，让 CPU 空转 有同学对线程安全还没有足够的认识，下面举一个反例，两个线程都要执行入队操作（几乎在同一时刻） 1234567891011121314151617181920public class TestThreadUnsafe &#123; private final String[] array = new String[10]; private int tail = 0; public void offer(String e) &#123; array[tail] = e; tail++; &#125; @Override public String toString() &#123; return Arrays.toString(array); &#125; public static void main(String[] args) &#123; TestThreadUnsafe queue = new TestThreadUnsafe(); new Thread(()-&gt; queue.offer(&quot;e1&quot;), &quot;t1&quot;).start(); new Thread(()-&gt; queue.offer(&quot;e2&quot;), &quot;t2&quot;).start(); &#125;&#125; 执行的时间序列如下，假设初始状态 tail &#x3D; 0，在执行过程中由于 CPU 在两个线程之间切换，造成了指令交错 线程1 线程2 说明 array[tail]&#x3D;e1 线程1 向 tail 位置加入 e1 这个元素，但还没来得及执行 tail++ array[tail]&#x3D;e2 线程2 向 tail 位置加入 e2 这个元素，覆盖掉了 e1 tail++ tail 自增为1 tail++ tail 自增为2 最后状态 tail 为 2，数组为 [e2, null, null …] 糟糕的是，由于指令交错的顺序不同，得到的结果不止以上一种，宏观上造成混乱的效果 1) 单锁实现Java 中要防止代码段交错执行，需要使用锁，有两种选择 synchronized 代码块，属于关键字级别提供锁保护，功能少 ReentrantLock 类，功能丰富 以 ReentrantLock 为例 1234567891011ReentrantLock lock = new ReentrantLock();public void offer(String e) &#123; lock.lockInterruptibly(); try &#123; array[tail] = e; tail++; &#125; finally &#123; lock.unlock(); &#125;&#125; 只要两个线程执行上段代码时，锁对象是同一个，就能保证 try 块内的代码的执行不会出现指令交错现象，即执行顺序只可能是下面两种情况之一 线程1 线程2 说明 lock.lockInterruptibly() t1对锁对象上锁 array[tail]&#x3D;e1 lock.lockInterruptibly() 即使 CPU 切换到线程2，但由于t1已经对该对象上锁，因此线程2卡在这儿进不去 tail++ 切换回线程1 执行后续代码 lock.unlock() 线程1 解锁 array[tail]&#x3D;e2 线程2 此时才能获得锁，执行它的代码 tail++ 另一种情况是线程2 先获得锁，线程1 被挡在外面 要明白保护的本质，本例中是保护的是 tail 位置读写的安全 事情还没有完，上面的例子是队列还没有放满的情况，考虑下面的代码（这回锁同时保护了 tail 和 size 的读写安全） 123456789101112131415161718192021ReentrantLock lock = new ReentrantLock();int size = 0;public void offer(String e) &#123; lock.lockInterruptibly(); try &#123; if(isFull()) &#123; // 满了怎么办? &#125; array[tail] = e; tail++; size++; &#125; finally &#123; lock.unlock(); &#125;&#125;private boolean isFull() &#123; return size == array.length;&#125; 之前是返回 false 表示添加失败，前面分析过想达到这么一种效果： 在队列满时，不是立刻返回，而是当前线程进入等待 什么时候队列不满了，再唤醒这个等待的线程，从上次的代码处继续向下运行 ReentrantLock 可以配合条件变量来实现，代码进化为 12345678910111213141516171819202122ReentrantLock lock = new ReentrantLock();Condition tailWaits = lock.newCondition(); // 条件变量int size = 0;public void offer(String e) &#123; lock.lockInterruptibly(); try &#123; while (isFull()) &#123; tailWaits.await();\t// 当队列满时, 当前线程进入 tailWaits 等待 &#125; array[tail] = e; tail++; size++; &#125; finally &#123; lock.unlock(); &#125;&#125;private boolean isFull() &#123; return size == array.length;&#125; 条件变量底层也是个队列，用来存储这些需要等待的线程，当队列满了，就会将 offer 线程加入条件队列，并暂时释放锁 将来我们的队列如果不满了（由 poll 线程那边得知）可以调用 tailWaits.signal() 来唤醒 tailWaits 中首个等待的线程，被唤醒的线程会再次抢到锁，从上次 await 处继续向下运行 思考为何要用 while 而不是 if，设队列容量是 3 操作前 offer(4) offer(5) poll() 操作后 [1 2 3] 队列满，进入tailWaits 等待 [1 2 3] [1 2 3] 取走 1，队列不满，唤醒线程 [2 3] [2 3] 抢先获得锁，发现不满，放入 5 [2 3 5] [2 3 5] 从上次等待处直接向下执行 [2 3 5 ?] 关键点： 从 tailWaits 中唤醒的线程，会与新来的 offer 的线程争抢锁，谁能抢到是不一定的，如果后者先抢到，就会导致条件又发生变化 这种情况称之为虚假唤醒，唤醒后应该重新检查条件，看是不是得重新进入等待 最后的实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 单锁实现 * @param &lt;E&gt; 元素类型 */public class BlockingQueue1&lt;E&gt; implements BlockingQueue&lt;E&gt; &#123; private final E[] array; private int head = 0; private int tail = 0; private int size = 0; // 元素个数 @SuppressWarnings(&quot;all&quot;) public BlockingQueue1(int capacity) &#123; array = (E[]) new Object[capacity]; &#125; ReentrantLock lock = new ReentrantLock(); Condition tailWaits = lock.newCondition(); Condition headWaits = lock.newCondition(); @Override public void offer(E e) throws InterruptedException &#123; lock.lockInterruptibly(); try &#123; while (isFull()) &#123; tailWaits.await(); &#125; array[tail] = e; if (++tail == array.length) &#123; tail = 0; &#125; size++; headWaits.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public void offer(E e, long timeout) throws InterruptedException &#123; lock.lockInterruptibly(); try &#123; long t = TimeUnit.MILLISECONDS.toNanos(timeout); while (isFull()) &#123; if (t &lt;= 0) &#123; return; &#125; t = tailWaits.awaitNanos(t); &#125; array[tail] = e; if (++tail == array.length) &#123; tail = 0; &#125; size++; headWaits.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public E poll() throws InterruptedException &#123; lock.lockInterruptibly(); try &#123; while (isEmpty()) &#123; headWaits.await(); &#125; E e = array[head]; array[head] = null; // help GC if (++head == array.length) &#123; head = 0; &#125; size--; tailWaits.signal(); return e; &#125; finally &#123; lock.unlock(); &#125; &#125; private boolean isEmpty() &#123; return size == 0; &#125; private boolean isFull() &#123; return size == array.length; &#125;&#125; public void offer(E e, long timeout) throws InterruptedException 是带超时的版本，可以只等待一段时间，而不是永久等下去，类似的 poll 也可以做带超时的版本，这个留给大家了 注意 JDK 中 BlockingQueue 接口的方法命名与我的示例有些差异 方法 offer(E e) 是非阻塞的实现，阻塞实现方法为 put(E e) 方法 poll() 是非阻塞的实现，阻塞实现方法为 take() 2) 双锁实现单锁的缺点在于： 生产和消费几乎是不冲突的，唯一冲突的是生产者和消费者它们有可能同时修改 size 冲突的主要是生产者之间：多个 offer 线程修改 tail 冲突的还有消费者之间：多个 poll 线程修改 head 如果希望进一步提高性能，可以用两把锁 一把锁保护 tail 另一把锁保护 head 12345ReentrantLock headLock = new ReentrantLock(); // 保护 head 的锁Condition headWaits = headLock.newCondition(); // 队列空时，需要等待的线程集合ReentrantLock tailLock = new ReentrantLock(); // 保护 tail 的锁Condition tailWaits = tailLock.newCondition(); // 队列满时，需要等待的线程集合 先看看 offer 方法的初步实现 12345678910111213141516171819202122@Overridepublic void offer(E e) throws InterruptedException &#123; tailLock.lockInterruptibly(); try &#123; // 队列满等待 while (isFull()) &#123; tailWaits.await(); &#125; // 不满则入队 array[tail] = e; if (++tail == array.length) &#123; tail = 0; &#125; // 修改 size （有问题） size++; &#125; finally &#123; tailLock.unlock(); &#125;&#125; 上面代码的缺点是 size 并不受 tailLock 保护，tailLock 与 headLock 是两把不同的锁，并不能实现互斥的效果。因此，size 需要用下面的代码保证原子性 1234AtomicInteger size = new AtomicInteger(0); // 保护 size 的原子变量size.getAndIncrement(); // 自增size.getAndDecrement(); // 自减 代码修改为 12345678910111213141516171819202122@Overridepublic void offer(E e) throws InterruptedException &#123; tailLock.lockInterruptibly(); try &#123; // 队列满等待 while (isFull()) &#123; tailWaits.await(); &#125; // 不满则入队 array[tail] = e; if (++tail == array.length) &#123; tail = 0; &#125; // 修改 size size.getAndIncrement(); &#125; finally &#123; tailLock.unlock(); &#125;&#125; 对称地，可以写出 poll 方法 123456789101112131415161718192021222324@Overridepublic E poll() throws InterruptedException &#123; E e; headLock.lockInterruptibly(); try &#123; // 队列空等待 while (isEmpty()) &#123; headWaits.await(); &#125; // 不空则出队 e = array[head]; if (++head == array.length) &#123; head = 0; &#125; // 修改 size size.getAndDecrement(); &#125; finally &#123; headLock.unlock(); &#125; return e;&#125; 下面来看一个难题，就是如何通知 headWaits 和 tailWaits 中等待的线程，比如 poll 方法拿走一个元素，通知 tailWaits：我拿走一个，不满了噢，你们可以放了，因此代码改为 123456789101112131415161718192021222324252627@Overridepublic E poll() throws InterruptedException &#123; E e; headLock.lockInterruptibly(); try &#123; // 队列空等待 while (isEmpty()) &#123; headWaits.await(); &#125; // 不空则出队 e = array[head]; if (++head == array.length) &#123; head = 0; &#125; // 修改 size size.getAndDecrement(); // 通知 tailWaits 不满（有问题） tailWaits.signal(); &#125; finally &#123; headLock.unlock(); &#125; return e;&#125; 问题在于要使用这些条件变量的 await()， signal() 等方法需要先获得与之关联的锁，上面的代码若直接运行会出现以下错误 1java.lang.IllegalMonitorStateException 那有同学说，加上锁不就行了吗，于是写出了下面的代码 发现什么问题了？两把锁这么嵌套使用，非常容易出现死锁，如下所示 因此得避免嵌套，两段加锁的代码变成了下面平级的样子 性能还可以进一步提升 代码调整后 offer 并没有同时获取 tailLock 和 headLock 两把锁，因此两次加锁之间会有空隙，这个空隙内可能有其它的 offer 线程添加了更多的元素，那么这些线程都要执行 signal()，通知 poll 线程队列非空吗？ 每次调用 signal() 都需要这些 offer 线程先获得 headLock 锁，成本较高，要想法减少 offer 线程获得 headLock 锁的次数 可以加一个条件：当 offer 增加前队列为空，即从 0 变化到不空，才由此 offer 线程来通知 headWaits，其它情况不归它管 队列从 0 变化到不空，会唤醒一个等待的 poll 线程，这个线程被唤醒后，肯定能拿到 headLock 锁，因此它具备了唤醒 headWaits 上其它 poll 线程的先决条件。如果检查出此时有其它 offer 线程新增了元素（不空，但不是从0变化而来），那么不妨由此 poll 线程来唤醒其它 poll 线程 这个技巧被称之为级联通知（cascading notifies），类似的原因 在 poll 时队列从满变化到不满，才由此 poll 线程来唤醒一个等待的 offer 线程，目的也是为了减少 poll 线程对 tailLock 上锁次数，剩下等待的 offer 线程由这个 offer 线程间接唤醒 最终的代码为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class BlockingQueue2&lt;E&gt; implements BlockingQueue&lt;E&gt; &#123; private final E[] array; private int head = 0; private int tail = 0; private final AtomicInteger size = new AtomicInteger(0); ReentrantLock headLock = new ReentrantLock(); Condition headWaits = headLock.newCondition(); ReentrantLock tailLock = new ReentrantLock(); Condition tailWaits = tailLock.newCondition(); public BlockingQueue2(int capacity) &#123; this.array = (E[]) new Object[capacity]; &#125; @Override public void offer(E e) throws InterruptedException &#123; int c; tailLock.lockInterruptibly(); try &#123; while (isFull()) &#123; tailWaits.await(); &#125; array[tail] = e; if (++tail == array.length) &#123; tail = 0; &#125; c = size.getAndIncrement(); // a. 队列不满, 但不是从满-&gt;不满, 由此offer线程唤醒其它offer线程 if (c + 1 &lt; array.length) &#123; tailWaits.signal(); &#125; &#125; finally &#123; tailLock.unlock(); &#125; // b. 从0-&gt;不空, 由此offer线程唤醒等待的poll线程 if (c == 0) &#123; headLock.lock(); try &#123; headWaits.signal(); &#125; finally &#123; headLock.unlock(); &#125; &#125; &#125; @Override public E poll() throws InterruptedException &#123; E e; int c; headLock.lockInterruptibly(); try &#123; while (isEmpty()) &#123; headWaits.await(); &#125; e = array[head]; if (++head == array.length) &#123; head = 0; &#125; c = size.getAndDecrement(); // b. 队列不空, 但不是从0变化到不空，由此poll线程通知其它poll线程 if (c &gt; 1) &#123; headWaits.signal(); &#125; &#125; finally &#123; headLock.unlock(); &#125; // a. 从满-&gt;不满, 由此poll线程唤醒等待的offer线程 if (c == array.length) &#123; tailLock.lock(); try &#123; tailWaits.signal(); &#125; finally &#123; tailLock.unlock(); &#125; &#125; return e; &#125; private boolean isEmpty() &#123; return size.get() == 0; &#125; private boolean isFull() &#123; return size.get() == array.length; &#125;&#125; 双锁实现的非常精巧，据说作者 Doug Lea 花了一年的时间才完善了此段代码 2.9 堆以大顶堆为例，相对于之前的优先级队列，增加了堆化等方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class MaxHeap &#123; int[] array; int size; public MaxHeap(int capacity) &#123; this.array = new int[capacity]; &#125; /** * 获取堆顶元素 * * @return 堆顶元素 */ public int peek() &#123; return array[0]; &#125; /** * 删除堆顶元素 * * @return 堆顶元素 */ public int poll() &#123; int top = array[0]; swap(0, size - 1); size--; down(0); return top; &#125; /** * 删除指定索引处元素 * * @param index 索引 * @return 被删除元素 */ public int poll(int index) &#123; int deleted = array[index]; up(Integer.MAX_VALUE, index); poll(); return deleted; &#125; /** * 替换堆顶元素 * * @param replaced 新元素 */ public void replace(int replaced) &#123; array[0] = replaced; down(0); &#125; /** * 堆的尾部添加元素 * * @param offered 新元素 * @return 是否添加成功 */ public boolean offer(int offered) &#123; if (size == array.length) &#123; return false; &#125; up(offered, size); size++; return true; &#125; // 将 offered 元素上浮: 直至 offered 小于父元素或到堆顶 private void up(int offered, int index) &#123; int child = index; while (child &gt; 0) &#123; int parent = (child - 1) / 2; if (offered &gt; array[parent]) &#123; array[child] = array[parent]; &#125; else &#123; break; &#125; child = parent; &#125; array[child] = offered; &#125; public MaxHeap(int[] array) &#123; this.array = array; this.size = array.length; heapify(); &#125; // 建堆 private void heapify() &#123; // 如何找到最后这个非叶子节点 size / 2 - 1 for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; down(i); &#125; &#125; // 将 parent 索引处的元素下潜: 与两个孩子较大者交换, 直至没孩子或孩子没它大 private void down(int parent) &#123; int left = parent * 2 + 1; int right = left + 1; int max = parent; if (left &lt; size &amp;&amp; array[left] &gt; array[max]) &#123; max = left; &#125; if (right &lt; size &amp;&amp; array[right] &gt; array[max]) &#123; max = right; &#125; if (max != parent) &#123; // 找到了更大的孩子 swap(max, parent); down(max); &#125; &#125; // 交换两个索引处的元素 private void swap(int i, int j) &#123; int t = array[i]; array[i] = array[j]; array[j] = t; &#125; public static void main(String[] args) &#123; int[] array = &#123;2, 3, 1, 7, 6, 4, 5&#125;; MaxHeap heap = new MaxHeap(array); System.out.println(Arrays.toString(heap.array)); while (heap.size &gt; 1) &#123; heap.swap(0, heap.size - 1); heap.size--; heap.down(0); &#125; System.out.println(Arrays.toString(heap.array)); &#125;&#125; 建堆Floyd 建堆算法作者（也是之前龟兔赛跑判环作者）： 找到最后一个非叶子节点 从后向前，对每个节点执行下潜 一些规律 一棵满二叉树节点个数为 $2^h-1$，如下例中高度 $h&#x3D;3$ 节点数是 $2^3-1&#x3D;7$ 非叶子节点范围为 $[0, size&#x2F;2-1]$ 算法时间复杂度分析 下面看交换次数的推导：设节点高度为 3 本层节点数 高度 下潜最多交换次数（高度-1） 4567 这层 4 1 0 23这层 2 2 1 1这层 1 3 2 每一层的交换次数为：$节点个数*此节点交换次数$，总的交换次数为$$\\begin{aligned}&amp; 4 * 0 + 2 * 1 + 1 * 2 \\ &amp; \\frac{8}{2}*0 + \\frac{8}{4}*1 + \\frac{8}{8}*2 \\ &amp; \\frac{8}{2^1}*0 + \\frac{8}{2^2}*1 + \\frac{8}{2^3}*2\\ \\end{aligned}$$即$$\\sum_{i&#x3D;1}^{h}(\\frac{2^h}{2^i}*(i-1))$$在 https://www.wolframalpha.com/ 输入 1Sum[\\(40)Divide[Power[2,x],Power[2,i]]*\\(40)i-1\\(41)\\(41),&#123;i,1,x&#125;] 推导出$$2^h -h -1$$其中 $2^h \\approx n$，$h \\approx \\log_2{n}$，因此有时间复杂度 $O(n)$ 习题E01. 堆排序算法描述 heapify 建立大顶堆 将堆顶与堆底交换（最大元素被交换到堆底），缩小并下潜调整堆 重复第二步直至堆里剩一个元素 可以使用之前课堂例题的大顶堆来实现 12345678910int[] array = &#123;1, 2, 3, 4, 5, 6, 7&#125;;MaxHeap maxHeap = new MaxHeap(array);System.out.println(Arrays.toString(maxHeap.array));while (maxHeap.size &gt; 1) &#123; maxHeap.swap(0, maxHeap.size - 1); maxHeap.size--; maxHeap.down(0);&#125;System.out.println(Arrays.toString(maxHeap.array)); E02. 数组中第K大元素-Leetcode 215小顶堆（可删去用不到代码） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class MinHeap &#123; int[] array; int size; public MinHeap(int capacity) &#123; array = new int[capacity]; &#125; private void heapify() &#123; for (int i = (size &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123; down(i); &#125; &#125; public int poll() &#123; swap(0, size - 1); size--; down(0); return array[size]; &#125; public int poll(int index) &#123; swap(index, size - 1); size--; down(index); return array[size]; &#125; public int peek() &#123; return array[0]; &#125; public boolean offer(int offered) &#123; if (size == array.length) &#123; return false; &#125; up(offered); size++; return true; &#125; public void replace(int replaced) &#123; array[0] = replaced; down(0); &#125; private void up(int offered) &#123; int child = size; while (child &gt; 0) &#123; int parent = (child - 1) &gt;&gt; 1; if (offered &lt; array[parent]) &#123; array[child] = array[parent]; &#125; else &#123; break; &#125; child = parent; &#125; array[child] = offered; &#125; private void down(int parent) &#123; int left = (parent &lt;&lt; 1) + 1; int right = left + 1; int min = parent; if (left &lt; size &amp;&amp; array[left] &lt; array[min]) &#123; min = left; &#125; if (right &lt; size &amp;&amp; array[right] &lt; array[min]) &#123; min = right; &#125; if (min != parent) &#123; swap(min, parent); down(min); &#125; &#125; // 交换两个索引处的元素 private void swap(int i, int j) &#123; int t = array[i]; array[i] = array[j]; array[j] = t; &#125;&#125; 题解 123456789101112public int findKthLargest(int[] numbers, int k) &#123; MinHeap heap = new MinHeap(k); for (int i = 0; i &lt; k; i++) &#123; heap.offer(numbers[i]); &#125; for (int i = k; i &lt; numbers.length; i++) &#123; if(numbers[i] &gt; heap.peek())&#123; heap.replace(numbers[i]); &#125; &#125; return heap.peek();&#125; 求数组中的第 K 大元素，使用堆并不是最佳选择，可以采用快速选择算法 E03. 数据流中第K大元素-Leetcode 703上题的小顶堆加一个方法 123456class MinHeap &#123; // ...\tpublic boolean isFull() &#123; return size == array.length; &#125;&#125; 题解 123456789101112131415161718192021class KthLargest &#123; private MinHeap heap; public KthLargest(int k, int[] nums) &#123; heap = new MinHeap(k); for(int i = 0; i &lt; nums.length; i++) &#123; add(nums[i]); &#125; &#125; public int add(int val) &#123; if(!heap.isFull())&#123; heap.offer(val); &#125; else if(val &gt; heap.peek())&#123; heap.replace(val); &#125; return heap.peek(); &#125; &#125; 求数据流中的第 K 大元素，使用堆最合适不过 E04. 数据流的中位数-Leetcode 295可以扩容的 heap, max 用于指定是大顶堆还是小顶堆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class Heap &#123; int[] array; int size; boolean max; public int size() &#123; return size; &#125; public Heap(int capacity, boolean max) &#123; this.array = new int[capacity]; this.max = max; &#125; /** * 获取堆顶元素 * * @return 堆顶元素 */ public int peek() &#123; return array[0]; &#125; /** * 删除堆顶元素 * * @return 堆顶元素 */ public int poll() &#123; int top = array[0]; swap(0, size - 1); size--; down(0); return top; &#125; /** * 删除指定索引处元素 * * @param index 索引 * @return 被删除元素 */ public int poll(int index) &#123; int deleted = array[index]; swap(index, size - 1); size--; down(index); return deleted; &#125; /** * 替换堆顶元素 * * @param replaced 新元素 */ public void replace(int replaced) &#123; array[0] = replaced; down(0); &#125; /** * 堆的尾部添加元素 * * @param offered 新元素 */ public void offer(int offered) &#123; if (size == array.length) &#123; grow(); &#125; up(offered); size++; &#125; private void grow() &#123; int capacity = size + (size &gt;&gt; 1); int[] newArray = new int[capacity]; System.arraycopy(array, 0, newArray, 0, size); array = newArray; &#125; // 将 offered 元素上浮: 直至 offered 小于父元素或到堆顶 private void up(int offered) &#123; int child = size; while (child &gt; 0) &#123; int parent = (child - 1) / 2; boolean cmp = max ? offered &gt; array[parent] : offered &lt; array[parent]; if (cmp) &#123; array[child] = array[parent]; &#125; else &#123; break; &#125; child = parent; &#125; array[child] = offered; &#125; public Heap(int[] array, boolean max) &#123; this.array = array; this.size = array.length; this.max = max; heapify(); &#125; // 建堆 private void heapify() &#123; // 如何找到最后这个非叶子节点 size / 2 - 1 for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; down(i); &#125; &#125; // 将 parent 索引处的元素下潜: 与两个孩子较大者交换, 直至没孩子或孩子没它大 private void down(int parent) &#123; int left = parent * 2 + 1; int right = left + 1; int min = parent; if (left &lt; size &amp;&amp; (max ? array[left] &gt; array[min] : array[left] &lt; array[min])) &#123; min = left; &#125; if (right &lt; size &amp;&amp; (max ? array[right] &gt; array[min] : array[right] &lt; array[min])) &#123; min = right; &#125; if (min != parent) &#123; // 找到了更大的孩子 swap(min, parent); down(min); &#125; &#125; // 交换两个索引处的元素 private void swap(int i, int j) &#123; int t = array[i]; array[i] = array[j]; array[j] = t; &#125;&#125; 题解 1234567891011121314151617181920212223242526272829303132333435363738private Heap left = new Heap(10, false);private Heap right = new Heap(10, true);/** 为了保证两边数据量的平衡 &lt;ul&gt; &lt;li&gt;两边数据一样时,加入左边&lt;/li&gt; &lt;li&gt;两边数据不一样时,加入右边&lt;/li&gt; &lt;/ul&gt; 但是, 随便一个数能直接加入吗? &lt;ul&gt; &lt;li&gt;加入左边前, 应该挑右边最小的加入&lt;/li&gt; &lt;li&gt;加入右边前, 应该挑左边最大的加入&lt;/li&gt; &lt;/ul&gt; */public void addNum(int num) &#123; if (left.size() == right.size()) &#123; right.offer(num); left.offer(right.poll()); &#125; else &#123; left.offer(num); right.offer(left.poll()); &#125;&#125;/** * &lt;ul&gt; * &lt;li&gt;两边数据一致, 左右各取堆顶元素求平均&lt;/li&gt; * &lt;li&gt;左边多一个, 取左边元素&lt;/li&gt; * &lt;/ul&gt; */public double findMedian() &#123; if (left.size() == right.size()) &#123; return (left.peek() + right.peek()) / 2.0; &#125; else &#123; return left.peek(); &#125;&#125; 本题还可以使用平衡二叉搜索树求解，不过代码比两个堆复杂 2.10 二叉树二叉树是这么一种树状结构：每个节点最多有两个孩子，左孩子和右孩子 重要的二叉树结构 完全二叉树（complete binary tree）是一种二叉树结构，除最后一层以外，每一层都必须填满，填充时要遵从先左后右 平衡二叉树（balance binary tree）是一种二叉树结构，其中每个节点的左右子树高度相差不超过 1 1) 存储存储方式分为两种 定义树节点与左、右孩子引用（TreeNode） 使用数组，前面讲堆时用过，若以 0 作为树的根，索引可以通过如下方式计算 父 &#x3D; floor((子 - 1) &#x2F; 2) 左孩子 &#x3D; 父 * 2 + 1 右孩子 &#x3D; 父 * 2 + 2 2) 遍历遍历也分为两种 广度优先遍历（Breadth-first order）：尽可能先访问距离根最近的节点，也称为层序遍历 深度优先遍历（Depth-first order）：对于二叉树，可以进一步分成三种（要深入到叶子节点） pre-order 前序遍历，对于每一棵子树，先访问该节点，然后是左子树，最后是右子树 in-order 中序遍历，对于每一棵子树，先访问左子树，然后是该节点，最后是右子树 post-order 后序遍历，对于每一棵子树，先访问左子树，然后是右子树，最后是该节点 广度优先 本轮开始时队列 本轮访问节点 [1] 1 [2, 3] 2 [3, 4] 3 [4, 5, 6] 4 [5, 6] 5 [6, 7, 8] 6 [7, 8] 7 [8] 8 [] 初始化，将根节点加入队列 循环处理队列中每个节点，直至队列为空 每次循环内处理节点后，将它的孩子节点（即下一层的节点）加入队列 注意 以上用队列来层序遍历是针对 TreeNode 这种方式表示的二叉树 对于数组表现的二叉树，则直接遍历数组即可，自然为层序遍历的顺序 深度优先 栈暂存 已处理 前序遍历 中序遍历 [1] 1 ✔️ 左💤 右💤 1 [1, 2] 2✔️ 左💤 右💤1✔️ 左💤 右💤 2 [1, 2, 4] 4✔️ 左✔️ 右✔️2✔️ 左💤 右💤1✔️ 左💤 右💤 4 4 [1, 2] 2✔️ 左✔️ 右✔️1✔️ 左💤 右💤 2 [1] 1✔️ 左✔️ 右💤 1 [1, 3] 3✔️ 左💤 右💤1✔️ 左✔️ 右💤 3 [1, 3, 5] 5✔️ 左✔️ 右✔️3✔️ 左💤 右💤1✔️ 左✔️ 右💤 5 5 [1, 3] 3✔️ 左✔️ 右💤1✔️ 左✔️ 右💤 3 [1, 3, 6] 6✔️ 左✔️ 右✔️3✔️ 左✔️ 右💤1✔️ 左✔️ 右💤 6 6 [1, 3] 3✔️ 左✔️ 右✔️1✔️ 左✔️ 右💤 [1] 1✔️ 左✔️ 右✔️ [] 递归实现1234567891011121314151617181920212223242526272829303132333435363738/** * &lt;h3&gt;前序遍历&lt;/h3&gt; * @param node 节点 */static void preOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; System.out.print(node.val + &quot;\\t&quot;); // 值 preOrder(node.left); // 左 preOrder(node.right); // 右&#125;/** * &lt;h3&gt;中序遍历&lt;/h3&gt; * @param node 节点 */static void inOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; inOrder(node.left); // 左 System.out.print(node.val + &quot;\\t&quot;); // 值 inOrder(node.right); // 右&#125;/** * &lt;h3&gt;后序遍历&lt;/h3&gt; * @param node 节点 */static void postOrder(TreeNode node) &#123; if (node == null) &#123; return; &#125; postOrder(node.left); // 左 postOrder(node.right); // 右 System.out.print(node.val + &quot;\\t&quot;); // 值&#125; 非递归实现前序遍历 1234567891011121314LinkedListStack&lt;TreeNode&gt; stack = new LinkedListStack&lt;&gt;();TreeNode curr = root;while (!stack.isEmpty() || curr != null) &#123; if (curr != null) &#123; stack.push(curr); System.out.println(curr); curr = curr.left; &#125; else &#123; TreeNode pop = stack.pop(); curr = pop.right; &#125;&#125; 中序遍历 12345678910111213LinkedListStack&lt;TreeNode&gt; stack = new LinkedListStack&lt;&gt;();TreeNode curr = root;while (!stack.isEmpty() || curr != null) &#123; if (curr != null) &#123; stack.push(curr); curr = curr.left; &#125; else &#123; TreeNode pop = stack.pop(); System.out.println(pop); curr = pop.right; &#125;&#125; 后序遍历 123456789101112131415161718LinkedListStack&lt;TreeNode&gt; stack = new LinkedListStack&lt;&gt;();TreeNode curr = root;TreeNode pop = null;while (!stack.isEmpty() || curr != null) &#123; if (curr != null) &#123; stack.push(curr); curr = curr.left; &#125; else &#123; TreeNode peek = stack.peek(); if (peek.right == null || peek.right == pop) &#123; pop = stack.pop(); System.out.println(pop); &#125; else &#123; curr = peek.right; &#125; &#125;&#125; 对于后序遍历，向回走时，需要处理完右子树才能 pop 出栈。如何知道右子树处理完成呢？ 如果栈顶元素的 $right \\equiv null$ 表示没啥可处理的，可以出栈 如果栈顶元素的 $right eq null$， 那么使用 lastPop 记录最近出栈的节点，即表示从这个节点向回走 如果栈顶元素的 $right&#x3D;&#x3D;lastPop$ 此时应当出栈 对于前、中两种遍历，实际以上代码从右子树向回走时，并未走完全程（stack 提前出栈了）后序遍历以上代码是走完全程了 统一写法 下面是一种统一的写法，依据后序遍历修改 123456789101112131415161718192021222324252627282930313233LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();TreeNode curr = root; // 代表当前节点TreeNode pop = null; // 最近一次弹栈的元素while (curr != null || !stack.isEmpty()) &#123; if (curr != null) &#123; colorPrintln(&quot;前: &quot; + curr.val, 31); stack.push(curr); // 压入栈，为了记住回来的路 curr = curr.left; &#125; else &#123; TreeNode peek = stack.peek(); // 右子树可以不处理, 对中序来说, 要在右子树处理之前打印 if (peek.right == null) &#123; colorPrintln(&quot;中: &quot; + peek.val, 36); pop = stack.pop(); colorPrintln(&quot;后: &quot; + pop.val, 34); &#125; // 右子树处理完成, 对中序来说, 无需打印 else if (peek.right == pop) &#123; pop = stack.pop(); colorPrintln(&quot;后: &quot; + pop.val, 34); &#125; // 右子树待处理, 对中序来说, 要在右子树处理之前打印 else &#123; colorPrintln(&quot;中: &quot; + peek.val, 36); curr = peek.right; &#125; &#125;&#125;public static void colorPrintln(String origin, int color) &#123; System.out.printf(&quot;\\033[%dm%s\\033[0m%n&quot;, color, origin);&#125; 一张图演示三种遍历 红色：前序遍历顺序 绿色：中序遍历顺序 蓝色：后续遍历顺序 习题E01. 前序遍历二叉树-Leetcode 144E02. 中序遍历二叉树-Leetcode 94E03. 后序遍历二叉树-Leetcode 145E04. 对称二叉树-Leetcode 101123456789101112131415161718public boolean isSymmetric(TreeNode root) &#123; return check(root.left, root.right);&#125;public boolean check(TreeNode left, TreeNode right) &#123; // 若同时为 null if (left == null &amp;&amp; right == null) &#123; return true; &#125; // 若有一个为 null (有上一轮筛选，另一个肯定不为 null) if (left == null || right == null) &#123; return false; &#125; if (left.val != right.val) &#123; return false; &#125; return check(left.left, right.right) &amp;&amp; check(left.right, right.left);&#125; 类似题目：Leetcode 100 题 - 相同的树 E05. 二叉树最大深度-Leetcode 104后序遍历求解 12345678910111213141516171819202122/* 思路： 1. 得到左子树深度, 得到右子树深度, 二者最大者加一, 就是本节点深度 2. 因为需要先得到左右子树深度, 很显然是后序遍历典型应用 3. 关于深度的定义：从根出发, 离根最远的节点总边数, 注意: 力扣里的深度定义要多一 深度2 深度3 深度1 1 1 1 / \\ / \\ 2 3 2 3 \\ 4 */public int maxDepth(TreeNode node) &#123; if (node == null) &#123; return 0; // 非力扣题目改为返回 -1 &#125; int d1 = maxDepth(node.left); int d2 = maxDepth(node.right); return Integer.max(d1, d2) + 1;&#125; 后序遍历求解-非递归 12345678910111213141516171819202122232425262728/* 思路： 1. 使用非递归后序遍历, 栈的最大高度即为最大深度 */public int maxDepth(TreeNode root) &#123; TreeNode curr = root; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); int max = 0; TreeNode pop = null; while (curr != null || !stack.isEmpty()) &#123; if (curr != null) &#123; stack.push(curr); int size = stack.size(); if (size &gt; max) &#123; max = size; &#125; curr = curr.left; &#125; else &#123; TreeNode peek = stack.peek(); if(peek.right == null || peek.right == pop) &#123; pop = stack.pop(); &#125; else &#123; curr = peek.right; &#125; &#125; &#125; return max;&#125; 层序遍历求解 1234567891011121314151617181920212223242526/* 思路： 1. 使用层序遍历, 层数即最大深度 */public int maxDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int level = 0; while (!queue.isEmpty()) &#123; level++; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; &#125; return level;&#125; E06. 二叉树最小深度-Leetcode 111后序遍历求解 1234567891011public int minDepth(TreeNode node) &#123; if (node == null) &#123; return 0; &#125; int d1 = minDepth(node.left); int d2 = minDepth(node.right); if (d1 == 0 || d2 == 0) &#123; return d1 + d2 + 1; &#125; return Integer.min(d1, d2) + 1;&#125; 相较于求最大深度，应当考虑： 当右子树为 null，应当返回左子树深度加一 当左子树为 null，应当返回右子树深度加一 上面两种情况满足时，不应该再把为 null 子树的深度 0 参与最小值比较，例如这样 123 1 /2 正确深度为 2，若把为 null 的右子树的深度 0 考虑进来，会得到错误结果 1 123451 \\ 3 \\ 4 正确深度为 3，若把为 null 的左子树的深度 0 考虑进来，会得到错误结果 1 层序遍历求解 遇到的第一个叶子节点所在层就是最小深度 例如，下面的树遇到的第一个叶子节点 3 所在的层就是最小深度，其他 4，7 等叶子节点深度更深，也更晚遇到 1234567 1 / \\ 2 3 / \\4 5 / 7 代码 12345678910111213141516171819202122232425public int minDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int level = 0; while (!queue.isEmpty()) &#123; level++; int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if (node.left == null &amp;&amp; node.right == null) &#123; return level; &#125; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; &#125; return level;&#125; 效率会高于之前后序遍历解法，因为找到第一个叶子节点后，就无需后续的层序遍历了 E07. 翻转二叉树-Leetcode 226123456789101112131415public TreeNode invertTree(TreeNode root) &#123; fn(root); return root;&#125;private void fn(TreeNode node)&#123; if (node == null) &#123; return; &#125; TreeNode t = node.left; node.left = node.right; node.right = t; fn(node.left); fn(node.right);&#125; 先交换、再递归或是先递归、再交换都可以 E08. 后缀表达式转二叉树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static class TreeNode &#123; public String val; public TreeNode left; public TreeNode right; public TreeNode(String val) &#123; this.val = val; &#125; public TreeNode(TreeNode left, String val, TreeNode right) &#123; this.left = left; this.val = val; this.right = right; &#125; @Override public String toString() &#123; return this.val; &#125;&#125;/* 中缀表达式 (2-1)*3 后缀（逆波兰）表达式 21-3* 1.遇到数字入栈 2.遇到运算符, 出栈两次, 与当前节点建立父子关系, 当前节点入栈 栈 | | | | | | _____ 表达式树 * / \\ - 3 / \\ 2 1 21-3* */public TreeNode constructExpressionTree(String[] tokens) &#123; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); for (String t : tokens) &#123; switch (t) &#123; case &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot; -&gt; &#123; // 运算符 TreeNode right = stack.pop(); TreeNode left = stack.pop(); TreeNode parent = new TreeNode(t); parent.left = left; parent.right = right; stack.push(parent); &#125; default -&gt; &#123; // 数字 stack.push(new TreeNode(t)); &#125; &#125; &#125; return stack.peek();&#125; E09. 根据前序与中序遍历结果构造二叉树-Leetcode 105 先通过前序遍历结果定位根节点 再结合中序遍历结果切分左右子树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class E09Leetcode105 &#123; /* preOrder = &#123;1,2,4,3,6,7&#125; inOrder = &#123;4,2,1,6,3,7&#125; 根 1 pre in 左 2,4 4,2 右 3,6,7 6,3,7 根 2 左 4 根 3 左 6 右 7 */ public TreeNode buildTree(int[] preOrder, int[] inOrder) &#123; if (preOrder.length == 0) &#123; return null; &#125; // 创建根节点 int rootValue = preOrder[0]; TreeNode root = new TreeNode(rootValue); // 区分左右子树 for (int i = 0; i &lt; inOrder.length; i++) &#123; if (inOrder[i] == rootValue) &#123; // 0 ~ i-1 左子树 // i+1 ~ inOrder.length -1 右子树 int[] inLeft = Arrays.copyOfRange(inOrder, 0, i); // [4,2] int[] inRight = Arrays.copyOfRange(inOrder, i + 1, inOrder.length); // [6,3,7] int[] preLeft = Arrays.copyOfRange(preOrder, 1, i + 1); // [2,4] int[] preRight = Arrays.copyOfRange(preOrder, i + 1, inOrder.length); // [3,6,7] root.left = buildTree(preLeft, inLeft); // 2 root.right = buildTree(preRight, inRight); // 3 break; &#125; &#125; return root; &#125;&#125; 代码可以进一步优化，涉及新数据结构，以后实现 E10. 根据中序与后序遍历结果构造二叉树-Leetcode 106 先通过后序遍历结果定位根节点 再结合中序遍历结果切分左右子树 1234567891011121314151617181920212223public TreeNode buildTree(int[] inOrder, int[] postOrder) &#123; if (inOrder.length == 0) &#123; return null; &#125; // 根 int rootValue = postOrder[postOrder.length - 1]; TreeNode root = new TreeNode(rootValue); // 切分左右子树 for (int i = 0; i &lt; inOrder.length; i++) &#123; if (inOrder[i] == rootValue) &#123; int[] inLeft = Arrays.copyOfRange(inOrder, 0, i); int[] inRight = Arrays.copyOfRange(inOrder, i + 1, inOrder.length); int[] postLeft = Arrays.copyOfRange(postOrder, 0, i); int[] postRight = Arrays.copyOfRange(postOrder, i, postOrder.length - 1); root.left = buildTree(inLeft, postLeft); root.right = buildTree(inRight, postRight); break; &#125; &#125; return root;&#125; 代码可以进一步优化，涉及新数据结构，以后实现 三. 基础算法3.1 查找概述查找算法是一种在数据集中寻找特定数据项的方法。通常，数据集是在计算机程序中存储的，例如数组、链表或散列表。在编写程序时，查找算法是非常重要的，它有助于快速找到所需的数据。在本文中，我们将介绍一些基本的查找算法及其特点。 线性查找线性查找也称为顺序查找，是一种最简单的查找算法。在这种算法中，我们从数据集的开头开始，逐个比较每个数据项，以寻找要查找的数据。如果我们找到了目标数据，查找过程就结束了。如果我们到达数据集的末尾，仍然找不到目标数据，则可以认为它不存在于数据集中。 线性查找的时间复杂度是O(n)，其中n是数据集的大小。因此，它在大型数据集中可能会很慢。然而，在小型数据集中，它仍然是一种非常有用的算法。 二分查找二分查找也称为折半查找，是一种更快速的查找算法。但前提是，数据集必须已经排序。在二分查找中，我们取数据集的中间值，然后将目标与中间值进行比较。如果目标小于中间值，则在左侧子集中继续查找；如果目标大于中间值，则在右侧子集中继续查找。每次比较都会缩小要搜索的数据集的大小。 二分查找的时间复杂度是O(log n)，其中n是数据集的大小。这种算法在大型数据集中非常有效，但在小型数据集中可能并不是最快的选择。 哈希表查找哈希表查找也称为散列表查找，是另一种常见的查找算法。它利用哈希函数将数据项映射到散列表中的位置。在查找过程中，我们只需通过哈希函数计算目标数据的位置，然后检查该位置是否包含目标数据。 哈希表查找的时间复杂度是O(1)。这使得它成为大型数据集中最快的查找算法之一。但是，哈希表查找的效率取决于哈希函数的质量。如果两个数据项映射到相同的位置，就会发生哈希冲突，这可能会导致性能下降。 小结在编写程序时，我们需要选择适合数据集大小和其他要求的最佳查找算法。例如，如果数据集很小，则线性查找可能是最快的选择；如果数据集已经排序，则二分查找是非常有用的。然而，在大型数据集中，哈希表查找通常是最好的选择。了解不同类型的查找算法及其特点可以帮助我们在编写程序时做出明智的选择。 不管是之前学过的数组、链表、队列、还是栈，这些线性结构中，如果想在其中查找一个元素，效率是比较慢的，只有$O(N)$，因此如果你的需求是实现数据的快速查找，那么就需要新的数据结构支持。 还记得最先介绍的那个二分查找算法吗？它的查找效率能够达到 $O(\\log{N})$，是不是还不错？不过呢，它需要对数组事先排好序，而排序的成本是比较高的。那么有没有一个折中的办法呢？有，那就是接下来要给大家介绍的二叉搜索树，它插入元素后，自然就是排好序的，接下来的查询也自然而然可以应用二分查找算法进行高效搜索。 3.2 二叉搜索树概述历史 二叉搜索树最早是由Bernoulli兄弟在18世纪中提出的，但是真正推广和应用该数据结构的是1960年代的D.L. Gries。他的著作《The Science of Programming》中详细介绍了二叉搜索树的实现和应用。 在计算机科学的发展中，二叉搜索树成为了一种非常基础的数据结构，被广泛应用在各种领域，包括搜索、排序、数据库索引等。随着计算机算力的提升和对数据结构的深入研究，二叉搜索树也不断被优化和扩展，例如AVL树、红黑树等。 特性二叉搜索树（也称二叉排序树）是符合下面特征的二叉树： 树节点增加 key 属性，用来比较谁大谁小，key 不可以重复 对于任意一个树节点，它的 key 比左子树的 key 都大，同时也比右子树的 key 都小，例如下图所示 轻易看出要查找 7 （从根开始）自然就可应用二分查找算法，只需三次比较 与 4 比，较之大，向右找 与 6 比，较之大，继续向右找 与 7 比，找到 查找的时间复杂度与树高相关，插入、删除也是如此。 如果这棵树长得还不赖（左右平衡）上图，那么时间复杂度均是 $O(\\log{N})$ 当然，这棵树如果长得丑（左右高度相差过大）下图，那么这时是最糟的情况，时间复杂度是 $O(N)$ 注： 二叉搜索树 - 英文 binary search tree，简称 BST 二叉排序树 - 英文 binary ordered tree 或 binary sorted tree 实现定义节点1234567891011121314151617181920212223static class BSTNode &#123; int key; // 若希望任意类型作为 key, 则后续可以将其设计为 Comparable 接口 Object value; BSTNode left; BSTNode right; public BSTNode(int key) &#123; this.key = key; this.value = key; &#125; public BSTNode(int key, Object value) &#123; this.key = key; this.value = value; &#125; public BSTNode(int key, Object value, BSTNode left, BSTNode right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125;&#125; 查询递归实现 12345678910111213141516public Object get(int key) &#123; return doGet(root, key);&#125;private Object doGet(BSTNode node, int key) &#123; if (node == null) &#123; return null; // 没找到 &#125; if (key &lt; node.key) &#123; return doGet(node.left, key); // 向左找 &#125; else if (node.key &lt; key) &#123; return doGet(node.right, key); // 向右找 &#125; else &#123; return node.value; // 找到了 &#125;&#125; 非递归实现 12345678910111213public Object get(int key) &#123; BSTNode node = root; while (node != null) &#123; if (key &lt; node.key) &#123; node = node.left; &#125; else if (node.key &lt; key) &#123; node = node.right; &#125; else &#123; return node.value; &#125; &#125; return null;&#125; Comparable如果希望让除 int 外更多的类型能够作为 key，一种方式是 key 必须实现 Comparable 接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BSTTree2&lt;T extends Comparable&lt;T&gt;&gt; &#123; static class BSTNode&lt;T&gt; &#123; T key; // 若希望任意类型作为 key, 则后续可以将其设计为 Comparable 接口 Object value; BSTNode&lt;T&gt; left; BSTNode&lt;T&gt; right; public BSTNode(T key) &#123; this.key = key; this.value = key; &#125; public BSTNode(T key, Object value) &#123; this.key = key; this.value = value; &#125; public BSTNode(T key, Object value, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125; &#125; BSTNode&lt;T&gt; root; public Object get(T key) &#123; return doGet(root, key); &#125; private Object doGet(BSTNode&lt;T&gt; node, T key) &#123; if (node == null) &#123; return null; &#125; int result = node.key.compareTo(key); if (result &gt; 0) &#123; return doGet(node.left, key); &#125; else if (result &lt; 0) &#123; return doGet(node.right, key); &#125; else &#123; return node.value; &#125; &#125;&#125; 还有一种做法不要求 key 实现 Comparable 接口，而是在构造 Tree 时把比较规则作为 Comparator 传入，将来比较 key 大小时都调用此 Comparator 进行比较，这种做法可以参考 Java 中的 java.util.TreeMap 最小递归实现 1234567891011121314public Object min() &#123; return doMin(root);&#125;public Object doMin(BSTNode node) &#123; if (node == null) &#123; return null; &#125; // 左边已走到头 if (node.left == null) &#123; return node.value; &#125; return doMin(node.left);&#125; 非递归实现 1234567891011public Object min() &#123; if (root == null) &#123; return null; &#125; BSTNode p = root; // 左边未走到头 while (p.left != null) &#123; p = p.left; &#125; return p.value;&#125; 最大递归实现 1234567891011121314public Object max() &#123; return doMax(root);&#125;public Object doMax(BSTNode node) &#123; if (node == null) &#123; return null; &#125; // 右边已走到头 if (node.left == null) &#123; return node.value; &#125; return doMin(node.right);&#125; 非递归实现 1234567891011public Object max() &#123; if (root == null) &#123; return null; &#125; BSTNode p = root; // 右边未走到头 while (p.right != null) &#123; p = p.right; &#125; return p.value;&#125; 新增递归实现 1234567891011121314151617public void put(int key, Object value) &#123; root = doPut(root, key, value);&#125;private BSTNode doPut(BSTNode node, int key, Object value) &#123; if (node == null) &#123; return new BSTNode(key, value); &#125; if (key &lt; node.key) &#123; node.left = doPut(node.left, key, value); &#125; else if (node.key &lt; key) &#123; node.right = doPut(node.right, key, value); &#125; else &#123; node.value = value; &#125; return node;&#125; 若找到 key，走 else 更新找到节点的值 若没找到 key，走第一个 if，创建并返回新节点 返回的新节点，作为上次递归时 node 的左孩子或右孩子 缺点是，会有很多不必要的赋值操作 非递归实现 123456789101112131415161718192021222324public void put(int key, Object value) &#123; BSTNode node = root; BSTNode parent = null; while (node != null) &#123; parent = node; if (key &lt; node.key) &#123; node = node.left; &#125; else if (node.key &lt; key) &#123; node = node.right; &#125; else &#123; // 1. key 存在则更新 node.value = value; return; &#125; &#125; // 2. key 不存在则新增 if (parent == null) &#123; root = new BSTNode(key, value); &#125; else if (key &lt; parent.key) &#123; parent.left = new BSTNode(key, value); &#125; else &#123; parent.right = new BSTNode(key, value); &#125;&#125; 前驱后继 一个节点的前驱（前任）节点是指比它小的节点中，最大的那个 一个节点的后继（后任）节点是指比它大的节点中，最小的那个 例如上图中 1 没有前驱，后继是 2 2 前驱是 1，后继是 3 3 前驱是 2，后继是 4 … 简单的办法是中序遍历，即可获得排序结果，此时很容易找到前驱后继 要效率更高，需要研究一下规律，找前驱分成 2 种情况： 节点有左子树，此时前驱节点就是左子树的最大值，图中属于这种情况的有 2 的前驱是1 4 的前驱是 3 6 的前驱是 5 7 的前驱是 6 节点没有左子树，若离它最近的祖先自从左而来，此祖先即为前驱，如 3 的祖先 2 自左而来，前驱 2 5 的祖先 4 自左而来，前驱 4 8 的祖先 7 自左而来，前驱 7 1 没有这样的祖先，前驱 null 找后继也分成 2 种情况 节点有右子树，此时后继节点即为右子树的最小值，如 2 的后继 3 3 的后继 4 5 的后继 6 7 的后继 8 节点没有右子树，若离它最近的祖先自从右而来，此祖先即为后继，如 1 的祖先 2 自右而来，后继 2 4 的祖先 5 自右而来，后继 5 6 的祖先 7 自右而来，后继 7 8 没有这样的祖先，后继 null 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public Object predecessor(int key) &#123; BSTNode ancestorFromLeft = null; BSTNode p = root; while (p != null) &#123; if (key &lt; p.key) &#123; p = p.left; &#125; else if (p.key &lt; key) &#123; ancestorFromLeft = p; p = p.right; &#125; else &#123; break; &#125; &#125; if (p == null) &#123; return null; &#125; // 情况1 - 有左孩子 if (p.left != null) &#123; return max(p.left); &#125; // 情况2 - 有祖先自左而来 return ancestorFromLeft != null ? ancestorFromLeft.value : null;&#125;public Object successor(int key) &#123; BSTNode ancestorFromRight = null; BSTNode p = root; while (p != null) &#123; if (key &lt; p.key) &#123; ancestorFromRight = p; p = p.left; &#125; else if (p.key &lt; key) &#123; p = p.right; &#125; else &#123; break; &#125; &#125; if (p == null) &#123; return null; &#125; // 情况1 - 有右孩子 if (p.right != null) &#123; return min(p.right); &#125; // 情况2 - 有祖先自右而来 return ancestorFromRight != null ? ancestorFromRight.value : null;&#125; 删除要删除某节点（称为 D），必须先找到被删除节点的父节点，这里称为 Parent 删除节点没有左孩子，将右孩子托孤给 Parent 删除节点没有右孩子，将左孩子托孤给 Parent 删除节点左右孩子都没有，已经被涵盖在情况1、情况2 当中，把 null 托孤给 Parent 删除节点左右孩子都有，可以将它的后继节点（称为 S）托孤给 Parent，设 S 的父亲为 SP，又分两种情况 SP 就是被删除节点，此时 D 与 S 紧邻，只需将 S 托孤给 Parent SP 不是被删除节点，此时 D 与 S 不相邻，此时需要将 S 的后代托孤给 SP，再将 S 托孤给 Parent 非递归实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * &lt;h3&gt;根据关键字删除&lt;/h3&gt; * * @param key 关键字 * @return 被删除关键字对应值 */public Object delete(int key) &#123; BSTNode p = root; BSTNode parent = null; while (p != null) &#123; if (key &lt; p.key) &#123; parent = p; p = p.left; &#125; else if (p.key &lt; key) &#123; parent = p; p = p.right; &#125; else &#123; break; &#125; &#125; if (p == null) &#123; return null; &#125; // 删除操作 if (p.left == null) &#123; shift(parent, p, p.right); // 情况1 &#125; else if (p.right == null) &#123; shift(parent, p, p.left); // 情况2 &#125; else &#123; // 情况4 // 4.1 被删除节点找后继 BSTNode s = p.right; BSTNode sParent = p; // 后继父亲 while (s.left != null) &#123; sParent = s; s = s.left; &#125; // 4.2 删除和后继不相邻, 处理后继的后事 if (sParent != p) &#123; shift(sParent, s, s.right); // 不可能有左孩子 s.right = p.right; &#125; // 4.3 后继取代被删除节点 shift(parent, p, s); s.left = p.left; &#125; return p.value;&#125;/** * 托孤方法 * * @param parent 被删除节点的父亲 * @param deleted 被删除节点 * @param child 被顶上去的节点 */// 只考虑让 n1父亲的左或右孩子指向 n2, n1自己的左或右孩子并未在方法内改变private void shift(BSTNode parent, BSTNode deleted, BSTNode child) &#123; if (parent == null) &#123; root = child; &#125; else if (deleted == parent.left) &#123; parent.left = child; &#125; else &#123; parent.right = child; &#125;&#125; 递归实现 123456789101112131415161718192021222324252627282930public Object delete(int key) &#123; ArrayList&lt;Object&gt; result = new ArrayList&lt;&gt;(); root = doDelete(root, key, result); return result.isEmpty() ? null : result.get(0);&#125;public BSTNode doDelete(BSTNode node, int key, ArrayList&lt;Object&gt; result) &#123; if (node == null) &#123; return null; &#125; if (key &lt; node.key) &#123; node.left = doDelete(node.left, key, result); return node; &#125; if (node.key &lt; key) &#123; node.right = doDelete(node.right, key, result); return node; &#125; result.add(node.value); if (node.left != null &amp;&amp; node.right != null) &#123; BSTNode s = node.right; while (s.left != null) &#123; s = s.left; &#125; s.right = doDelete(node.right, s.key, new ArrayList&lt;&gt;()); s.left = node.left; return s; &#125; return node.left != null ? node.left : node.right;&#125; 说明 ArrayList&lt;Object&gt; result 用来保存被删除节点的值 第二、第三个 if 对应没找到的情况，继续递归查找和删除，注意后续的 doDelete 返回值代表删剩下的，因此需要更新 最后一个 return 对应删除节点只有一个孩子的情况，返回那个不为空的孩子，待删节点自己因没有返回而被删除 第四个 if 对应删除节点有两个孩子的情况，此时需要找到后继节点，并在待删除节点的右子树中删掉后继节点，最后用后继节点替代掉待删除节点返回，别忘了改变后继节点的左右指针 找小的1234567891011121314151617181920public List&lt;Object&gt; less(int key) &#123; ArrayList&lt;Object&gt; result = new ArrayList&lt;&gt;(); BSTNode p = root; LinkedList&lt;BSTNode&gt; stack = new LinkedList&lt;&gt;(); while (p != null || !stack.isEmpty()) &#123; if (p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; BSTNode pop = stack.pop(); if (pop.key &lt; key) &#123; result.add(pop.value); &#125; else &#123; break; &#125; p = pop.right; &#125; &#125; return result;&#125; 找大的123456789101112131415161718public List&lt;Object&gt; greater(int key) &#123; ArrayList&lt;Object&gt; result = new ArrayList&lt;&gt;(); BSTNode p = root; LinkedList&lt;BSTNode&gt; stack = new LinkedList&lt;&gt;(); while (p != null || !stack.isEmpty()) &#123; if (p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; BSTNode pop = stack.pop(); if (pop.key &gt; key) &#123; result.add(pop.value); &#125; p = pop.right; &#125; &#125; return result;&#125; 但这样效率不高，可以用 RNL 遍历 注： Pre-order, NLR In-order, LNR Post-order, LRN Reverse pre-order, NRL Reverse in-order, RNL Reverse post-order, RLN 1234567891011121314151617181920public List&lt;Object&gt; greater(int key) &#123; ArrayList&lt;Object&gt; result = new ArrayList&lt;&gt;(); BSTNode p = root; LinkedList&lt;BSTNode&gt; stack = new LinkedList&lt;&gt;(); while (p != null || !stack.isEmpty()) &#123; if (p != null) &#123; stack.push(p); p = p.right; &#125; else &#123; BSTNode pop = stack.pop(); if (pop.key &gt; key) &#123; result.add(pop.value); &#125; else &#123; break; &#125; p = pop.left; &#125; &#125; return result;&#125; 找之间1234567891011121314151617181920public List&lt;Object&gt; between(int key1, int key2) &#123; ArrayList&lt;Object&gt; result = new ArrayList&lt;&gt;(); BSTNode p = root; LinkedList&lt;BSTNode&gt; stack = new LinkedList&lt;&gt;(); while (p != null || !stack.isEmpty()) &#123; if (p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; BSTNode pop = stack.pop(); if (pop.key &gt;= key1 &amp;&amp; pop.key &lt;= key2) &#123; result.add(pop.value); &#125; else if (pop.key &gt; key2) &#123; break; &#125; p = pop.right; &#125; &#125; return result;&#125; 小结优点： 如果每个节点的左子树和右子树的大小差距不超过一，可以保证搜索操作的时间复杂度是 O(log n)，效率高。 插入、删除结点等操作也比较容易实现，效率也比较高。 对于有序数据的查询和处理，二叉查找树非常适用，可以使用中序遍历得到有序序列。 缺点： 如果输入的数据是有序或者近似有序的，就会出现极度不平衡的情况，可能导致搜索效率下降，时间复杂度退化成O(n)。 对于频繁地插入、删除操作，需要维护平衡二叉查找树，例如红黑树、AVL 树等，否则搜索效率也会下降。 对于存在大量重复数据的情况，需要做相应的处理，否则会导致树的深度增加，搜索效率下降。 对于结点过多的情况，由于树的空间开销较大，可能导致内存消耗过大，不适合对内存要求高的场景。 习题E01. 删除节点-Leetcode 450例题已经讲过，用非递归和递归均可实现，这里只给出递归参考代码 1234567891011121314151617181920212223242526public TreeNode deleteNode(TreeNode node, int key) &#123; if (node == null) &#123; return null; &#125; if (key &lt; node.val) &#123; node.left = deleteNode(node.left, key); return node; &#125; if (node.val &lt; key) &#123; node.right = deleteNode(node.right, key); return node; &#125; if (node.left == null) &#123; // 情况1 - 只有右孩子 return node.right; &#125; if (node.right == null) &#123; // 情况2 - 只有左孩子 return node.left; &#125; TreeNode s = node.right; // 情况3 - 有两个孩子 while (s.left != null) &#123; s = s.left; &#125; s.right = deleteNode(node.right, s.val); s.left = node.left; return s;&#125; 树节点 TreeNode 相当于例题中的 BSTNode TreeNode 有属性：val, left, right，并未区分键值 BSTNode 有属性：key, value, left, right，区分了键值 它的 TreeNode 没有 key，比较用的是 TreeNode.val 属性与待删除 key 进行比较 E02. 新增节点-Leetcode 701例题也讲过了（put），下面给出递归实现 1234567891011public TreeNode insertIntoBST(TreeNode node, int val) &#123; if(node == null) &#123; return new TreeNode(val); &#125; if(val &lt; node.val) &#123; node.left = insertIntoBST(node.left, val); &#125; else if(node.val &lt; val) &#123; node.right = insertIntoBST(node.right, val); &#125; return node;&#125; 注意事项与上题相同，不再赘述 题目提示输入的 val 一定与树中节点不同，因此只需考虑新增情况，不会出现更新情况 E03. 查询节点-Leetcode 700例题讲过，下面给出递归实现 123456789101112public TreeNode searchBST(TreeNode node, int val) &#123; if(node == null) &#123; return null; &#125; if(val &lt; node.val) &#123; return searchBST(node.left, val); &#125; else if(node.val &lt; val) &#123; return searchBST(node.right, val); &#125; else &#123; return node; &#125;&#125; E04. 验证二叉搜索树-Leetcode 98中序非递归实现 12345678910111213141516171819public boolean isValidBST(TreeNode root) &#123; TreeNode p = root; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); long prev = Long.MIN_VALUE; while (p != null || !stack.isEmpty()) &#123; if (p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; TreeNode pop = stack.pop(); if (prev &gt;= pop.val) &#123; return false; &#125; prev = pop.val; p = pop.right; &#125; &#125; return true;&#125; 记录 prev 需要用 long，否则若测试用例中最小的节点为 Integer.MIN_VALUE 则测试会失败 注意，如果相邻两个节点相等，也不应当通过测试，例如，下面的树也是不合法的 1232 / 2 中序递归实现 12345678910111213141516171819public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return doValid(new AtomicLong(Long.MIN_VALUE),root);&#125;public boolean doValid(AtomicLong prev, TreeNode node) &#123; if (node == null) &#123; return true; &#125; boolean a = doValid(prev, node.left); if (prev.get() &gt;= node.val) &#123; return false; &#125; prev.set(node.val); boolean b = doValid(prev, node.right); return a &amp;&amp; b;&#125; 为何不能用 Long 或 long？因为它们都是局部变量且不可变，因此每次赋值时，并不会改变其它方法调用时的 prev 要么把 prev 设置为 AtomicLong，要么把 prev 设置为全局变量，而不要采用方法参数这样的局部变量 上述代码并不是最有效率的，分析过程见视频讲解 上下限递归 12345678910111213public boolean isValidBST(TreeNode node) &#123; return doValid(node, Long.MIN_VALUE, Long.MAX_VALUE);&#125;private boolean doValid(TreeNode node, long min, long max) &#123; if (node == null) &#123; return true; &#125; if (node.val &lt;= min || node.val &gt;= max) &#123; return false; &#125; return doValid(node.left, min, node.val) &amp;&amp; doValid(node.right, node.val, max);&#125; 设每个节点必须在一个范围内：$(min, max)$，不包含边界，若节点值超过这个范围，则返回 false 对于 node.left 范围肯定是 $(min, node.val)$ 对于 node.right 范围肯定是 $(node.val, max)$ 一开始不知道 min，max 则取 java 中长整数的最小、最大值 本质是前序遍历 + 剪枝 E05. 求范围和-Leetcode 938中序递归实现 1234567891011public int rangeSumBST(TreeNode node, int low, int high) &#123; if (node == null) &#123; return 0; &#125; int a = rangeSumBST(node.left, low, high); int b = 0; if (node.val &gt;= low &amp;&amp; node.val &lt;= high) &#123; b = node.val; &#125; return a + b + rangeSumBST(node.right, low, high);&#125; 中序非递归实现 123456789101112131415161718192021public int rangeSumBST(TreeNode node, int low, int high) &#123; TreeNode p = node; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); int sum = 0; while(p != null || !stack.isEmpty()) &#123; if (p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; TreeNode pop = stack.pop(); if (pop.val &gt; high) &#123; break; &#125; if (pop.val &gt;= low) &#123; sum += pop.val; &#125; p = pop.right; &#125; &#125; return sum;&#125; leedcode 执行耗时 4ms 上下限递归实现 1234567891011121314public int rangeSumBST(TreeNode node, int low, int high) &#123; if (node == null) &#123; return 0; &#125; if (node.val &lt; low) &#123; return rangeSumBST(node.right, low, high); &#125; if (node.val &gt; high) &#123; return rangeSumBST(node.left, low, high); &#125; return node.val + rangeSumBST(node.left, low, high) + rangeSumBST(node.right, low, high);&#125; leetcode 执行耗时 0 ms node.val &lt; low 只需考虑它右子树的累加结果 node.val &gt; high 只需考虑它左子树的累加结果 node.val 在范围内，需要把当前节点的值加上其左右子树的累加结果 E06. 根据前序遍历结果构造二叉搜索树-Leetcode 1008直接插入 注意：根据前序遍历的结果，可以唯一地构造出一个二叉搜索树 12345678910111213141516171819public TreeNode bstFromPreorder(int[] preorder) &#123; TreeNode root = insert(null, preorder[0]); for (int i = 1; i &lt; preorder.length; i++) &#123; insert(root, preorder[i]); &#125; return root;&#125;private TreeNode insert(TreeNode node, int val) &#123; if (node == null) &#123; return new TreeNode(val); &#125; if(val &lt; node.val) &#123; node.left = insert(node.left, val); &#125; else if(node.val &lt; val)&#123; node.right = insert(node.right, val); &#125; return node;&#125; 上限法 1234567891011121314151617181920public TreeNode bstFromPreorder(int[] preorder) &#123; return insert(preorder, Integer.MAX_VALUE);&#125;int i = 0;private TreeNode insert(int[] preorder, int max) &#123; if (i == preorder.length) &#123; return null; &#125; int val = preorder[i]; System.out.println(val + String.format(&quot;[%d]&quot;, max)); if (val &gt; max) &#123; return null; &#125; TreeNode node = new TreeNode(val); i++; node.left = insert(preorder, node.val); node.right = insert(preorder, max); return node;&#125; 依次处理 prevorder 中每个值, 返回创建好的节点或 null 作为上个节点的孩子 如果超过上限, 返回 null 如果没超过上限, 创建节点, 并将其左右孩子设置完整后返回 i++ 需要放在设置左右孩子之前，意思是从剩下的元素中挑选左右孩子 分治法 123456789101112131415161718192021public TreeNode bstFromPreorder(int[] preorder) &#123; return partition(preorder, 0, preorder.length - 1);&#125;private TreeNode partition(int[] preorder, int start, int end) &#123; if (start &gt; end) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[start]); int index = start + 1; while (index &lt;= end) &#123; if (preorder[index] &gt; preorder[start]) &#123; break; &#125; index++; &#125; // index 就是右子树的起点 root.left = partition(preorder, start + 1, index - 1); root.right = partition(preorder, index, end); return root;&#125; 刚开始 8, 5, 1, 7, 10, 12，方法每次执行，确定本次的根节点和左右子树的分界线 第一次确定根节点为 8，左子树 5, 1, 7，右子树 10, 12 对 5, 1, 7 做递归操作，确定根节点是 5， 左子树是 1， 右子树是 7 对 1 做递归操作，确定根节点是 1，左右子树为 null 对 7 做递归操作，确定根节点是 7，左右子树为 null 对 10, 12 做递归操作，确定根节点是 10，左子树为 null，右子树为 12 对 12 做递归操作，确定根节点是 12，左右子树为 null 递归结束，返回本范围内的根节点 E07. 二叉搜索树的最近公共祖先-Leetcode 235要点：若 p，q 在 ancestor 的两侧，则 ancestor 就是它们的最近公共祖先 123456789101112public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; TreeNode ancestor = root; while (ancestor.val &gt; p.val &amp;&amp; ancestor.val &gt; q.val || ancestor.val &lt; p.val &amp;&amp; ancestor.val &lt; q.val) &#123; if (ancestor.val &gt; p.val) &#123; ancestor = ancestor.left; &#125; else &#123; ancestor = ancestor.right; &#125; &#125; return ancestor;&#125; 其它题目 题号 名称 Leetcode 236 二叉树的最近公共祖先 Leetcode 114 二叉树展开为链表 Leetcode 108 有序数组构造平衡二叉搜索树 Leetcode 1382 二叉搜索树变为平衡 3.3 AVL 树概述历史 AVL 树是一种自平衡二叉搜索树，由托尔·哈斯特罗姆在 1960 年提出并在 1962 年发表。它的名字来源于发明者的名字：Adelson-Velsky 和 Landis，他们是苏联数学家，于 1962 年发表了一篇论文，详细介绍了 AVL 树的概念和性质。 在二叉搜索树中，如果插入的元素按照特定的顺序排列，可能会导致树变得非常不平衡，从而降低搜索、插入和删除的效率。为了解决这个问题，AVL 树通过在每个节点中维护一个平衡因子来确保树的平衡。平衡因子是左子树的高度减去右子树的高度。如果平衡因子的绝对值大于等于 2，则通过旋转操作来重新平衡树。 AVL 树是用于存储有序数据的一种重要数据结构，它是二叉搜索树的一种改进和扩展。它不仅能够提高搜索、插入和删除操作的效率，而且还能够确保树的深度始终保持在 O(log n) 的水平。随着计算机技术的不断发展，AVL 树已经成为了许多高效算法和系统中必不可少的一种基础数据结构。 前面介绍过，如果一棵二叉搜索树长的不平衡，那么查询的效率会受到影响，如下图 通过旋转可以让树重新变得平衡，并且不会改变二叉搜索树的性质（即左边仍然小，右边仍然大） 如何判断失衡？ 如果一个节点的左右孩子，高度差超过 1，则此节点失衡，才需要旋转 处理高度如何得到节点高度？一种方式之前做过的一道题目：E05. 求二叉树的最大深度（高度），但由于求高度是一个非常频繁的操作，因此将高度作为节点的一个属性，将来新增或删除时及时更新，默认为 1（按力扣说法） 12345678static class AVLNode &#123; int height = 1; int key; Object value; AVLNode left; AVLNode right; // ...&#125; 求高度代码 这里加入了 height 函数方便求节点为 null 时的高度 123private int height(AVLNode node) &#123; return node == null ? 0 : node.height;&#125; 更新高度代码 将来新增、删除、旋转时，高度都可能发生变化，需要更新。下面是更新高度的代码 123private void updateHeight(AVLNode node) &#123; node.height = Integer.max(height(node.left), height(node.right)) + 1;&#125; 何时触发失衡判断？定义平衡因子（balance factor）如下$$平衡因子 &#x3D; 左子树高度 - 右子树高度$$当平衡因子 bf &#x3D; 0，1，-1 时，表示左右平衡 bf &gt; 1 时，表示左边太高 bf &lt; -1 时，表示右边太高 对应代码 123private int bf(AVLNode node) &#123; return height(node.left) - height(node.right);&#125; 当插入新节点，或删除节点时，引起高度变化时，例如 目前此树平衡，当再插入一个 4 时，节点们的高度都产生了相应的变化，8 节点失衡了 在比如说，下面这棵树一开始也是平衡的 当删除节点 8 时，节点们的高度都产生了相应的变化，6 节点失衡了 失衡的四种情况LL 失衡节点（图中 8 红色）的 bf &gt; 1，即左边更高 失衡节点的左孩子（图中 6）的 bf &gt;&#x3D; 0 即左孩子这边也是左边更高或等高 LR 失衡节点（图中 8）的 bf &gt; 1，即左边更高 失衡节点的左孩子（图中 6 红色）的 bf &lt; 0 即左孩子这边是右边更高 对称的还有两种情况 RL 失衡节点（图中 3）的 bf &lt;-1，即右边更高 失衡节点的右孩子（图中 6 红色）的 bf &gt; 0，即右孩子这边左边更高 RR 失衡节点（图中 3）的 bf &lt;-1，即右边更高 失衡节点的右孩子（图中 6 红色）的 bf &lt;&#x3D; 0，即右孩子这边右边更高或等高 实现解决失衡失衡可以通过树的旋转解决。什么是树的旋转呢？它是在不干扰元素顺序的情况下更改结构，通常用来让树的高度变得平衡。 观察下面一棵二叉搜索树，可以看到，旋转后，并未改变树的左小右大特性，但根、父、孩子节点都发生了变化 12345 4 2 / \\ 4 right / \\ 2 5 --------------------&gt; 1 4 / \\ &lt;-------------------- / \\1 3 2 left 3 5 右旋 旋转前 红色节点，旧根（失衡节点） 黄色节点，旧根的左孩子，将来作为新根，旧根是它右孩子 绿色节点，新根的右孩子，将来要换爹作为旧根的左孩子 旋转后 代码 1234567private AVLNode rightRotate(AVLNode red) &#123; AVLNode yellow = red.left; AVLNode green = yellow.right; yellow.right = red; red.left = green; return yellow;&#125; 左旋 旋转前 红色节点，旧根（失衡节点） 黄色节点，旧根的右孩子，将来作为新根，旧根是它左孩子 绿色节点，新根的左孩子，将来要换爹作为旧根的右孩子 旋转后 代码 1234567private AVLNode leftRotate(AVLNode red) &#123; AVLNode yellow = red.right; AVLNode green = yellow.left; yellow.left = red; red.right = green; return yellow;&#125; 左右旋 指先左旋左子树，再右旋根节点（失衡），这时一次旋转并不能解决失衡 左子树旋转后 根右旋前 根右旋后 代码 1234private AVLNode leftRightRotate(AVLNode root) &#123; root.left = leftRotate(root.left); return rightRotate(root);&#125; 右左旋 指先右旋右子树，再左旋根节点（失衡） 右子树右旋后 根左旋前 根左旋后 代码 1234private AVLNode rightLeftRotate(AVLNode root) &#123; root.right = rightRotate(root.right); return leftRotate(root);&#125; 判断及调整平衡代码 12345678910111213141516private AVLNode balance(AVLNode node) &#123; if (node == null) &#123; return null; &#125; int bf = bf(node); if (bf &gt; 1 &amp;&amp; bf(node.left) &gt;= 0) &#123; return rightRotate(node); &#125; else if (bf &gt; 1 &amp;&amp; bf(node.left) &lt; 0) &#123; return rightLeftRotate(node); &#125; else if (bf &lt; -1 &amp;&amp; bf(node.right) &gt; 0) &#123; return leftRightRotate(node); &#125; else if (bf &lt; -1 &amp;&amp; bf(node.right) &lt;= 0) &#123; return rightRotate(node); &#125; return node;&#125; 以上四种旋转代码里，都需要更新高度，需要更新的节点是红色、黄色，而绿色节点高度不变 新增1234567891011121314151617181920public void put(int key, Object value) &#123; root = doPut(root, key, value);&#125;private AVLNode doPut(AVLNode node, int key, Object value) &#123; if (node == null) &#123; return new AVLNode(key, value); &#125; if (key == node.key) &#123; node.value = value; return node; &#125; if (key &lt; node.key) &#123; node.left = doPut(node.left, key, value); &#125; else &#123; node.right = doPut(node.right, key, value); &#125; updateHeight(node); return balance(node);&#125; 删除123456789101112131415161718192021222324252627282930313233public void remove(int key) &#123; root = doRemove(root, key);&#125;private AVLNode doRemove(AVLNode node, int key) &#123; if (node == null) &#123; return null; &#125; if (key &lt; node.key) &#123; node.left = doRemove(node.left, key); &#125; else if (node.key &lt; key) &#123; node.right = doRemove(node.right, key); &#125; else &#123; if (node.left == null) &#123; node = node.right; &#125; else if (node.right == null) &#123; node = node.left; &#125; else &#123; AVLNode s = node.right; while (s.left != null) &#123; s = s.left; &#125; s.right = doRemove(node.right, s.key); s.left = node.left; node = s; &#125; &#125; if (node == null) &#123; return null; &#125; updateHeight(node); return balance(node);&#125; 完整代码备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class AVLTree &#123; static class AVLNode &#123; int height = 1; int key; Object value; AVLNode left; AVLNode right; public AVLNode(int key) &#123; this.key = key; &#125; public AVLNode(int key, Object value) &#123; this.key = key; this.value = value; &#125; public AVLNode(int key, Object value, AVLNode left, AVLNode right) &#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125; &#125; AVLNode root; private AVLNode leftRotate(AVLNode p) &#123; AVLNode r = p.right; AVLNode b = r.left; r.left = p; p.right = b; updateHeight(p); updateHeight(r); return r; &#125; private void updateHeight(AVLNode node) &#123; node.height = Integer.max(height(node.left), height(node.right)) + 1; &#125; private AVLNode rightRotate(AVLNode r) &#123; AVLNode a = r.left; AVLNode b = a.right; a.right = r; r.left = b; updateHeight(r); updateHeight(a); return a; &#125; private AVLNode leftRightRotate(AVLNode p) &#123; AVLNode r = p.left; p.left = leftRotate(r); return rightRotate(p); &#125; private AVLNode rightLeftRotate(AVLNode p) &#123; AVLNode r = p.right; p.right = rightRotate(r); return leftRotate(p); &#125; private int height(AVLNode node) &#123; return node == null ? 0 : node.height; &#125; public void remove(int key) &#123; root = doRemove(root, key); &#125; private AVLNode doRemove(AVLNode node, int key) &#123; if (node == null) &#123; return null; &#125; if (key &lt; node.key) &#123; node.left = doRemove(node.left, key); &#125; else if (node.key &lt; key) &#123; node.right = doRemove(node.right, key); &#125; else &#123; if (node.left == null) &#123; node = node.right; &#125; else if (node.right == null) &#123; node = node.left; &#125; else &#123; AVLNode s = node.right; while (s.left != null) &#123; s = s.left; &#125; s.right = doRemove(node.right, s.key); s.left = node.left; node = s; &#125; &#125; if (node == null) &#123; return null; &#125; updateHeight(node); return balance(node); &#125; public void put(int key, Object value) &#123; root = doPut(root, key, value); &#125; private AVLNode doPut(AVLNode node, int key, Object value) &#123; if (node == null) &#123; return new AVLNode(key, value); &#125; if (key == node.key) &#123; node.value = value; return node; &#125; if (key &lt; node.key) &#123; node.left = doPut(node.left, key, value); &#125; else &#123; node.right = doPut(node.right, key, value); &#125; updateHeight(node); return balance(node); &#125; private int bf(AVLNode node) &#123; return height(node.left) - height(node.right); &#125; private AVLNode balance(AVLNode node) &#123; if (node == null) &#123; return null; &#125; int bf = bf(node); if (bf &gt; 1 &amp;&amp; bf(node.left) &gt;= 0) &#123; return rightRotate(node); &#125; else if (bf &gt; 1 &amp;&amp; bf(node.left) &lt; 0) &#123; return rightLeftRotate(node); &#125; else if (bf &lt; -1 &amp;&amp; bf(node.right) &gt; 0) &#123; return leftRightRotate(node); &#125; else if (bf &lt; -1 &amp;&amp; bf(node.right) &lt;= 0) &#123; return rightRotate(node); &#125; return node; &#125;&#125; 小结AVL树的优点： AVL树是一种自平衡树，保证了树的高度平衡，从而保证了树的查询和插入操作的时间复杂度均为O(logn)。 相比于一般二叉搜索树，AVL树对查询效率的提升更为显著，因为其左右子树高度的差值不会超过1，避免了二叉搜索树退化为链表的情况，使得整棵树的高度更低。 AVL树的删除操作比较简单，只需要像插入一样旋转即可，在旋转过程中树的平衡性可以得到维护。 AVL树的缺点： AVL树每次插入或删除节点时需要进行旋转操作，这个操作比较耗时，因此在一些应用中不太适用。 在AVL树进行插入或删除操作时，为保持树的平衡需要不断进行旋转操作，在一些高并发环节和大数据量环境下，这可能会导致多余的写锁导致性能瓶颈。 AVL树的旋转操作相对较多，因此在一些应用中可能会造成较大的空间浪费。 3.4 红黑树概述历史 红黑树是一种自平衡二叉查找树，最早由一位名叫Rudolf Bayer的德国计算机科学家于1972年发明。然而，最初的树形结构不是现在的红黑树，而是一种称为B树的结构，它是一种多叉树，可用于在磁盘上存储大量数据。 在1980年代早期，计算机科学家Leonard Adleman和Daniel Sleator推广了红黑树，并证明了它的自平衡性和高效性。从那时起，红黑树成为了最流行的自平衡二叉查找树之一，并被广泛应用于许多领域，如编译器、操作系统、数据库等。 红黑树的名字来源于红色节点和黑色节点的交替出现，它们的颜色是用来维护树的平衡性的关键。它们的颜色具有特殊的意义，黑色节点代表普通节点，而红色节点代表一个新添加的节点，它们必须满足一些特定的规则才能维持树的平衡性。 红黑树也是一种自平衡的二叉搜索树，较之 AVL，插入和删除时旋转次数更少 红黑树特性 所有节点都有两种颜色：红:red_circle:、黑:black_circle: 所有 null 视为黑色:black_circle: 红色:red_circle:节点不能相邻 根节点是黑色:black_circle: 从根到任意一个叶子节点，路径中的黑色:black_circle:节点数一样 实现插入情况插入节点均视为红色:red_circle: case 1：插入节点为根节点，将根节点变黑:black_circle: case 2：插入节点的父亲若为黑色:black_circle:，树的红黑性质不变，无需调整 插入节点的父亲为红色:red_circle:，触发红红相邻 case 3：叔叔为红色:red_circle: 父亲变为黑色:black_circle:，为了保证黑色平衡，连带的叔叔也变为黑色:black_circle: 祖父如果是黑色不变，会造成这颗子树黑色过多，因此祖父节点变为红色:red_circle: 祖父如果变成红色，可能会接着触发红红相邻，因此对将祖父进行递归调整 case 4：叔叔为黑色:black_circle: 父亲为左孩子，插入节点也是左孩子，此时即 LL 不平衡 让父亲变黑:black_circle:，为了保证这颗子树黑色不变，将祖父变成红:red_circle:，但叔叔子树少了一个黑色 祖父右旋，补齐一个黑色给叔叔，父亲旋转上去取代祖父，由于它是黑色，不会再次触发红红相邻 父亲为左孩子，插入节点是右孩子，此时即 LR 不平衡 父亲左旋，变成 LL 情况，按 1. 来后续处理 父亲为右孩子，插入节点也是右孩子，此时即 RR 不平衡 让父亲变黑:black_circle:，为了保证这颗子树黑色不变，将祖父变成红:red_circle:，但叔叔子树少了一个黑色 祖父左旋，补齐一个黑色给叔叔，父亲旋转上去取代祖父，由于它是黑色，不会再次触发红红相邻 父亲为右孩子，插入节点是左孩子，此时即 RL 不平衡 父亲右旋，变成 RR 情况，按 3. 来后续处理 删除情况case0：如果删除节点有两个孩子 交换删除节点和后继节点的 key，value，递归删除后继节点，直到该节点没有孩子或只剩一个孩子 如果删除节点没有孩子或只剩一个孩子 case 1：删的是根节点 删完了，直接将 root &#x3D; null 用剩余节点替换了根节点的 key，value，根节点孩子 &#x3D; null，颜色保持黑色:black_circle:不变 删黑色会失衡，删红色不会失衡，但删黑色有一种简单情况 case 2：删的是黑:black_circle:，剩下的是红:red_circle:，剩下这个红节点变黑:black_circle: 删除节点和剩下节点都是黑:black_circle:，触发双黑，双黑意思是，少了一个黑 case 3：被调整节点的兄弟为红:red_circle:，此时两个侄子定为黑 :black_circle: 删除节点是左孩子，父亲左旋 删除节点是右孩子，父亲右旋 父亲和兄弟要变色，保证旋转后颜色平衡 旋转的目的是让黑侄子变为删除节点的黑兄弟，对删除节点再次递归，进入 case 4 或 case 5 case 4：被调整节点的兄弟为黑:black_circle:，两个侄子都为黑 :black_circle: 将兄弟变红:red_circle:，目的是将删除节点和兄弟那边的黑色高度同时减少 1 如果父亲是红:red_circle:，则需将父亲变为黑，避免红红，此时路径黑节点数目不变 如果父亲是黑:black_circle:，说明这条路径还是少黑，再次让父节点触发双黑 case 5：被调整节点的兄弟为黑:black_circle:，至少一个红:red_circle:侄子 如果兄弟是左孩子，左侄子是红:red_circle:，LL 不平衡 将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑:black_circle:，平衡起见，左侄子也是黑:black_circle: 原来兄弟要成为父亲，需要保留父亲颜色 如果兄弟是左孩子，右侄子是红:red_circle:，LR 不平衡 将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑:black_circle: 右侄子会取代原来父亲，因此它保留父亲颜色 兄弟已经是黑了:black_circle:，无需改变 如果兄弟是右孩子，右侄子是红:red_circle:，RR 不平衡 将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑:black_circle:，平衡起见，右侄子也是黑:black_circle: 原来兄弟要成为父亲，需要保留父亲颜色 如果兄弟是右孩子，左侄子是红:red_circle:，RL 不平衡 将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑:black_circle: 左侄子会取代原来父亲，因此它保留父亲颜色 兄弟已经是黑了:black_circle:，无需改变 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390package com.itheima.datastructure.redblacktree;import static com.itheima.datastructure.redblacktree.RedBlackTree.Color.BLACK;import static com.itheima.datastructure.redblacktree.RedBlackTree.Color.RED;/** * &lt;h3&gt;红黑树&lt;/h3&gt; */public class RedBlackTree &#123; enum Color &#123; RED, BLACK; &#125; Node root; static class Node &#123; int key; Object value; Node left; Node right; Node parent; // 父节点 Color color = RED; // 颜色 public Node(int key, Object value) &#123; this.key = key; this.value = value; &#125; public Node(int key) &#123; this.key = key; &#125; public Node(int key, Color color) &#123; this.key = key; this.color = color; &#125; public Node(int key, Color color, Node left, Node right) &#123; this.key = key; this.color = color; this.left = left; this.right = right; if (left != null) &#123; left.parent = this; &#125; if (right != null) &#123; right.parent = this; &#125; &#125; // 是否是左孩子 boolean isLeftChild() &#123; return parent != null &amp;&amp; parent.left == this; &#125; // 叔叔 Node uncle() &#123; if (parent == null || parent.parent == null) &#123; return null; &#125; if (parent.isLeftChild()) &#123; return parent.parent.right; &#125; else &#123; return parent.parent.left; &#125; &#125; // 兄弟 Node sibling() &#123; if (parent == null) &#123; return null; &#125; if (this.isLeftChild()) &#123; return parent.right; &#125; else &#123; return parent.left; &#125; &#125; &#125; // 判断红 boolean isRed(Node node) &#123; return node != null &amp;&amp; node.color == RED; &#125; // 判断黑 boolean isBlack(Node node) &#123;// return !isRed(node); return node == null || node.color == BLACK; &#125; // 右旋 1. parent 的处理 2. 旋转后新根的父子关系 private void rightRotate(Node pink) &#123; Node parent = pink.parent; Node yellow = pink.left; Node green = yellow.right; if (green != null) &#123; green.parent = pink; &#125; yellow.right = pink; yellow.parent = parent; pink.left = green; pink.parent = yellow; if (parent == null) &#123; root = yellow; &#125; else if (parent.left == pink) &#123; parent.left = yellow; &#125; else &#123; parent.right = yellow; &#125; &#125; // 左旋 private void leftRotate(Node pink) &#123; Node parent = pink.parent; Node yellow = pink.right; Node green = yellow.left; if (green != null) &#123; green.parent = pink; &#125; yellow.left = pink; yellow.parent = parent; pink.right = green; pink.parent = yellow; if (parent == null) &#123; root = yellow; &#125; else if (parent.left == pink) &#123; parent.left = yellow; &#125; else &#123; parent.right = yellow; &#125; &#125; /** * 新增或更新 * &lt;br&gt; * 正常增、遇到红红不平衡进行调整 * * @param key 键 * @param value 值 */ public void put(int key, Object value) &#123; Node p = root; Node parent = null; while (p != null) &#123; parent = p; if (key &lt; p.key) &#123; p = p.left; &#125; else if (p.key &lt; key) &#123; p = p.right; &#125; else &#123; p.value = value; // 更新 return; &#125; &#125; Node inserted = new Node(key, value); if (parent == null) &#123; root = inserted; &#125; else if (key &lt; parent.key) &#123; parent.left = inserted; inserted.parent = parent; &#125; else &#123; parent.right = inserted; inserted.parent = parent; &#125; fixRedRed(inserted); &#125; void fixRedRed(Node x) &#123; // case 1 插入节点是根节点，变黑即可 if (x == root) &#123; x.color = BLACK; return; &#125; // case 2 插入节点父亲是黑色，无需调整 if (isBlack(x.parent)) &#123; return; &#125; /* case 3 当红红相邻，叔叔为红时 需要将父亲、叔叔变黑、祖父变红，然后对祖父做递归处理 */ Node parent = x.parent; Node uncle = x.uncle(); Node grandparent = parent.parent; if (isRed(uncle)) &#123; parent.color = BLACK; uncle.color = BLACK; grandparent.color = RED; fixRedRed(grandparent); return; &#125; // case 4 当红红相邻，叔叔为黑时 if (parent.isLeftChild() &amp;&amp; x.isLeftChild()) &#123; // LL parent.color = BLACK; grandparent.color = RED; rightRotate(grandparent); &#125; else if (parent.isLeftChild()) &#123; // LR leftRotate(parent); x.color = BLACK; grandparent.color = RED; rightRotate(grandparent); &#125; else if (!x.isLeftChild()) &#123; // RR parent.color = BLACK; grandparent.color = RED; leftRotate(grandparent); &#125; else &#123; // RL rightRotate(parent); x.color = BLACK; grandparent.color = RED; leftRotate(grandparent); &#125; &#125; /** * 删除 * &lt;br&gt; * 正常删、会用到李代桃僵技巧、遇到黑黑不平衡进行调整 * * @param key 键 */ public void remove(int key) &#123; Node deleted = find(key); if (deleted == null) &#123; return; &#125; doRemove(deleted); &#125; public boolean contains(int key) &#123; return find(key) != null; &#125; // 查找删除节点 private Node find(int key) &#123; Node p = root; while (p != null) &#123; if (key &lt; p.key) &#123; p = p.left; &#125; else if (p.key &lt; key) &#123; p = p.right; &#125; else &#123; return p; &#125; &#125; return null; &#125; // 查找剩余节点 private Node findReplaced(Node deleted) &#123; if (deleted.left == null &amp;&amp; deleted.right == null) &#123; return null; &#125; if (deleted.left == null) &#123; return deleted.right; &#125; if (deleted.right == null) &#123; return deleted.left; &#125; Node s = deleted.right; while (s.left != null) &#123; s = s.left; &#125; return s; &#125; // 处理双黑 (case3、case4、case5) private void fixDoubleBlack(Node x) &#123; if (x == root) &#123; return; &#125; Node parent = x.parent; Node sibling = x.sibling(); // case 3 兄弟节点是红色 if (isRed(sibling)) &#123; if (x.isLeftChild()) &#123; leftRotate(parent); &#125; else &#123; rightRotate(parent); &#125; parent.color = RED; sibling.color = BLACK; fixDoubleBlack(x); return; &#125; if (sibling != null) &#123; // case 4 兄弟是黑色, 两个侄子也是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; sibling.color = RED; if (isRed(parent)) &#123; parent.color = BLACK; &#125; else &#123; fixDoubleBlack(parent); &#125; &#125; // case 5 兄弟是黑色, 侄子有红色 else &#123; // LL if (sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) &#123; rightRotate(parent); sibling.left.color = BLACK; sibling.color = parent.color; &#125; // LR else if (sibling.isLeftChild() &amp;&amp; isRed(sibling.right)) &#123; sibling.right.color = parent.color; leftRotate(sibling); rightRotate(parent); &#125; // RL else if (!sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) &#123; sibling.left.color = parent.color; rightRotate(sibling); leftRotate(parent); &#125; // RR else &#123; leftRotate(parent); sibling.right.color = BLACK; sibling.color = parent.color; &#125; parent.color = BLACK; &#125; &#125; else &#123; // @TODO 实际也不会出现，触发双黑后，兄弟节点不会为 null fixDoubleBlack(parent); &#125; &#125; private void doRemove(Node deleted) &#123; Node replaced = findReplaced(deleted); Node parent = deleted.parent; // 没有孩子 if (replaced == null) &#123; // case 1 删除的是根节点 if (deleted == root) &#123; root = null; &#125; else &#123; if (isBlack(deleted)) &#123; // 双黑调整 fixDoubleBlack(deleted); &#125; else &#123; // 红色叶子, 无需任何处理 &#125; if (deleted.isLeftChild()) &#123; parent.left = null; &#125; else &#123; parent.right = null; &#125; deleted.parent = null; &#125; return; &#125; // 有一个孩子 if (deleted.left == null || deleted.right == null) &#123; // case 1 删除的是根节点 if (deleted == root) &#123; root.key = replaced.key; root.value = replaced.value; root.left = root.right = null; &#125; else &#123; if (deleted.isLeftChild()) &#123; parent.left = replaced; &#125; else &#123; parent.right = replaced; &#125; replaced.parent = parent; deleted.left = deleted.right = deleted.parent = null; if (isBlack(deleted) &amp;&amp; isBlack(replaced)) &#123; // @TODO 实际不会有这种情况 因为只有一个孩子时 被删除节点是黑色 那么剩余节点只能是红色不会触发双黑 fixDoubleBlack(replaced); &#125; else &#123; // case 2 删除是黑，剩下是红 replaced.color = BLACK; &#125; &#125; return; &#125; // case 0 有两个孩子 =&gt; 有一个孩子 或 没有孩子 int t = deleted.key; deleted.key = replaced.key; replaced.key = t; Object v = deleted.value; deleted.value = replaced.value; replaced.value = v; doRemove(replaced); &#125;&#125; 以上代码中的 TODO 未作改正 小结 维度 普通二叉搜索树 AVL树 红黑树 查询 平均O(logn)，最坏O(n) O(logn) O(logn) 插入 平均O(logn)，最坏O(n) O(logn) O(logn) 删除 平均O(logn)，最坏O(n) O(logn) O(logn) 平衡性 不平衡 严格平衡 近似平衡 结构 二叉树 自平衡的二叉树 具有红黑性质的自平衡二叉树 查找效率 低 高 高 插入删除效率 低 中等 高 普通二叉搜索树插入、删除、查询的时间复杂度与树的高度相关，因此在最坏情况下，时间复杂度为O(n)，而且容易退化成链表，查找效率低。 AVL树是一种高度平衡的二叉搜索树，其左右子树的高度差不超过1。因此，它能够在logn的平均时间内完成插入、删除、查询操作，但是在维护平衡的过程中，需要频繁地进行旋转操作，导致插入删除效率较低。 红黑树是一种近似平衡的二叉搜索树，它在保持高度平衡的同时，又能够保持较高的插入删除效率。红黑树通过节点着色和旋转操作来维护平衡。红黑树在维护平衡的过程中，能够进行较少的节点旋转操作，因此插入删除效率较高，并且查询效率也较高。 综上所述，红黑树具有较高的综合性能，是一种广泛应用的数据结构。 3.5 B 树ai 问题列表 请用中文回答：B-树历史 请用中文回答：100万的数据使用 avl 树来存储，树高是多少? 请用中文回答：100万的数据，如果存储到B-树(最小度数是500)，那么树高大约是多少? 请用中文回答：B-树的特性有哪些？ 概述历史 B树（B-Tree）结构是一种高效存储和查询数据的方法，它的历史可以追溯到1970年代早期。B树的发明人Rudolf Bayer和Edward M. McCreight分别发表了一篇论文介绍了B树。这篇论文是1972年发表于《ACM Transactions on Database Systems》中的，题目为”Organization and Maintenance of Large Ordered Indexes”。 这篇论文提出了一种能够高效地维护大型有序索引的方法，这种方法的主要思想是将每个节点扩展成多个子节点，以减少查找所需的次数。B树结构非常适合应用于磁盘等大型存储器的高效操作，被广泛应用于关系数据库和文件系统中。 B树结构有很多变种和升级版，例如B+树，B*树和SB树等。这些变种和升级版本都基于B树的核心思想，通过调整B树的参数和结构，提高了B树在不同场景下的性能表现。 总的来说，B树结构是一个非常重要的数据结构，为高效存储和查询大量数据提供了可靠的方法。它的历史可以追溯到上个世纪70年代，而且在今天仍然被广泛应用于各种场景。 B 的含义 B-树的名称是由其发明者Rudolf Bayer提出的。Bayer和McCreight从未解释B代表什么，人们提出了许多可能的解释，比如Boeing、balanced、between、broad、bushy和Bayer等。但McCreight表示，越是思考B-trees中的B代表什么，就越能更好地理解B-trees 特性一棵 B-树具有以下性质 特性1：每个节点 x 具有 属性 n，表示节点 x 中 key 的个数 属性 leaf，表示节点是否是叶子节点 节点 key 可以有多个，以升序存储 特性2：每个非叶子节点中的孩子数是 n + 1、叶子节点没有孩子 特性3：最小度数t（节点的孩子数称为度）和节点中键数量的关系如下： 最小度数t 键数量范围 2 1 ~ 3 3 2 ~ 5 4 3 ~ 7 … … n (n-1) ~ (2n-1) 其中，当节点中键数量达到其最大值时，即 3、5、7 … 2n-1，需要分裂 特性4：叶子节点的深度都相同 问： B-树为什么有最小度数的限制？ 答： B树中有最小度数的限制是为了保证B树的平衡特性。 在B树中，每个节点都可以有多个子节点，这使得B树可以存储大量的键值，但也带来了一些问题。如果节点的子节点数量太少，那么就可能导致B树的高度过高，从而降低了B树的效率。此外，如果节点的子节点数量太多，那么就可能导致节点的搜索、插入和删除操作变得复杂和低效。 最小度数的限制通过限制节点的子节点数量，来平衡这些问题。在B树中，每个节点的子节点数量都必须在一定的范围内，即t到2t之间（其中t为最小度数） B-树与 2-3 树、2-3-4 树的关系可以这样总结它们之间的关系： 2-3树是最小度数为2的B树，其中每个节点可以包含2个或3个子节点。 2-3-4树是最小度数为2的B树的一种特殊情况，其中每个节点可以包含2个、3个或4个子节点。 B树是一种更加一般化的平衡树，可以适应不同的应用场景，其节点可以包含任意数量的键值，节点的度数取决于最小度数t的设定。 实现定义节点123456789101112131415161718static class Node &#123; boolean leaf = true; int keyNumber; int t; int[] keys; Node[] children; public Node(int t) &#123; this.t = t; this.keys = new int[2 * t - 1]; this.children = new Node[2 * t]; &#125; @Override public String toString() &#123; return Arrays.toString(Arrays.copyOfRange(keys, 0, keyNumber)); &#125;&#125; leaf 表示是否为叶子节点 keyNumber 为 keys 中有效 key 数目 t 为最小度数，它决定了节点中key 的最小、最大数目，分别是 t-1 和 2t-1 keys 存储此节点的 key children 存储此节点的 child toString 只是为了方便调试和测试，非必须 实际 keys 应当改为 entries 以便同时保存 key 和 value，刚开始简化实现 多路查找为上面节点类添加 get 方法 12345678910111213Node get(int key) &#123; int i = 0; while (i &lt; keyNumber &amp;&amp; keys[i] &lt; key) &#123; i++; &#125; if (i &lt; keyNumber &amp;&amp; keys[i] == key) &#123; return this; &#125; if (leaf) &#123; return null; &#125; return children[i].get(key);&#125; 插入 key 和 child为上面节点类添加 insertKey 和 insertChild 方法 12345678910void insertKey(int key, int index) &#123; System.arraycopy(keys, index, keys, index + 1, keyNumber - index); keys[index] = key; keyNumber++;&#125;void insertChild(Node child, int index) &#123; System.arraycopy(children, index, children, index + 1, keyNumber - index); children[index] = child;&#125; 作用是向 keys 数组或 children 数组指定 index 处插入新数据，注意 由于使用了静态数组，并且不会在新增或删除时改变它的大小，因此需要额外的 keyNumber 来指定数组内有效 key 的数目 插入时 keyNumber++ 删除时减少 keyNumber 的值即可 children 不会单独维护数目，它比 keys 多一个 如果这两个方法同时调用，注意它们的先后顺序，insertChild 后调用，因为它计算复制元素个数时用到了 keyNumber 定义树1234567891011121314151617public class BTree &#123; final int t; final int MIN_KEY_NUMBER; final int MAX_KEY_NUMBER; Node root; public BTree() &#123; this(2); &#125; public BTree(int t) &#123; this.t = t; MIN_KEY_NUMBER = t - 1; MAX_KEY_NUMBER = 2 * t - 1; root = new Node(t); &#125;&#125; 插入123456789101112131415161718192021public void put(int key) &#123; doPut(null, 0, root, key);&#125;private void doPut(Node parent, int index, Node node, int key) &#123; int i = 0; while (i &lt; node.keyNumber &amp;&amp; node.keys[i] &lt; key) &#123; i++; &#125; if (i &lt; node.keyNumber &amp;&amp; node.keys[i] == key) &#123; return; &#125; if (node.leaf) &#123; node.insertKey(key, i); &#125; else &#123; doPut(node, i, node.children[i], key); &#125; if (isFull(node)) &#123; split(parent, index, node); &#125;&#125; 首先查找本节点中的插入位置 i，如果没有空位（key 被找到），应该走更新的逻辑，目前什么没做 接下来分两种情况 如果节点是叶子节点，可以直接插入了 如果节点是非叶子节点，需要继续在 children[i] 处继续递归插入 无论哪种情况，插入完成后都可能超过节点 keys 数目限制，此时应当执行节点分裂 参数中的 parent 和 index 都是给分裂方法用的，代表当前节点父节点，和分裂节点是第几个孩子 判断依据为： 123boolean isFull(Node node) &#123; return node.keyNumber == MAX_KEY_NUMBER;&#125; 分裂123456789101112131415161718192021void split(Node parent, int index , Node left) &#123; if (parent == null) &#123; Node newRoot = new Node(this.t); newRoot.leaf = false; newRoot.insertChild(root, 0); root = newRoot; parent = newRoot; &#125; Node right = new Node(this.t); right.leaf = left.leaf; right.keyNumber = t - 1; System.arraycopy(left.keys, t, right.keys, 0, t - 1); if (!left.leaf) &#123; System.arraycopy(left.children, t, right.children, 0, t); &#125; left.keyNumber = t - 1; int mid = left.keys[t - 1]; parent.insertKey(mid, index); parent.insertChild(right, index + 1);&#125; 分两种情况： 如果 parent &#x3D;&#x3D; null 表示要分裂的是根节点，此时需要创建新根，原来的根节点作为新根的 0 孩子 否则 创建 right 节点（分裂后大于当前 left 节点的），把 t 以后的 key 和 child 都拷贝过去 t-1 处的 key 插入到 parent 的 index 处，index 指 left 作为孩子时的索引 right 节点作为 parent 的孩子插入到 index + 1 处 删除case 1：当前节点是叶子节点，没找到 case 2：当前节点是叶子节点，找到了 case 3：当前节点是非叶子节点，没找到 case 4：当前节点是非叶子节点，找到了 case 5：删除后 key 数目 &lt; 下限（不平衡） case 6：根节点 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286package com.itheima.algorithm.btree;import java.util.Arrays;/** * &lt;h3&gt;B-树&lt;/h3&gt; */@SuppressWarnings(&quot;all&quot;)public class BTree &#123; static class Node &#123; int[] keys; // 关键字 Node[] children; // 孩子 int keyNumber; // 有效关键字数目 boolean leaf = true; // 是否是叶子节点 int t; // 最小度数 (最小孩子数) public Node(int t) &#123; // t&gt;=2 this.t = t; this.children = new Node[2 * t]; this.keys = new int[2 * t - 1]; &#125; public Node(int[] keys) &#123; this.keys = keys; &#125; @Override public String toString() &#123; return Arrays.toString(Arrays.copyOfRange(keys, 0, keyNumber)); &#125; // 多路查找 Node get(int key) &#123; int i = 0; while (i &lt; keyNumber) &#123; if (keys[i] == key) &#123; return this; &#125; if (keys[i] &gt; key) &#123; break; &#125; i++; &#125; // 执行到此时 keys[i]&gt;key 或 i==keyNumber if (leaf) &#123; return null; &#125; // 非叶子情况 return children[i].get(key); &#125; // 向 keys 指定索引处插入 key void insertKey(int key, int index) &#123; System.arraycopy(keys, index, keys, index + 1, keyNumber - index); keys[index] = key; keyNumber++; &#125; // 向 children 指定索引处插入 child void insertChild(Node child, int index) &#123; System.arraycopy(children, index, children, index + 1, keyNumber - index); children[index] = child; &#125; int removeKey(int index) &#123; int t = keys[index]; System.arraycopy(keys, index + 1, keys, index, --keyNumber - index); return t; &#125; int removeLeftmostKey() &#123; return removeKey(0); &#125; int removeRightmostKey() &#123; return removeKey(keyNumber - 1); &#125; Node removeChild(int index) &#123; Node t = children[index]; System.arraycopy(children, index + 1, children, index, keyNumber - index); children[keyNumber] = null; return t; &#125; Node removeLeftmostChild() &#123; return removeChild(0); &#125; Node removeRightmostChild() &#123; return removeChild(keyNumber); &#125; void moveToLeft(Node left) &#123; int start = left.keyNumber; if (!leaf) &#123; for (int i = 0; i &lt;= keyNumber; i++) &#123; left.children[start + i] = children[i]; &#125; &#125; for (int i = 0; i &lt; keyNumber; i++) &#123; left.keys[left.keyNumber++] = keys[i]; &#125; &#125; Node leftSibling(int index) &#123; return index &gt; 0 ? children[index - 1] : null; &#125; Node rightSibling(int index) &#123; return index == keyNumber ? null : children[index + 1]; &#125; &#125; Node root; int t; // 树中节点最小度数 final int MIN_KEY_NUMBER; // 最小key数目 final int MAX_KEY_NUMBER; // 最大key数目 public BTree() &#123; this(2); &#125; public BTree(int t) &#123; this.t = t; root = new Node(t); MAX_KEY_NUMBER = 2 * t - 1; MIN_KEY_NUMBER = t - 1; &#125; // 1. 是否存在 public boolean contains(int key) &#123; return root.get(key) != null; &#125; // 2. 新增 public void put(int key) &#123; doPut(root, key, null, 0); &#125; private void doPut(Node node, int key, Node parent, int index) &#123; int i = 0; while (i &lt; node.keyNumber) &#123; if (node.keys[i] == key) &#123; return; // 更新 &#125; if (node.keys[i] &gt; key) &#123; break; // 找到了插入位置，即为此时的 i &#125; i++; &#125; if (node.leaf) &#123; node.insertKey(key, i); &#125; else &#123; doPut(node.children[i], key, node, i); &#125; if (node.keyNumber == MAX_KEY_NUMBER) &#123; split(node, parent, index); &#125; &#125; /** * &lt;h3&gt;分裂方法&lt;/h3&gt; * * @param left 要分裂的节点 * @param parent 分裂节点的父节点 * @param index 分裂节点是第几个孩子 */ void split(Node left, Node parent, int index) &#123; // 分裂的是根节点 if (parent == null) &#123; Node newRoot = new Node(t); newRoot.leaf = false; newRoot.insertChild(left, 0); this.root = newRoot; parent = newRoot; &#125; // 1. 创建 right 节点，把 left 中 t 之后的 key 和 child 移动过去 Node right = new Node(t); right.leaf = left.leaf; System.arraycopy(left.keys, t, right.keys, 0, t - 1); // 分裂节点是非叶子的情况 if (!left.leaf) &#123; System.arraycopy(left.children, t, right.children, 0, t); for (int i = t; i &lt;= left.keyNumber; i++) &#123; left.children[i] = null; &#125; &#125; right.keyNumber = t - 1; left.keyNumber = t - 1; // 2. 中间的 key （t-1 处）插入到父节点 int mid = left.keys[t - 1]; parent.insertKey(mid, index); // 3. right 节点作为父节点的孩子 parent.insertChild(right, index + 1); &#125; // 3. 删除 public void remove(int key) &#123; doRemove(root, key, null, 0); &#125; private void doRemove(Node node, int key, Node parent, int index) &#123; int i = 0; while (i &lt; node.keyNumber) &#123; if (node.keys[i] &gt;= key) &#123; break; &#125; i++; &#125; if (node.leaf) &#123; if (notFound(node, key, i)) &#123; // case 1 return; &#125; node.removeKey(i); // case 2 &#125; else &#123; if (notFound(node, key, i)) &#123; // case 3 doRemove(node.children[i], key, node, i); &#125; else &#123; // case 4 Node s = node.children[i + 1]; while (!s.leaf) &#123; s = s.children[0]; &#125; int k = s.keys[0]; node.keys[i] = k; doRemove(node.children[i + 1], k, node, i + 1); &#125; &#125; if (node.keyNumber &lt; MIN_KEY_NUMBER) &#123; // case 5 balance(node, parent, index); &#125; &#125; private boolean notFound(Node node, int key, int i) &#123; return i &gt;= node.keyNumber || (i &lt; node.keyNumber &amp;&amp; node.keys[i] != key); &#125; private void balance(Node node, Node parent, int i) &#123; if (node == root) &#123; if (root.keyNumber == 0 &amp;&amp; root.children[0] != null) &#123; root = root.children[0]; &#125; return; &#125; Node leftSibling = parent.leftSibling(i); Node rightSibling = parent.rightSibling(i); if (leftSibling != null &amp;&amp; leftSibling.keyNumber &gt; MIN_KEY_NUMBER) &#123; rightRotate(node, leftSibling, parent, i); return; &#125; if (rightSibling != null &amp;&amp; rightSibling.keyNumber &gt; MIN_KEY_NUMBER) &#123; leftRotate(node, rightSibling, parent, i); return; &#125; if (leftSibling != null) &#123; mergeToLeft(leftSibling, parent, i - 1); &#125; else &#123; mergeToLeft(node, parent, i); &#125; &#125; private void mergeToLeft(Node left, Node parent, int i) &#123; Node right = parent.removeChild(i + 1); left.insertKey(parent.removeKey(i), left.keyNumber); right.moveToLeft(left); &#125; private void rightRotate(Node node, Node leftSibling, Node parent, int i) &#123; node.insertKey(parent.keys[i - 1], 0); if (!leftSibling.leaf) &#123; node.insertChild(leftSibling.removeRightmostChild(), 0); &#125; parent.keys[i - 1] = leftSibling.removeRightmostKey(); &#125; private void leftRotate(Node node, Node rightSibling, Node parent, int i) &#123; node.insertKey(parent.keys[i], node.keyNumber); if (!rightSibling.leaf) &#123; node.insertChild(rightSibling.removeLeftmostChild(), node.keyNumber + 1); &#125; parent.keys[i] = rightSibling.removeLeftmostKey(); &#125;&#125; 3.6 哈希表第一版未考虑 hash 码的生成，假定该 hash 码由我们提供 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148public class HashTable &#123; // 节点类 static class Entry &#123; int hash; // 哈希码 Object key; // 键 Object value; // 值 Entry next; public Entry(int hash, Object key, Object value) &#123; this.hash = hash; this.key = key; this.value = value; &#125; &#125; Entry[] table = new Entry[16]; int size = 0; // 元素个数 float loadFactor = 0.75f; // 12 阈值 int threshold = (int) (loadFactor * table.length); /* 求模运算替换为位运算 - 前提：数组长度是 2 的 n 次方 - hash % 数组长度 等价于 hash &amp; (数组长度-1) */ // 根据 hash 码获取 value Object get(int hash, Object key) &#123; int idx = hash &amp; (table.length - 1); if (table[idx] == null) &#123; return null; &#125; Entry p = table[idx]; while (p != null) &#123; if (p.key.equals(key)) &#123; return p.value; &#125; p = p.next; &#125; return null; &#125; // 向 hash 表存入新 key value，如果 key 重复，则更新 value void put(int hash, Object key, Object value) &#123; int idx = hash &amp; (table.length - 1); if (table[idx] == null) &#123; // 1. idx 处有空位, 直接新增 table[idx] = new Entry(hash, key, value); &#125; else &#123; // 2. idx 处无空位, 沿链表查找 有重复key更新，否则新增 Entry p = table[idx]; while (true) &#123; if (p.key.equals(key)) &#123; p.value = value; // 更新 return; &#125; if (p.next == null) &#123; break; &#125; p = p.next; &#125; p.next = new Entry(hash, key, value); // 新增 &#125; size++; if (size &gt; threshold) &#123; resize(); &#125; &#125; private void resize() &#123; Entry[] newTable = new Entry[table.length &lt;&lt; 1]; for (int i = 0; i &lt; table.length; i++) &#123; Entry p = table[i]; // 拿到每个链表头 if (p != null) &#123; /* 拆分链表，移动到新数组，拆分规律 * 一个链表最多拆成两个 * hash &amp; table.length == 0 的一组 * hash &amp; table.length != 0 的一组 p 0-&gt;8-&gt;16-&gt;24-&gt;32-&gt;40-&gt;48-&gt;null a 0-&gt;16-&gt;32-&gt;48-&gt;null b 8-&gt;24-&gt;40-&gt;null */ Entry a = null; Entry b = null; Entry aHead = null; Entry bHead = null; while (p != null) &#123; if ((p.hash &amp; table.length) == 0) &#123; if (a != null) &#123; a.next = p; &#125; else &#123; aHead = p; &#125; a = p; // 分配到a &#125; else &#123; if (b != null) &#123; b.next = p; &#125; else &#123; bHead = p; &#125; b = p; // 分配到b &#125; p = p.next; &#125; // 规律： a 链表保持索引位置不变，b 链表索引位置+table.length if (a != null) &#123; a.next = null; newTable[i] = aHead; &#125; if (b != null) &#123; b.next = null; newTable[i + table.length] = bHead; &#125; &#125; &#125; table = newTable; threshold = (int) (loadFactor * table.length); &#125; // 根据 hash 码删除，返回删除的 value Object remove(int hash, Object key) &#123; int idx = hash &amp; (table.length - 1); if (table[idx] == null) &#123; return null; &#125; Entry p = table[idx]; Entry prev = null; while (p != null) &#123; if (p.key.equals(key)) &#123; // 找到了, 删除 if (prev == null) &#123; // 链表头 table[idx] = p.next; &#125; else &#123; // 非链表头 prev.next = p.next; &#125; size--; return p.value; &#125; prev = p; p = p.next; &#125; return null; &#125;&#125; 生成 hashCode hash 算法是将任意对象，分配一个编号的过程，其中编号是一个有限范围内的数字（如 int 范围内） Object.hashCode Object 的 hashCode 方法默认是生成随机数作为 hash 值（会缓存在对象头当中） 缺点是包含相同值的不同对象，他们的 hashCode 不一样，不能够用 hash 值来反映对象的值特征，因此诸多子类都会重写 hashCode 方法 String.hashCode 123456789101112131415161718192021public static void main(String[] args) &#123; String s1 = &quot;bac&quot;; String s2 = new String(&quot;abc&quot;); System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); // 原则：值相同的字符串生成相同的 hash 码, 尽量让值不同的字符串生成不同的 hash 码 /* 对于 abc a * 100 + b * 10 + c 对于 bac b * 100 + a * 10 + c */ int hash = 0; for (int i = 0; i &lt; s1.length(); i++) &#123; char c = s1.charAt(i); System.out.println((int) c); // (a*10 + b)*10 + c ==&gt; a*100 + b*10 + c 2^5 hash = (hash &lt;&lt; 5) - hash + c; &#125; System.out.println(hash);&#125; 经验表明如果每次乘的是较大质数，可以有更好地降低 hash 冲突，因此改【乘 10】为【乘 31】 【乘 31】可以等价为【乘 32 - hash】，进一步可以转为更高效地【左移5位 - hash】 检查 hash 表的分散性 123456789101112131415public void print() &#123; int[] sum = new int[table.length]; for (int i = 0; i &lt; table.length; i++) &#123; Entry p = table[i]; while (p != null) &#123; sum[i]++; p = p.next; &#125; &#125; System.out.println(Arrays.toString(sum)); Map&lt;Integer, Long&gt; result = Arrays.stream(sum).boxed() .collect(Collectors.groupingBy(s -&gt; s, Collectors.counting())); System.out.println(result);&#125; 测试 1234567891011121314151617public static void main(String[] args) throws IOException &#123; // 测试 Object.hashCode HashTable table = new HashTable(); for (int i = 0; i &lt; 200000; i++) &#123; Object obj = new Object(); table.put(obj, obj); &#125; table.print(); // 测试 String.hashCode table = new HashTable(); List&lt;String&gt; strings = Files.readAllLines(Path.of(&quot;words&quot;)); for (String string : strings) &#123; table.put(string, string); &#125; table.print();&#125; MurmurHash 思考 我们的代码里使用了尾插法，如果改成头插法呢？ JDK 的 HashMap 中采用了将对象 hashCode 高低位相互异或的方式减少冲突，怎么理解 我们的 HashTable 中表格容量是 2 的 n 次方，很多优化都是基于这个前提，能否不用 2 的 n 次方作为表格容量？ JDK 的 HashMap 在链表长度过长会转换成红黑树，对此你怎么看 习题E01. 两数之和-Leetcode 112345678910111213public class E01Leetcode1 &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int k = target - nums[i]; if (map.containsKey(k)) &#123; return new int[]&#123;i, map.get(k)&#125;; &#125; map.put(nums[i], i); &#125; return null; // 不会执行 &#125;&#125; 注意：题目明确说明只会存在一个有效答案，因此不会执行到最后的 return null E02. 无重复字符的最长字串-Leetcode 31234567891011121314151617public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int begin = 0; int maxLength = 0; for (int end = 0; end &lt; s.length(); end++) &#123; char ch = s.charAt(end); if (map.containsKey(ch)) &#123; // 重复时调整 begin begin = Math.max(begin, map.get(ch) + 1); map.put(ch, end); &#125; else &#123; // 不重复 map.put(ch, end); &#125; System.out.println(s.substring(begin, end + 1)); maxLength = Math.max(maxLength, end - begin + 1); &#125; return maxLength;&#125; begin 调整时的解释，遇到重复的 begin 应该向右调整，例如 1abca 遇到重复的 a，这时 begin 应该调整到上个重复字符 a 索引加 1 处，即 map.get(‘a’) + 1 &#x3D; 1， 但还有一种情况需要考虑，就是连续遇到两次重复，例如 1abba 遇到重复的 b，这时 begin 应该调整到上个重复字符 b 索引加 1 处，即 map.get(‘b’) + 1 &#x3D; 2 不过接下来，又遇到了重复的 a，此时若还执行 map.get(‘a’) + 1 &#x3D; 1，则 begin 相当于向左退了，不对 应该是 Math.max(2, map.get(‘a’) + 1)，即 begin 应该是两个重复字符索引中更靠右者 题目中说明 s 由英文字母、数字、符号和空格组成，因此它的范围是有限的（在 0 ~127 之内），可以用数组来替代 HashMap 优化，如下 123456789101112131415161718public int lengthOfLongestSubstring(String s) &#123; int[] map = new int[128]; Arrays.fill(map, -1); int begin = 0; int maxLength = 0; for (int end = 0; end &lt; s.length(); end++) &#123; char ch = s.charAt(end); if (map[ch] != -1) &#123; // 重复时调整 begin begin = Math.max(begin, map[ch] + 1); map[ch] = end; &#125; else &#123; // 不重复 map[ch] = end; &#125; System.out.println(s.substring(begin, end + 1)); maxLength = Math.max(maxLength, end - begin + 1); &#125; return maxLength;&#125; E03. 字母异位词分组-Leetcode 49解法1 1234567891011public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String str : strs) &#123; char[] chars = str.toCharArray(); Arrays.sort(chars); String key = new String(chars); List&lt;String&gt; strings = map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()); strings.add(str); &#125; return new ArrayList&lt;&gt;(map.values());&#125; 解法2 12345678910111213141516171819202122232425262728293031323334static class ArrayKey &#123; int[] key = new int[26]; public ArrayKey(String str) &#123; for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); key[ch - &#x27;a&#x27;]++; &#125; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; ArrayKey arrayKey = (ArrayKey) o; return Arrays.equals(key, arrayKey.key); &#125; @Override public int hashCode() &#123; return Arrays.hashCode(key); &#125;&#125;public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; HashMap&lt;ArrayKey, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String str : strs) &#123; List&lt;String&gt; strings = map.computeIfAbsent(new ArrayKey(str), k -&gt; new ArrayList&lt;&gt;()); strings.add(str); &#125; return new ArrayList&lt;&gt;(map.values());&#125; E04. 判断有没有重复元素-Leetcode 217123456789public boolean containsDuplicate(int[] nums) &#123; // 5ms HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int key : nums) &#123; if (!set.add(key)) &#123; return true; &#125; &#125; return false;&#125; E05. 找出出现一次的数字-Leetcode 136解法1：用 HashSet 123456789public int singleNumber(int[] nums) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) &#123; if (!set.add(num)) &#123; set.remove(num); &#125; &#125; return set.toArray(new Integer[0])[0];&#125; 解法2：用 xor 1234567public int singleNumber(int[] nums) &#123; int num = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; num = num ^ nums[i]; &#125; return num;&#125; E06. 判断字母异位词-Leetcode 242123456789101112public boolean isAnagram(String s, String t) &#123; // 1ms return Arrays.equals(getKey(s), getKey(t));&#125;private static int[] getKey(String s) &#123; int[] array = new int[26]; char[] chars = s.toCharArray(); for (char ch : chars) &#123; array[ch - 97]++; &#125; return array;&#125; 其中用 s.toCharArray() 性能明显高于用 s.charAt() 一个个获取字符 E07. 第一个不重复字符-Leetcode 3871234567891011121314public int firstUniqChar(String s) &#123; int[] array = new int[26]; char[] chars = s.toCharArray(); for (char ch : chars) &#123; array[ch-97]++; &#125; for (int i = 0; i &lt; chars.length; i++) &#123; char ch = chars[i]; if (array[ch - 97] == 1) &#123; return i; &#125; &#125; return -1;&#125; E08. 出现次数最多的单词-Leetcode 819简洁解法 14 ms 12345678910111213public String mostCommonWord(String paragraph, String[] banned) &#123; Set&lt;String&gt; banSet = Set.of(banned); HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\tString[] split = paragraph.toLowerCase().split(&quot;[^A-Za-z]+&quot;); for (String key : split) &#123; if(banSet.contains(key)) &#123; continue; &#125; map.compute(key, (k, v) -&gt; v == null ? 1 : v + 1); &#125;\tOptional&lt;Map.Entry&lt;String, Integer&gt;&gt; optional = map.entrySet().stream().max(Map.Entry.comparingByValue()); return optional.map(Map.Entry::getKey).orElse(null);&#125; 后两行避免 lambda，12 ms 123456789101112131415161718192021public String mostCommonWord(String paragraph, String[] banned) &#123; Set&lt;String&gt; banSet = Set.of(banned); String[] split = paragraph.toLowerCase().split(&quot;[^A-Za-z]+&quot;); HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (String key : split) &#123; if(banSet.contains(key)) &#123; continue; &#125; map.compute(key, (k, v) -&gt; v == null ? 1 : v + 1); &#125; Integer max = 0; String maxKey = null; for (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) &#123; Integer value = e.getValue(); if (value &gt; max) &#123; max = value; maxKey = e.getKey(); &#125; &#125; return maxKey;&#125; 避免正则匹配 5ms 1234567891011121314151617181920212223242526272829303132333435public String mostCommonWord(String paragraph, String[] banned) &#123; Set&lt;String&gt; banSet = Set.of(banned); HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); char[] chars = paragraph.toLowerCase().toCharArray(); StringBuilder sb = new StringBuilder(); for (char ch : chars) &#123; if (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;) &#123; sb.append(ch); &#125; else &#123; put(banSet, map, sb); sb = new StringBuilder(); &#125; &#125; put(banSet, map, sb); Integer max = 0; String maxKey = null; for (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) &#123; Integer value = e.getValue(); if (value &gt; max) &#123; max = value; maxKey = e.getKey(); &#125; &#125; return maxKey;&#125;private static void put(Set&lt;String&gt; banSet, HashMap&lt;String, Integer&gt; map, StringBuilder sb) &#123; if (sb.length() &gt; 0) &#123; String key = sb.toString(); if(!banSet.contains(key)) &#123; map.compute(key, (k, v) -&gt; v == null ? 1 : v + 1); &#125; &#125;&#125; sb 避免每次新建 4ms 1sb.setLength(0); E09. 根据前序与中序遍历结果构造二叉树-Leetcode105 Improved1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class E09Leetcode105Improved &#123; // 用 hashmap 改善查找性能，其中 key 是 inOrder 值， value 是 inOrder 索引 HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preOrder, int[] inOrder) &#123; for (int i = 0; i &lt; inOrder.length; i++) &#123; map.put(inOrder[i], i); &#125; return helper(preOrder, 0, 0, inOrder.length - 1); &#125; // preBegin 决定了每次在 preOrder 中找到根元素 // inBegin 和 inEnd 可以用来获取区间内元素个数，结束递归等 private TreeNode helper(int[] preOrder, int preBegin, int inBegin, int inEnd) &#123; if (inBegin &gt; inEnd) &#123; return null; &#125; int rootValue = preOrder[preBegin]; TreeNode root = new TreeNode(rootValue); int i = map.get(rootValue); int leftSize = i - inBegin; System.out.println(&quot;元素：&quot; + rootValue + &quot; left[&quot; + (preBegin + 1) + &quot;] inOrder 索引范围[&quot; + inBegin + &quot;~&quot; + (i - 1) + &quot;]&quot;); System.out.println(&quot;元素：&quot; + rootValue + &quot; right[&quot; + (preBegin + 1 + leftSize) + &quot;] inOrder 索引范围[&quot; + (i + 1) + &quot;~&quot; + inEnd + &quot;]&quot;); root.left = helper(preOrder, preBegin + 1, inBegin, i - 1); root.right = helper(preOrder, preBegin + 1 + leftSize, i + 1, inEnd); return root; &#125; public static void main(String[] args) &#123; int[] preOrder = &#123;1, 2, 4, 3, 6, 7&#125;; int[] inOrder = &#123;4, 2, 1, 6, 3, 7&#125;; /* 例如： 根据根节点[1] 到中序遍历数组中一分为2，首次递归 [1] 2 4 3 6 7 前 0 1 2 3 4 5 前索引 4 2 [1] 6 3 7 中 0 1 2 3 4 5 中索引 确定 preOrder 中 left 和 right 的递归起始索引，当然也要确定 inOrder 对应的两个索引位置 left right 1 [2] 4 [3] 6 7 前 0 1 2 3 4 5 前索引 left inOrder 索引范围： 0~1 right inOrder 索引范围： 3~5 */ TreeNode root = new E09Leetcode105Improved().buildTree(preOrder, inOrder); System.out.println(root); &#125;&#125; E10. 根据中序与后序遍历结果构造二叉树-Leetcode106 Improved12345678910111213141516171819202122232425262728293031323334353637public class E10Leetcode106Improved &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] inOrder, int[] postOrder) &#123; for (int i = 0; i &lt; inOrder.length; i++) &#123; map.put(inOrder[i], i); &#125; return helper(postOrder, postOrder.length - 1, 0, inOrder.length - 1); &#125; /* inOrder = &#123;4,2,1,6,3,7&#125; postOrder = &#123;4,2,6,7,3,1&#125; */ private TreeNode helper(int[] postOrder, int postEnd, int inBegin, int inEnd) &#123; if (inBegin &gt; inEnd) &#123; return null; &#125; int rootValue = postOrder[postEnd]; TreeNode root = new TreeNode(rootValue); Integer i = map.get(rootValue);// int leftSize = i - inBegin; int rightSize = inEnd - i; System.out.println(&quot;元素：&quot; + rootValue + &quot; left[&quot; + (postEnd - 1 - rightSize) + &quot;] inOrder 索引范围[&quot; + inBegin + &quot;~&quot; + (i - 1) + &quot;]&quot;); System.out.println(&quot;元素：&quot; + rootValue + &quot; right[&quot; + (postEnd - 1) + &quot;] inOrder 索引范围[&quot; + (i + 1) + &quot;~&quot; + inEnd + &quot;]&quot;); root.left = helper(postOrder, postEnd - 1 - rightSize, inBegin, i - 1); root.right = helper(postOrder, postEnd - 1, i + 1, inEnd); return root; &#125; public static void main(String[] args) &#123; int[] postOrder = &#123;4, 2, 6, 7, 3, 1&#125;; int[] inOrder = &#123;4, 2, 1, 6, 3, 7&#125;; TreeNode root = new E10Leetcode106Improved().buildTree(inOrder, postOrder); System.out.println(root); &#125;&#125; 3.7 排序算法概述比较排序算法 算法 最好 最坏 平均 空间 稳定 思想 注意事项 冒泡 O(n) O($n^2$) O($n^2$) O(1) Y 比较 最好情况需要额外判断 选择 O($n^2$) O($n^2$) O($n^2$) O(1) N 比较 交换次数一般少于冒泡 堆 O($nlogn$) O($nlogn$) O($nlogn$) O(1) N 选择 堆排序的辅助性较强，理解前先理解堆的数据结构 插入 O(n) O($n^2$) O($n^2$) O(1) Y 比较 插入排序对于近乎有序的数据处理速度比较快，复杂度有所下降，可以提前结束 希尔 O(nlogn) O($n^2$) O($nlogn$) O(1) N 插入 gap序列的构造有多种方式，不同方式处理的数据复杂度可能不同 归并 O($nlogn$) O($nlogn$) O($nlogn$) O(n) Y 分治 需要额外的O(n)的存储空间 快速 O($nlogn$) O($n^2$) O($nlogn$) O(logn) N 分治 快排可能存在最坏情况，需要把枢轴值选取得尽量随机化来缓解最坏情况下的时间复杂度 非比较排序算法 非比较排序算法 时间复杂度 空间复杂度 稳定性 计数排序 O(n+k) O(n+k) 稳定 桶排序 O(n+k) O(n+k) 稳定 基数排序 O(d*(n+k)) O(n+k) 稳定 其中 n 是数组长度 k 是桶长度 d 是基数位数 稳定 vs 不稳定 Java 中的排序Arrays.sort JDK 7~13 中的排序实现 排序目标 条件 采用算法 int[] long[] float[] double[] size &lt; 47 混合插入排序 (pair) size &lt; 286 双基准点快排 有序度低 双基准点快排 有序度高 归并排序 byte[] size &lt;&#x3D; 29 插入排序 size &gt; 29 计数排序 char[] short[] size &lt; 47 插入排序 size &lt; 286 双基准点快排 有序度低 双基准点快排 有序度高 归并排序 size &gt; 3200 计数排序 Object[] -Djava.util.Arrays.useLegacyMergeSort&#x3D;true 传统归并排序 TimSort JDK 14~20 中的排序实现 排序目标 条件 采用算法 int[] long[] float[] double[] size &lt; 44 并位于最左侧 插入排序 size &lt; 65 并不是最左侧 混合插入排序 (pin) 有序度低 双基准点快排 递归次数超过 384 堆排序 对于整个数组或非最左侧 size &gt; 4096，有序度高 归并排序 byte[] size &lt;&#x3D; 64 插入排序 size &gt; 64 计数排序 char[] short[] size &lt; 44 插入排序 再大 双基准点快排 递归次数超过 384 计数排序 size &gt; 1750 计数排序 Object[] -Djava.util.Arrays.useLegacyMergeSort&#x3D;true 传统归并排序 TimSort 其中 TimSort 是用归并+二分插入排序的混合排序算法 值得注意的是从 JDK 8 开始支持 Arrays.parallelSort 并行排序 根据最新的提交记录来看 JDK 21 可能会引入基数排序等优化 外部排序1) 冒泡排序要点 每轮冒泡不断地比较相邻的两个元素，如果它们是逆序的，则交换它们的位置 下一轮冒泡，可以调整未排序的右边界，减少不必要比较 以数组 3、2、1 的冒泡排序为例，第一轮冒泡 第二轮冒泡 未排序区域内就剩一个元素，结束 优化手段：每次循环时，若能确定更合适的右边界，则可以减少冒泡轮数 以数组 3、2、1、4、5 为例，第一轮结束后记录的 x，即为右边界 非递归版代码 12345678910111213141516171819202122232425262728public class BubbleSort &#123; private static void bubble(int[] a) &#123; int j = a.length - 1; while (true) &#123; int x = 0; for (int i = 0; i &lt; j; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; int t = a[i]; a[i] = a[i + 1]; a[i + 1] = t; x = i; &#125; &#125; j = x; if (j == 0) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;6, 5, 4, 3, 2, 1&#125;; System.out.println(Arrays.toString(a)); bubble(a); System.out.println(Arrays.toString(a)); &#125;&#125; 2) 选择排序要点 每一轮选择，找出最大（最小）的元素，并把它交换到合适的位置 以下面的数组选择最大值为例 非递归实现 123456789101112131415161718192021222324252627282930public class SelectionSort &#123; public static void sort(int[] a) &#123; // 1. 选择轮数 a.length - 1 // 2. 交换的索引位置(right) 初始 a.length - 1, 每次递减 for (int right = a.length - 1; right &gt; 0 ; right--) &#123; int max = right; for (int i = 0; i &lt; right; i++) &#123; if (a[i] &gt; a[max]) &#123; max = i; &#125; &#125; if(max != right) &#123; swap(a, max, right); &#125; &#125; &#125; private static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; public static void main(String[] args) &#123; int[] a = &#123;6, 5, 4, 3, 2, 1&#125;; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 3) 堆排序要点： 建立大顶堆 每次将堆顶元素（最大值）交换到末尾，调整堆顶元素，让它重新符合大顶堆特性 建堆 交换，下潜调整 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HeapSort &#123; public static void sort(int[] a) &#123; heapify(a, a.length); for (int right = a.length - 1; right &gt; 0; right--) &#123; swap(a, 0, right); down(a, 0, right); &#125; &#125; // 建堆 O(n) private static void heapify(int[] array, int size) &#123; for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; down(array, i, size); &#125; &#125; // 下潜 // leetcode 上数组排序题目用堆排序求解，非递归实现比递归实现大约快 6ms private static void down(int[] array, int parent, int size) &#123; while (true) &#123; int left = parent * 2 + 1; int right = left + 1; int max = parent; if (left &lt; size &amp;&amp; array[left] &gt; array[max]) &#123; max = left; &#125; if (right &lt; size &amp;&amp; array[right] &gt; array[max]) &#123; max = right; &#125; if (max == parent) &#123; // 没找到更大的孩子 break; &#125; swap(array, max, parent); parent = max; &#125; &#125; // 交换 private static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; public static void main(String[] args) &#123; int[] a = &#123;2, 3, 1, 7, 6, 4, 5&#125;; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 4) 插入排序要点 将数组分为两部分 [0 .. low-1] [low .. a.length-1] 左边 [0 .. low-1] 是已排序部分 右边 [low .. a.length-1] 是未排序部分 每次从未排序区域取出 low 位置的元素, 插入到已排序区域 例 代码 123456789101112131415161718192021222324252627public class InsertionSort &#123; public static void sort(int[] a) &#123; for (int low = 1; low &lt; a.length; low++) &#123; // 将 low 位置的元素插入至 [0..low-1] 的已排序区域 int t = a[low]; int i = low - 1; // 已排序区域指针 while (i &gt;= 0 &amp;&amp; t &lt; a[i]) &#123; // 没有找到插入位置 a[i + 1] = a[i]; // 空出插入位置 i--; &#125; // 找到插入位置 if (i != low - 1) &#123; a[i + 1] = t; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;9, 3, 7, 2, 5, 8, 1, 4&#125;; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 5) 希尔排序要点 简单的说，就是分组实现插入，每组元素间隙称为 gap 每轮排序后 gap 逐渐变小，直至 gap 为 1 完成排序 对插入排序的优化，让元素更快速地交换到最终位置 下图演示了 gap &#x3D; 4，gap &#x3D; 2，gap &#x3D; 1 的三轮排序前后比较 代码 12345678910111213141516171819202122232425262728public class ShellSort &#123; public static void sort(int[] a) &#123; for (int gap = a.length&gt;&gt;1; gap &gt;0 ; gap=gap&gt;&gt;1) &#123; for (int low = gap; low &lt; a.length; low ++) &#123; // 将 low 位置的元素插入至 [0..low-1] 的已排序区域 int t = a[low]; int i = low - gap; // 已排序区域指针 while (i &gt;= 0 &amp;&amp; t &lt; a[i]) &#123; // 没有找到插入位置 a[i + gap] = a[i]; // 空出插入位置 i -= gap; &#125; // 找到插入位置 if (i != low - gap) &#123; a[i + gap] = t; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;9, 3, 7, 2, 5, 8, 1, 4&#125;; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 6) 归并排序递归实现要点 分 - 每次从中间切一刀，处理的数据少一半 治 - 当数据仅剩一个时可以认为有序 合 - 两个有序的结果，可以进行合并排序（参见数组练习 E01. 合并有序数组） 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MergeSortTopDown &#123; /* a1 原始数组 i~iEnd 第一个有序范围 j~jEnd 第二个有序范围 a2 临时数组 */ public static void merge(int[] a1, int i, int iEnd, int j, int jEnd, int[] a2) &#123; int k = i; while (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) &#123; if (a1[i] &lt; a1[j]) &#123; a2[k] = a1[i]; i++; &#125; else &#123; a2[k] = a1[j]; j++; &#125; k++; &#125; if (i &gt; iEnd) &#123; System.arraycopy(a1, j, a2, k, jEnd - j + 1); &#125; if (j &gt; jEnd) &#123; System.arraycopy(a1, i, a2, k, iEnd - i + 1); &#125; &#125; public static void sort(int[] a1) &#123; int[] a2 = new int[a1.length]; split(a1, 0, a1.length - 1, a2); &#125; private static void split(int[] a1, int left, int right, int[] a2) &#123; int[] array = Arrays.copyOfRange(a1, left, right + 1);// System.out.println(Arrays.toString(array)); // 2. 治 if (left == right) &#123; return; &#125; // 1. 分 int m = (left + right) &gt;&gt;&gt; 1; split(a1, left, m, a2); // left = 0 m = 0 9 split(a1, m + 1, right, a2); // m+1 = 1 right = 1 3 // 3. 合 merge(a1, left, m, m + 1, right, a2); System.arraycopy(a2, left, a1, left, right - left + 1); &#125; public static void main(String[] args) &#123; int[] a = &#123;9, 3, 7, 2, 8, 5, 1, 4&#125;; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 时间复杂度 两个长度为 m 和 n 的链表合并，时间复杂度是 m + n 归并，时间复杂度：$f(n) &#x3D; 2f(n&#x2F;2) + n, f(1)&#x3D;c$，等价解 $f(n) &#x3D; nlog_2{n} + cn$ 1234567891011121314151617 8 / \\ 4 4 / \\ / \\ 2 2 2 2 || || || || 11 11 11 11 f(8) = 2f(4) + 8f(4) = 2f(2) + 4f(2) = 2f(1) + 2f(1) = 1f(8) = 8 + 24f(4) = 4 + 8f(2) = 2 + 2f(1) = 1 当 n &#x3D; 16 时，结果 80 当 n &#x3D; 64 时，结果 448 若逐一合并，时间复杂度：$f(n)&#x3D;\\sum\\limits_{n&#x3D;0}^{n-1}n+1$，等价解 $f(n)&#x3D;\\frac{1}{2}(n^2+n)$ 123456789101|0 =&gt; 11|1 =&gt; 21|2 =&gt; 31|3 =&gt; 41|4 =&gt; 51|5 =&gt; 61|6 =&gt; 71|7 =&gt; 836 当 n &#x3D; 16 时，结果 136 当 n &#x3D; 64 时，结果 2080 非递归实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MergeSortBottomUp &#123; /* a1 原始数组 i~iEnd 第一个有序范围 j~jEnd 第二个有序范围 a2 临时数组 */ public static void merge(int[] a1, int i, int iEnd, int j, int jEnd, int[] a2) &#123; int k = i; while (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) &#123; if (a1[i] &lt; a1[j]) &#123; a2[k] = a1[i]; i++; &#125; else &#123; a2[k] = a1[j]; j++; &#125; k++; &#125; if (i &gt; iEnd) &#123; System.arraycopy(a1, j, a2, k, jEnd - j + 1); &#125; if (j &gt; jEnd) &#123; System.arraycopy(a1, i, a2, k, iEnd - i + 1); &#125; &#125; public static void sort(int[] a1) &#123; int n = a1.length; int[] a2 = new int[n]; for (int width = 1; width &lt; n; width *= 2) &#123; for (int i = 0; i &lt; n; i += 2 * width) &#123; int m = Integer.min(i + width - 1, n - 1); int j = Integer.min(i + 2 * width - 1, n - 1); System.out.println(i + &quot; &quot; + m + &quot; &quot; + j); merge(a1, i, m, m + 1, j, a2); &#125; System.arraycopy(a2, 0, a1, 0, n); &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;9, 3, 7, 2, 8, 5, 1, 4&#125;; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 7) 归并+插入 小数据量且有序度高时，插入排序效果高 大数据量用归并效果好 可以结合二者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MergeInsertionSort &#123; public static void insertion(int[] a, int left, int right) &#123; for (int low = left + 1; low &lt;= right; low++) &#123; int t = a[low]; int i = low - 1; while (i &gt;= left &amp;&amp; t &lt; a[i]) &#123; a[i + 1] = a[i]; i--; &#125; if (i != low - 1) &#123; a[i + 1] = t; &#125; &#125; &#125; /* a1 原始数组 i~iEnd 第一个有序范围 j~jEnd 第二个有序范围 a2 临时数组 */ public static void merge(int[] a1, int i, int iEnd, int j, int jEnd, int[] a2) &#123; int k = i; while (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) &#123; if (a1[i] &lt; a1[j]) &#123; a2[k] = a1[i]; i++; &#125; else &#123; a2[k] = a1[j]; j++; &#125; k++; &#125; if (i &gt; iEnd) &#123; System.arraycopy(a1, j, a2, k, jEnd - j + 1); &#125; if (j &gt; jEnd) &#123; System.arraycopy(a1, i, a2, k, iEnd - i + 1); &#125; &#125; public static void sort(int[] a1) &#123; int[] a2 = new int[a1.length]; split(a1, 0, a1.length - 1, a2); &#125; private static void split(int[] a1, int left, int right, int[] a2) &#123;// int[] array = Arrays.copyOfRange(a1, left, right + 1);// System.out.println(Arrays.toString(array)); // 2. 治 if (right == left) &#123; return; &#125; if (right - left &lt;= 32) &#123; insertion(a1, left, right); System.out.println(&quot;insert...&quot; + left + &quot; &quot; + right +&quot; &quot;+Arrays.toString(a1)); return; &#125; // 1. 分 int m = (left + right) &gt;&gt;&gt; 1; split(a1, left, m, a2); // left = 0 m = 0 9 split(a1, m + 1, right, a2); // m+1 = 1 right = 1 3 System.out.println(left + &quot; &quot; + right + &quot; &quot;+Arrays.toString(a1)); // 3. 合 merge(a1, left, m, m + 1, right, a2); System.arraycopy(a2, left, a1, left, right - left + 1); &#125; public static void main(String[] args) &#123; int[] a = &#123;9, 3, 7, 2, 8, 5, 1, 4&#125;; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 8) 快速排序单边循环（lomuto分区）要点 选择最右侧元素作为基准点 j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换 交换时机：j 找到小的，且与 i 不相等 i 找到 &gt;&#x3D; 基准点元素后，不应自增 最后基准点与 i 交换，i 即为基准点最终索引 例： i 和 j 都从左边出发向右查找，i 找到比基准点4大的5，j找到比基准点小的2，停下来交换 i 找到了比基准点大的5，j 找到比基准点小的3，停下来交换 j 到达right 处结束，right 与 i 交换，一轮分区结束 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class QuickSortLomuto &#123; public static void sort(int[] a) &#123; quick(a, 0, a.length - 1); &#125; private static void quick(int[] a, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int p = partition(a, left, right); // p代表基准点元素索引 quick(a, left, p - 1); quick(a, p + 1, right); &#125; private static int partition(int[] a, int left, int right) &#123; int pv = a[right]; // 基准点元素值 int i = left; int j = left; while (j &lt; right) &#123; if (a[j] &lt; pv) &#123; // j 找到比基准点小的了, 没找到大的 if (i != j) &#123; swap(a, i, j); &#125; i++; &#125; j++; &#125; swap(a, i, right); return i; &#125; private static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; public static void main(String[] args) &#123; int[] a = &#123;5, 3, 7, 2, 9, 8, 1, 4&#125;; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 双边循环要点 选择最左侧元素作为基准点 j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换 i 从左向右 j 从右向左 最后基准点与 i 交换，i 即为基准点最终索引 例： i 找到比基准点大的5停下来，j 找到比基准点小的1停下来（包含等于），二者交换 i 找到8，j 找到3，二者交换，i 找到7，j 找到2，二者交换 i &#x3D;&#x3D; j，退出循环，基准点与 i 交换 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class QuickSortHoare &#123; public static void sort(int[] a) &#123; quick(a, 0, a.length - 1); &#125; private static void quick(int[] a, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int p = partition(a, left, right); quick(a, left, p - 1); quick(a, p + 1, right); &#125; private static int partition(int[] a, int left, int right) &#123; int i = left; int j = right; int pv = a[left]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &gt; pv) &#123; j--; &#125; while (i &lt; j &amp;&amp; pv &gt;= a[i]) &#123; i++; &#125; swap(a, i, j); &#125; swap(a, left, j); return j; &#125; private static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; public static void main(String[] args) &#123; int[] a = &#123;9, 3, 7, 2, 8, 5, 1, 4&#125;; System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 随机基准点使用随机数作为基准点，避免万一最大值或最小值作为基准点导致的分区不均衡 例 改进代码 12int idx = ThreadLocalRandom.current().nextInt(right - left + 1) + left;swap(a, idx, left); 处理重复值如果重复值较多，则原来算法中的分区效果也不好，如下图中左侧所示，需要想办法改为右侧的分区效果 改进代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class QuickSortHandleDuplicate &#123; public static void sort(int[] a) &#123; quick(a, 0, a.length - 1); &#125; private static void quick(int[] a, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int p = partition(a, left, right); quick(a, left, p - 1); quick(a, p + 1, right); &#125; /* 循环内 i 从 left + 1 开始，从左向右找大的或相等的 j 从 right 开始，从右向左找小的或相等的 交换，i++ j-- 循环外 j 和 基准点交换，j 即为分区位置 */ private static int partition(int[] a, int left, int right) &#123; int idx = ThreadLocalRandom.current().nextInt(right - left + 1) + left; swap(a, left, idx); int pv = a[left]; int i = left + 1; int j = right; while (i &lt;= j) &#123; // i 从左向右找大的或者相等的 while (i &lt;= j &amp;&amp; a[i] &lt; pv) &#123; i++; &#125; // j 从右向左找小的或者相等的 while (i &lt;= j &amp;&amp; a[j] &gt; pv) &#123; j--; &#125; if (i &lt;= j) &#123; swap(a, i, j); i++; j--; &#125; &#125; swap(a, j, left); return j; &#125; private static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; public static void main(String[] args) &#123;// int[] a = &#123;4, 2, 1, 3, 2, 4&#125;; // 最外层循环 = 要加// int[] a = &#123;2, 1, 3, 2&#125;; // 内层循环 = 要加 int[] a = &#123;2, 1, 3, 2&#125;; // 内层if要加 System.out.println(Arrays.toString(a)); sort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 核心思想是 改进前，i 只找大于的，j 会找小于等于的。一个不找等于、一个找等于，势必导致等于的值分布不平衡 改进后，二者都会找等于的交换，等于的值会平衡分布在基准点两边 细节： 因为一开始 i 就可能等于 j，因此外层循环需要加等于条件保证至少进入一次，让 j 能减到正确位置 内层 while 循环中 i &lt;&#x3D; j 的 &#x3D; 也不能去掉，因为 i &#x3D;&#x3D; j 时也要做一次与基准点的判断，好让 i 及 j 正确 i &#x3D;&#x3D; j 时，也要做一次 i++ 和 j– 使下次循环二者不等才能退出 因为最后退出循环时 i 会大于 j，因此最终与基准点交换的是 j 内层两个 while 循环的先后顺序不再重要 9) 计数排序方法1（简化后的计数排序） 1234567891011121314151617181920212223public static void sort(int[] a) &#123; int min = a[0]; int max = a[0]; for (int i : a) &#123; if (i &gt; max) &#123; max = i; &#125; else if (i &lt; min) &#123; min = i; &#125; &#125; int[] counting = new int[max - min + 1]; for (int i : a) &#123; counting[i - min]++; &#125; int k = 0; for (int i = 0; i &lt; counting.length; i++) &#123; while (counting[i] &gt; 0) &#123; a[k] = i + min; counting[i]--; k++; &#125; &#125;&#125; 针对 byte []，因为数据范围已知，省去了求最大、最小值的过程，java 中对 char[]、short[]、byte[] 的排序都可能采用 counting 排序 12345678910111213141516public static void sort(byte[] a) &#123; int[] counting = new int[256]; for (int i : a) &#123; counting[i &amp; 0xFF]++; &#125; int k = a.length-1; for (int i = 128 + 256; k &gt;= 0; ) &#123; while (counting[--i &amp; 0xFF] ==0); int v = i &amp; 0xFF; int c = counting[i &amp; 0xFF]; for (int j = 0; j &lt; c; j++) &#123; a[k] = (byte) v; k--; &#125; &#125;&#125; 稳定计数排序 12345678910111213141516171819202122232425public static void sort2(int[] a) &#123; int min = a[0]; int max = a[0]; for (int i : a) &#123; if (i &gt; max) &#123; max = i; &#125; else if (i &lt; min) &#123; min = i; &#125; &#125; int[] counting = new int[max - min + 1]; for (int i : a) &#123; counting[i - min]++; &#125; for (int i = 1; i &lt; counting.length; i++) &#123; counting[i] = counting[i] + counting[i - 1]; &#125; int[] b = new int[a.length]; for (int i = a.length - 1; i &gt;= 0; i--) &#123; int j = a[i] - min; counting[j]--; b[counting[j]] = a[i]; &#125; System.arraycopy(b, 0, a, 0, a.length);&#125; 10) 桶排序初步实现 123456789101112131415161718192021222324252627282930public class BucketSort &#123; public static void main(String[] args) &#123; int[] ages = &#123;20, 18, 66, 25, 67, 30&#125;; // 假设人类年龄 1~99 那么分为10个桶 System.out.println(Arrays.toString(ages)); sort(ages); System.out.println(Arrays.toString(ages)); &#125; public static void sort(int[] a) &#123; DynamicArray[] buckets = new DynamicArray[10]; for (int i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = new DynamicArray(); &#125; for (int v : a) &#123; DynamicArray bucket = buckets[v / 10]; bucket.addLast(v); &#125; for (DynamicArray bucket : buckets) &#123; System.out.println(Arrays.toString(bucket.array())); &#125; int k = 0; for (DynamicArray bucket : buckets) &#123; int[] array = bucket.array(); InsertionSort.sort(array); for (int v : array) &#123; a[k++] = v; &#125; &#125; &#125;&#125; 通用 123456789101112131415161718192021222324252627282930313233343536373839404142public class BucketSortGeneric &#123; public static void main(String[] args) &#123; int[] ages = &#123;20, 10, 28, 66, 25, 31, 67, 30, 70&#125;; // 假设人类年龄 1~99 System.out.println(Arrays.toString(ages)); sort(ages, 20); System.out.println(Arrays.toString(ages)); &#125; public static void sort(int[] a, int range) &#123; int max = a[0]; int min = a[0]; for (int i = 1; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; max = a[i]; &#125; if (a[i] &lt; min) &#123; min = a[i]; &#125; &#125; // 1. 准备桶 DynamicArray[] buckets = new DynamicArray[(max - min) / range + 1]; System.out.println(buckets.length); for (int i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = new DynamicArray(); &#125; // 2. 放入年龄数据 for (int age : a) &#123; buckets[(age - min) / range].addLast(age); &#125; int k = 0; for (DynamicArray bucket : buckets) &#123; // 3. 排序桶内元素 int[] array = bucket.array(); InsertionSort.sort(array); System.out.println(Arrays.toString(array)); // 4. 把每个桶排序好的内容，依次放入原始数组 for (int v : array) &#123; a[k++] = v; &#125; &#125; &#125;&#125; 11) 基数排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class RadixSort &#123; public static void radixSort(String[] a, int length) &#123; ArrayList&lt;String&gt;[] buckets = new ArrayList[128]; for (int i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = new ArrayList&lt;&gt;(); &#125; for (int i = length - 1; i &gt;= 0 ; i--) &#123; for (String s : a) &#123; buckets[s.charAt(i)].add(s); &#125; int k = 0; for (ArrayList&lt;String&gt; bucket : buckets) &#123; for (String s : bucket) &#123; a[k++] = s; &#125; bucket.clear(); &#125; &#125; &#125; public static void main(String[] args) &#123; /*String[] phoneNumbers = new String[10]; phoneNumbers[0] = &quot;13812345678&quot;; phoneNumbers[1] = &quot;13912345678&quot;; phoneNumbers[2] = &quot;13612345678&quot;; phoneNumbers[3] = &quot;13712345678&quot;; phoneNumbers[4] = &quot;13512345678&quot;; phoneNumbers[5] = &quot;13412345678&quot;; phoneNumbers[6] = &quot;15012345678&quot;; phoneNumbers[7] = &quot;15112345678&quot;; phoneNumbers[8] = &quot;15212345678&quot;; phoneNumbers[9] = &quot;15712345678&quot;;*/ String[] phoneNumbers = new String[10]; phoneNumbers[0] = &quot;138&quot;; phoneNumbers[1] = &quot;139&quot;; phoneNumbers[2] = &quot;136&quot;; phoneNumbers[3] = &quot;137&quot;; phoneNumbers[4] = &quot;135&quot;; phoneNumbers[5] = &quot;134&quot;; phoneNumbers[6] = &quot;150&quot;; phoneNumbers[7] = &quot;151&quot;; phoneNumbers[8] = &quot;152&quot;; phoneNumbers[9] = &quot;157&quot;; RadixSort.radixSort(phoneNumbers, 3); for (String phoneNumber : phoneNumbers) &#123; System.out.println(phoneNumber); &#125; &#125;&#125; 基数排序是稳定排序，因此先排个位、再排十位，十位的排序不会打乱个位取值相等的元素顺序 习题E01. 根据另一个数组次序排序-Leetcode 112212345678910111213141516171819202122232425262728/* 前提 1. 元素值均 &gt;= 0 2. arr2 内元素唯一，且长度 &lt;= 1000 */public class E01Leetcode1122 &#123; public int[] relativeSortArray(int[] arr1, int[] arr2) &#123; int[] count = new int[1001]; for (int i : arr1) &#123; count[i]++; &#125; int[] result = new int[arr1.length]; int k = 0; for (int i : arr2) &#123; while (count[i] &gt; 0) &#123; result[k++] = i; count[i]--; &#125; &#125; for (int i = 0; i &lt; count.length; i++) &#123; while (count[i] &gt; 0) &#123; result[k++] = i; count[i]--; &#125; &#125; return result; &#125;&#125; E02. 按出现频率排序-Leetcode 1636123456789101112131415161718public class E02Leetcode1636 &#123; public int[] frequencySort(int[] nums) &#123; int[] count = new int[201]; for (int i : nums) &#123; count[i + 100]++; &#125; return Arrays.stream(nums).boxed().sorted((a, b) -&gt; &#123; int fa = count[a + 100]; int fb = count[b + 100]; if (fa == fb) &#123; return Integer.compare(b, a); &#125; else &#123; return fa - fb; &#125; &#125;).mapToInt(Integer::intValue).toArray(); &#125;&#125; E03. 最大间距-Leetcode 164解法1：桶排序 - 超过内存限制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class E03Leetcode164_1 &#123; public int maximumGap(int[] nums) &#123; int n = nums.length; if (n &lt; 2) &#123; return 0; &#125; sort(nums, 1); int ret = 0; for (int i = 1; i &lt; n; i++) &#123; ret = Math.max(ret, nums[i] - nums[i - 1]); &#125; return ret; &#125; public static void sort(int[] a, int range) &#123; int max = a[0]; int min = a[0]; for (int i = 1; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; max = a[i]; &#125; if (a[i] &lt; min) &#123; min = a[i]; &#125; &#125; // 1. 准备桶 DynamicArray[] buckets = new DynamicArray[(max - min) / range + 1]; for (int i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = new DynamicArray(); &#125; // 2. 放入数据 for (int age : a) &#123; buckets[(age - min) / range].addLast(age); &#125; int k = 0; for (DynamicArray bucket : buckets) &#123; // 3. 排序桶内元素 int[] array = bucket.array(); InsertionSort.sort(array); // 4. 把每个桶排序好的内容，依次放入原始数组 for (int v : array) &#123; a[k++] = v; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] nums = &#123;13, 26, 16, 11&#125;; int r = new E03Leetcode164_1().maximumGap(nums); System.out.println(r); &#125;&#125; 解法2：基数排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class E03Leetcode164 &#123; public int maximumGap(int[] a) &#123; if (a.length &lt; 2) &#123; return 0; &#125; // 计算最大值 int max = a[0]; for (int i = 1; i &lt; a.length; i++) &#123; max = Math.max(a[i], max); &#125; // 准备10个桶 ArrayList&lt;Integer&gt;[] buckets = new ArrayList[10]; for (int i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = new ArrayList&lt;&gt;(); &#125; // 没超过最大值 long exp = 1; while (max &gt;= exp) &#123; for (int j : a) &#123; buckets[(j / (int) exp) % 10].add(j); &#125; int k = 0; for (ArrayList&lt;Integer&gt; bucket : buckets) &#123; for (Integer i : bucket) &#123; a[k++] = i; &#125; bucket.clear(); &#125; exp *= 10; &#125; // 求最大间距 int r = 0; for (int i = 1; i &lt; a.length; i++) &#123; r = Math.max(r, a[i] - a[i - 1]); &#125; return r; &#125; public static void main(String[] args) &#123; int[] nums = &#123;3, 6, 16, 1&#125;; int r = new E03Leetcode164().maximumGap(nums); System.out.println(r); &#125;&#125; 解法3：桶排序 - 合理化桶个数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class E03Leetcode164_3 &#123; public int maximumGap(int[] nums) &#123; // 1. 处理特殊情况 if (nums.length &lt; 2) &#123; return 0; &#125; // 2. 桶排序 int max = nums[0]; int min = nums[0]; for (int i1 = 1; i1 &lt; nums.length; i1++) &#123; if (nums[i1] &gt; max) &#123; max = nums[i1]; &#125; if (nums[i1] &lt; min) &#123; min = nums[i1]; &#125; &#125; // 2.1 准备桶 /* 计算桶个数 期望桶个数 (max - min) / range + 1 = nums.length (max - min) / (nums.length - 1) = range */ int range = Math.max((max - min) / (nums.length - 1), 1); DynamicArray[] buckets = new DynamicArray[(max - min) / range + 1]; for (int i1 = 0; i1 &lt; buckets.length; i1++) &#123; buckets[i1] = new DynamicArray(); &#125; // 2.2 放入数据 for (int age : nums) &#123; buckets[(age - min) / range].addLast(age); &#125; int k = 0; for (DynamicArray bucket : buckets) &#123; // 2.3 排序桶内元素 int[] array = bucket.array(); InsertionSort.sort(array); System.out.println(Arrays.toString(array)); // 2.4 把每个桶排序好的内容，依次放入原始数组 for (int v : array) &#123; nums[k++] = v; &#125; &#125; // 3. 寻找最大差值 int r = 0; for (int i = 1; i &lt; nums.length; i++) &#123; r = Math.max(r, nums[i] - nums[i - 1]); &#125; return r; &#125; public static void main(String[] args) &#123;// int[] nums = &#123;1, 10000000&#125;;// int[] nums = &#123;9, 1, 3, 5&#125;;// int[] nums = &#123;1, 1, 1, 1&#125;;// int[] nums = &#123;1, 1, 1, 1, 1, 5, 5, 5, 5, 5&#125;; int[] nums = &#123;15252, 16764, 27963, 7817, 26155, 20757, 3478, 22602, 20404, 6739, 16790, 10588, 16521, 6644, 20880, 15632, 27078, 25463, 20124, 15728, 30042, 16604, 17223, 4388, 23646, 32683, 23688, 12439, 30630, 3895, 7926, 22101, 32406, 21540, 31799, 3768, 26679, 21799, 23740&#125;; int r = new E03Leetcode164_3().maximumGap(nums); System.out.println(r); &#125;&#125; 解法4：在解法3的基础上，只保留桶内最大最小值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class E03Leetcode164_4 &#123; public int maximumGap(int[] nums) &#123; // 1. 处理特殊情况 if (nums.length &lt; 2) &#123; return 0; &#125; // 2. 桶排序 // 桶个数 (max - min) / range + 1 期望桶个数 nums.length + 1 // range = (max - min) / nums.length int max = nums[0]; int min = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; max) &#123; max = nums[i]; &#125; if (nums[i] &lt; min) &#123; min = nums[i]; &#125; &#125; if (max == min) &#123; return 0; &#125; int range = Math.max(1, (max - min) / nums.length); int size = (max - min) / range + 1; Pair[] buckets = new Pair[size]; // 2. 放入数据 for (int i : nums) &#123; int idx = (i - min) / range; if (buckets[idx] == null) &#123; buckets[idx] = new Pair(); &#125; buckets[idx].add(i); &#125; System.out.println(Arrays.toString(buckets)); // 3. 寻找最大差值 int r = 0; int lastMax = buckets[0].max; for (int i = 1; i &lt; buckets.length; i++) &#123; Pair pair = buckets[i]; if (pair != null) &#123; r = Math.max(r, pair.min - lastMax); lastMax = pair.max; &#125; &#125; return r; &#125; static class Pair &#123; int max = 0; int min = 1000_000_000; public void add(int v) &#123; max = Math.max(max, v); min = Math.min(min, v); &#125; @Override public String toString() &#123; return &quot;[&quot; + min + &quot;,&quot; + max + &quot;]&quot;; &#125; &#125; public static void main(String[] args) &#123; int[] nums = &#123;9, 1, 6, 5&#125;;// int[] nums = &#123;1, 10000000&#125;;// int[] nums = &#123;1, 1, 1, 1&#125;;// int[] nums = &#123;1, 1, 1, 1, 1, 5, 5, 5, 5, 5&#125;;// int[] nums = &#123;15252, 16764, 27963, 7817, 26155, 20757, 3478, 22602, 20404, 6739, 16790, 10588, 16521, 6644, 20880, 15632, 27078, 25463, 20124, 15728, 30042, 16604, 17223, 4388, 23646, 32683, 23688, 12439, 30630, 3895, 7926, 22101, 32406, 21540, 31799, 3768, 26679, 21799, 23740&#125;; int r = new E03Leetcode164_4().maximumGap(nums); System.out.println(r); &#125;&#125; 排序数组-Leetcode 912排序链表-Leetcode 148其它题目 题目编号 题目标题 排序算法类型 1122 数组的相对排序 计数排序 1636 按照频率将数组升序排序 计数排序 164 最大间距 基数排序、桶排序 315 计算右侧小于当前元素的个数 基数排序 347 前 K 个高频元素 桶排序 题目编号 题目标题 排序算法类型 75 颜色分类 三向切分快速排序 215 数组中的第K个最大元素 堆排序 493 翻转对 归并排序 493 翻转对 树状数组 524 通过删除字母匹配到字典里最长单词 循环排序 977 有序数组的平方 双指针法 四. 高级数据结构与算法设计4.1 图1) 概念图是由顶点（vertex）和边（edge）组成的数据结构，例如 123456graph LR A---&gt;B A---&gt;C B---&gt;D C---&gt;D 该图有四个顶点：A、B、C、D 以及四条有向边，有向图中，边是单向的 有向 vs 无向如果是无向图，那么边是双向的，下面是一个无向图的例子 12345graph LR A---B A---C B---D C---D 度度是指与该顶点相邻的边的数量 12345678910graph LR A((A))---B((B)) A---C((C)) B---D((D)) C---D D---E((E)) D---F((F)) E---F A &amp; B &amp; C &amp; D &amp; E &amp; F 例如上图中 A、B、C、E、F 这几个顶点度数为 2 D 顶点度数为 4 有向图中，细分为入度和出度，参见下图 12345678910graph LR A((A))--&gt;B((B)) A--&gt;C((C)) B--&gt;D((D)) C--&gt;D D--&gt;E((E)) D--&gt;F((F)) E--&gt;F A &amp; B &amp; C &amp; D &amp; E &amp; F A (2 out &#x2F; 0 in) B、C、E (1 out &#x2F; 1 in) D (2 out &#x2F; 2 in) F (0 out &#x2F; 2 in) 权边可以有权重，代表从源顶点到目标顶点的距离、费用、时间或其他度量。 1234567891011graph LR BJ((北京)) WH((武汉)) GZ((广州)) SH((上海)) BJ---800km--&gt;WH BJ---1900km--&gt;GZ BJ---1200km--&gt;SH WH---1050km--&gt;GZ WH---700km--&gt;SH 路径路径被定义为从一个顶点到另一个顶点的一系列连续边，例如上图中【北京】到【上海】有多条路径 北京 - 上海 北京 - 武汉 - 上海 路径长度 不考虑权重，长度就是边的数量 考虑权重，一般就是权重累加 环在有向图中，从一个顶点开始，可以通过若干条有向边返回到该顶点，那么就形成了一个环 12345678910111213graph LR A((A)) B((B)) C((C)) D((D)) E((E)) A---&gt;B B---&gt;C C---&gt;D D---&gt;E E---&gt;A 图的连通性如果两个顶点之间存在路径，则这两个顶点是连通的，所有顶点都连通，则该图被称之为连通图，若子图连通，则称为连通分量 1234567891011graph LR A --- B A --- C C --- D D --- E B --- E F --- G G --- H H --- F I --- J 2) 图的表示比如说，下面的图 12345graph LR A---B A---C B---D C---D 用邻接矩阵可以表示为： 12345 A B C DA 0 1 1 0B 1 0 0 1 C 1 0 0 1D 0 1 1 0 用邻接表可以表示为： 1234A -&gt; B -&gt; CB -&gt; A -&gt; DC -&gt; A -&gt; DD -&gt; B -&gt; C 有向图的例子 12345graph LR A---&gt;B A---&gt;C B---&gt;D C---&gt;D 12345 A B C DA 0 1 1 0B 0 0 0 1C 0 0 0 1D 0 0 0 0 1234A - B - CB - DC - DD - empty 3) Java 表示顶点 12345678910111213141516public class Vertex &#123; String name; List&lt;Edge&gt; edges; // 拓扑排序相关 int inDegree; int status; // 状态 0-未访问 1-访问中 2-访问过，用在拓扑排序 // dfs, bfs 相关 boolean visited; // 求解最短距离相关 private static final int INF = Integer.MAX_VALUE; int dist = INF; Vertex prev = null;&#125; 边 1234567891011121314public class Edge &#123; Vertex linked; int weight; public Edge(Vertex linked) &#123; this(linked, 1); &#125; public Edge(Vertex linked, int weight) &#123; this.linked = linked; this.weight = weight; &#125;&#125; 4) DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Dfs &#123; public static void main(String[] args) &#123; Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); Vertex v5 = new Vertex(&quot;v5&quot;); Vertex v6 = new Vertex(&quot;v6&quot;); v1.edges = List.of(new Edge(v3), new Edge(v2), new Edge(v6)); v2.edges = List.of(new Edge(v4)); v3.edges = List.of(new Edge(v4), new Edge(v6)); v4.edges = List.of(new Edge(v5)); v5.edges = List.of(); v6.edges = List.of(new Edge(v5)); dfs1(v1); &#125; private static void dfs2(Vertex v) &#123; LinkedList&lt;Vertex&gt; stack = new LinkedList&lt;&gt;(); stack.push(v); while (!stack.isEmpty()) &#123; Vertex pop = stack.pop(); pop.visited = true; System.out.println(pop.name); for (Edge edge : pop.edges) &#123; if (!edge.linked.visited) &#123; stack.push(edge.linked); &#125; &#125; &#125; &#125; private static void dfs1(Vertex v) &#123; v.visited = true; System.out.println(v.name); for (Edge edge : v.edges) &#123; if (!edge.linked.visited) &#123; dfs(edge.linked); &#125; &#125; &#125;&#125; 5) BFS1234567891011121314151617181920212223242526272829303132333435public class Bfs &#123; public static void main(String[] args) &#123; Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); Vertex v5 = new Vertex(&quot;v5&quot;); Vertex v6 = new Vertex(&quot;v6&quot;); v1.edges = List.of(new Edge(v3), new Edge(v2), new Edge(v6)); v2.edges = List.of(new Edge(v4)); v3.edges = List.of(new Edge(v4), new Edge(v6)); v4.edges = List.of(new Edge(v5)); v5.edges = List.of(); v6.edges = List.of(new Edge(v5)); bfs(v1); &#125; private static void bfs(Vertex v) &#123; LinkedList&lt;Vertex&gt; queue = new LinkedList&lt;&gt;(); v.visited = true; queue.offer(v); while (!queue.isEmpty()) &#123; Vertex poll = queue.poll(); System.out.println(poll.name); for (Edge edge : poll.edges) &#123; if (!edge.linked.visited) &#123; edge.linked.visited = true; queue.offer(edge.linked); &#125; &#125; &#125; &#125;&#125; 6) 拓扑排序1234567graph LR\tHTML[网页基础] --&gt; WEB SE[Java 基础] --&gt; WEB[Java Web] DB[数据库] --&gt; Spring WEB --&gt; Spring[Spring框架] Spring --&gt; Micro[微服务框架] Micro --&gt; Project[实战项目] Kahn123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TopologicalSort &#123; public static void main(String[] args) &#123; Vertex v1 = new Vertex(&quot;网页基础&quot;); Vertex v2 = new Vertex(&quot;Java基础&quot;); Vertex v3 = new Vertex(&quot;JavaWeb&quot;); Vertex v4 = new Vertex(&quot;Spring框架&quot;); Vertex v5 = new Vertex(&quot;微服务框架&quot;); Vertex v6 = new Vertex(&quot;数据库&quot;); Vertex v7 = new Vertex(&quot;实战项目&quot;); v1.edges = List.of(new Edge(v3)); // +1 v2.edges = List.of(new Edge(v3)); // +1 v3.edges = List.of(new Edge(v4)); v6.edges = List.of(new Edge(v4)); v4.edges = List.of(new Edge(v5)); v5.edges = List.of(new Edge(v7)); v7.edges = List.of(); List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6, v7); // 1. 统计每个顶点的入度 for (Vertex v : graph) &#123; for (Edge edge : v.edges) &#123; edge.linked.inDegree++; &#125; &#125; /*for (Vertex vertex : graph) &#123; System.out.println(vertex.name + &quot; &quot; + vertex.inDegree); &#125;*/ // 2. 将入度为0的顶点加入队列 LinkedList&lt;Vertex&gt; queue = new LinkedList&lt;&gt;(); for (Vertex v : graph) &#123; if (v.inDegree == 0) &#123; queue.offer(v); &#125; &#125; // 3. 队列中不断移除顶点，每移除一个顶点，把它相邻顶点入度减1，若减到0则入队 List&lt;String&gt; result = new ArrayList&lt;&gt;(); while (!queue.isEmpty()) &#123; Vertex poll = queue.poll();// System.out.println(poll.name); result.add(poll.name); for (Edge edge : poll.edges) &#123; edge.linked.inDegree--; if (edge.linked.inDegree == 0) &#123; queue.offer(edge.linked); &#125; &#125; &#125; if (result.size() != graph.size()) &#123; System.out.println(&quot;出现环&quot;); &#125; else &#123; for (String key : result) &#123; System.out.println(key); &#125; &#125; &#125;&#125; DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TopologicalSortDFS &#123; public static void main(String[] args) &#123; Vertex v1 = new Vertex(&quot;网页基础&quot;); Vertex v2 = new Vertex(&quot;Java基础&quot;); Vertex v3 = new Vertex(&quot;JavaWeb&quot;); Vertex v4 = new Vertex(&quot;Spring框架&quot;); Vertex v5 = new Vertex(&quot;微服务框架&quot;); Vertex v6 = new Vertex(&quot;数据库&quot;); Vertex v7 = new Vertex(&quot;实战项目&quot;); v1.edges = List.of(new Edge(v3)); v2.edges = List.of(new Edge(v3)); v3.edges = List.of(new Edge(v4)); v6.edges = List.of(new Edge(v4)); v4.edges = List.of(new Edge(v5)); v5.edges = List.of(new Edge(v7)); v7.edges = List.of(); List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6, v7); LinkedList&lt;String&gt; result = new LinkedList&lt;&gt;(); for (Vertex v : graph) &#123; if(v.status==0) &#123; dfs(v, result); &#125; &#125; System.out.println(result); &#125; private static void dfs(Vertex v, LinkedList&lt;String&gt; result) &#123; if (v.status == 2) &#123; return; &#125; if (v.status == 1) &#123; throw new RuntimeException(&quot;发现环&quot;); &#125; v.status = 1; for (Edge edge : v.edges) &#123; dfs(edge.linked, result); &#125; v.status = 2; result.push(v.name); &#125;&#125; 7) 最短路径Dijkstra Edsger Wybe Dijkstra 艾兹格·维布·迪克斯特拉（Edsger Wybe Dijkstra，&#x2F;ˈdaɪkstrə&#x2F; DYKE-strə；荷兰语：[ˈɛtsxər ˈʋibə ˈdɛikstra] 1930年5月11日-2002年8月6日）是一位荷兰计算机科学家、程序员、软件工程师、系统科学家和科学散文家。他因对开发结构化编程语言做出的基础贡献而获得了1972年的图灵奖，并担任德克萨斯大学奥斯汀分校的斯伦贝谢百年计算机科学主席，任职时间从1984年到2000年。在他于2002年去世前不久，他因其在程序计算的自稳定性方面的工作而获得了ACM PODC分布式计算有影响力论文奖。为了纪念他，该年度奖项在接下来的一年更名为迪克斯特拉奖。 迪克斯特拉在计算机科学领域的贡献 最短路径算法，也称为迪克斯特拉算法，现代计算机科学本科课程中广泛教授 Shunting yard算法 THE OS 操作系统 银行家算法 用于协调多个处理器和程序的信号量构造 在分布式计算领域提出概念：自稳定性 123456789graph LR 1--7--&gt;2 1--9---&gt;3 1--14---&gt;6 6--9---&gt;5 3--2---&gt;6 2--15---&gt;4 3--11---&gt;4 4--6---&gt;5 算法描述： 将所有顶点标记为未访问。创建一个未访问顶点的集合。 为每个顶点分配一个临时距离值 对于我们的初始顶点，将其设置为零 对于所有其他顶点，将其设置为无穷大。 每次选择最小临时距离的未访问顶点，作为新的当前顶点 对于当前顶点，遍历其所有未访问的邻居，并更新它们的临时距离为更小 例如，1-&gt;6 的距离是 14，而1-&gt;3-&gt;6 的距离是11。这时将距离更新为 11 否则，将保留上次距离值 当前顶点的邻居处理完成后，把它从未访问集合中删除 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Dijkstra &#123; public static void main(String[] args) &#123; Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); Vertex v5 = new Vertex(&quot;v5&quot;); Vertex v6 = new Vertex(&quot;v6&quot;); v1.edges = List.of(new Edge(v3, 9), new Edge(v2, 7), new Edge(v6, 14)); v2.edges = List.of(new Edge(v4, 15)); v3.edges = List.of(new Edge(v4, 11), new Edge(v6, 2)); v4.edges = List.of(new Edge(v5, 6)); v5.edges = List.of(); v6.edges = List.of(new Edge(v5, 9)); List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6); dijkstra(graph, v1); &#125; private static void dijkstra(List&lt;Vertex&gt; graph, Vertex source) &#123; ArrayList&lt;Vertex&gt; list = new ArrayList&lt;&gt;(graph); source.dist = 0; while (!list.isEmpty()) &#123; // 3. 选取当前顶点 Vertex curr = chooseMinDistVertex(list); // 4. 更新当前顶点邻居距离 updateNeighboursDist(curr, list); // 5. 移除当前顶点 list.remove(curr); &#125; for (Vertex v : graph) &#123; System.out.println(v.name + &quot; &quot; + v.dist); &#125; &#125; private static void updateNeighboursDist(Vertex curr, ArrayList&lt;Vertex&gt; list) &#123; for (Edge edge : curr.edges) &#123; Vertex n = edge.linked; if (list.contains(n)) &#123; int dist = curr.dist + edge.weight; if (dist &lt; n.dist) &#123; n.dist = dist; &#125; &#125; &#125; &#125; private static Vertex chooseMinDistVertex(ArrayList&lt;Vertex&gt; list) &#123; Vertex min = list.get(0); for (int i = 1; i &lt; list.size(); i++) &#123; if (list.get(i).dist &lt; min.dist) &#123; min = list.get(i); &#125; &#125; return min; &#125;&#125; 改进 - 优先级队列 创建一个优先级队列，放入所有顶点（队列大小会达到边的数量） 为每个顶点分配一个临时距离值 对于我们的初始顶点，将其设置为零 对于所有其他顶点，将其设置为无穷大。 每次选择最小临时距离的未访问顶点，作为新的当前顶点 对于当前顶点，遍历其所有未访问的邻居，并更新它们的临时距离为更小，若距离更新需加入队列 例如，1-&gt;6 的距离是 14，而1-&gt;3-&gt;6 的距离是11。这时将距离更新为 11 否则，将保留上次距离值 当前顶点的邻居处理完成后，把它从队列中删除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DijkstraPriorityQueue &#123; public static void main(String[] args) &#123; Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); Vertex v5 = new Vertex(&quot;v5&quot;); Vertex v6 = new Vertex(&quot;v6&quot;); v1.edges = List.of(new Edge(v3, 9), new Edge(v2, 7), new Edge(v6, 14)); v2.edges = List.of(new Edge(v4, 15)); v3.edges = List.of(new Edge(v4, 11), new Edge(v6, 2)); v4.edges = List.of(new Edge(v5, 6)); v5.edges = List.of(); v6.edges = List.of(new Edge(v5, 9)); List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6); dijkstra(graph, v1); &#125; private static void dijkstra(List&lt;Vertex&gt; graph, Vertex source) &#123; PriorityQueue&lt;Vertex&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(v -&gt; v.dist)); source.dist = 0; for (Vertex v : graph) &#123; queue.offer(v); &#125; while (!queue.isEmpty()) &#123; System.out.println(queue); // 3. 选取当前顶点 Vertex curr = queue.peek(); // 4. 更新当前顶点邻居距离 if(!curr.visited) &#123; updateNeighboursDist(curr, queue); curr.visited = true; &#125; // 5. 移除当前顶点 queue.poll(); &#125; for (Vertex v : graph) &#123; System.out.println(v.name + &quot; &quot; + v.dist + &quot; &quot; + (v.prev != null ? v.prev.name : &quot;null&quot;)); &#125; &#125; private static void updateNeighboursDist(Vertex curr, PriorityQueue&lt;Vertex&gt; queue) &#123; for (Edge edge : curr.edges) &#123; Vertex n = edge.linked; if (!n.visited) &#123; int dist = curr.dist + edge.weight; if (dist &lt; n.dist) &#123; n.dist = dist; n.prev = curr; queue.offer(n); &#125; &#125; &#125; &#125;&#125; 问题 12345graph LRv1 --2--&gt; v2v1 --1--&gt; v3v2 --&quot;-2&quot;--&gt; v3v3 --1--&gt; v4 按照 Dijkstra 算法，得出 v1 -&gt; v2 最短距离2 v1 -&gt; v3 最短距离1 v1 -&gt; v4 最短距离2 事实应当是 v1 -&gt; v2 最短距离2 v1 -&gt; v3 最短距离0 v1 -&gt; v4 最短距离1 Bellman-Ford1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class BellmanFord &#123; public static void main(String[] args) &#123; // 正常情况 /*Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); Vertex v5 = new Vertex(&quot;v5&quot;); Vertex v6 = new Vertex(&quot;v6&quot;); v1.edges = List.of(new Edge(v3, 9), new Edge(v2, 7), new Edge(v6, 14)); v2.edges = List.of(new Edge(v4, 15)); v3.edges = List.of(new Edge(v4, 11), new Edge(v6, 2)); v4.edges = List.of(new Edge(v5, 6)); v5.edges = List.of(); v6.edges = List.of(new Edge(v5, 9)); List&lt;Vertex&gt; graph = List.of(v4, v5, v6, v1, v2, v3);*/ // 负边情况 /*Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); v1.edges = List.of(new Edge(v2, 2), new Edge(v3, 1)); v2.edges = List.of(new Edge(v3, -2)); v3.edges = List.of(new Edge(v4, 1)); v4.edges = List.of(); List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4);*/ // 负环情况 Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); v1.edges = List.of(new Edge(v2, 2)); v2.edges = List.of(new Edge(v3, -4)); v3.edges = List.of(new Edge(v4, 1), new Edge(v1, 1)); v4.edges = List.of(); List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4); bellmanFord(graph, v1); &#125; private static void bellmanFord(List&lt;Vertex&gt; graph, Vertex source) &#123; source.dist = 0; int size = graph.size(); // 1. 进行 顶点个数 - 1 轮处理 for (int i = 0; i &lt; size - 1; i++) &#123; // 2. 遍历所有的边 for (Vertex s : graph) &#123; for (Edge edge : s.edges) &#123; // 3. 处理每一条边 Vertex e = edge.linked; if (s.dist != Integer.MAX_VALUE &amp;&amp; s.dist + edge.weight &lt; e.dist) &#123; e.dist = s.dist + edge.weight; e.prev = s; &#125; &#125; &#125; &#125; for (Vertex v : graph) &#123; System.out.println(v + &quot; &quot; + (v.prev != null ? v.prev.name : &quot;null&quot;)); &#125; &#125;&#125; 负环 123456graph LRv1 --2--&gt; v2v2 --&quot;-4&quot;--&gt; v3v3 --1--&gt; v4v3 --1--&gt; v1 如果在【顶点-1】轮处理完成后，还能继续找到更短距离，表示发现了负环 Floyd-Warshall123456graph LRv1 --&quot;-2&quot;--&gt; v3v2 --&quot;4&quot;--&gt; v1v2 --&quot;3&quot;--&gt; v3v3 --2--&gt; v4v4 --&quot;-1&quot;--&gt; v2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class FloydWarshall &#123; public static void main(String[] args) &#123; Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); v1.edges = List.of(new Edge(v3, -2)); v2.edges = List.of(new Edge(v1, 4), new Edge(v3, 3)); v3.edges = List.of(new Edge(v4, 2)); v4.edges = List.of(new Edge(v2, -1)); List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4); /* 直接连通 v1 v2 v3 v4 v1 0 ∞ -2 ∞ v2 4 0 3 ∞ v3 ∞ ∞ 0 2 v4 ∞ -1 ∞ 0 k=0 借助v1到达其它顶点 v1 v2 v3 v4 v1 0 ∞ -2 ∞ v2 4 0 2 ∞ v3 ∞ ∞ 0 2 v4 ∞ -1 ∞ 0 k=1 借助v2到达其它顶点 v1 v2 v3 v4 v1 0 ∞ -2 ∞ v2 4 0 2 ∞ v3 ∞ ∞ 0 2 v4 3 -1 1 0 k=2 借助v3到达其它顶点 v1 v2 v3 v4 v1 0 ∞ -2 0 v2 4 0 2 4 v3 ∞ ∞ 0 2 v4 3 -1 1 0 k=3 借助v4到达其它顶点 v1 v2 v3 v4 v1 0 -1 -2 0 v2 4 0 2 4 v3 5 1 0 2 v4 3 -1 1 0 */ floydWarshall(graph); &#125; static void floydWarshall(List&lt;Vertex&gt; graph) &#123; int size = graph.size(); int[][] dist = new int[size][size]; Vertex[][] prev = new Vertex[size][size]; // 1）初始化 for (int i = 0; i &lt; size; i++) &#123; Vertex v = graph.get(i); // v1 (v3) Map&lt;Vertex, Integer&gt; map = v.edges.stream().collect(Collectors.toMap(e -&gt; e.linked, e -&gt; e.weight)); for (int j = 0; j &lt; size; j++) &#123; Vertex u = graph.get(j); // v3 if (v == u) &#123; dist[i][j] = 0; &#125; else &#123; dist[i][j] = map.getOrDefault(u, Integer.MAX_VALUE); prev[i][j] = map.get(u) != null ? v : null; &#125; &#125; &#125; print(prev); // 2）看能否借路到达其它顶点 /* v2-&gt;v1 v1-&gt;v? dist[1][0] + dist[0][0] dist[1][0] + dist[0][1] dist[1][0] + dist[0][2] dist[1][0] + dist[0][3] */ for (int k = 0; k &lt; size; k++) &#123; for (int i = 0; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123;// dist[i][k] + dist[k][j] // i行的顶点，借助k顶点，到达j列顶点// dist[i][j] // i行顶点，直接到达j列顶点 if (dist[i][k] != Integer.MAX_VALUE &amp;&amp; dist[k][j] != Integer.MAX_VALUE &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123; dist[i][j] = dist[i][k] + dist[k][j]; prev[i][j] = prev[k][j]; &#125; &#125; &#125;// print(dist); &#125; print(prev); &#125; static void path(Vertex[][] prev, List&lt;Vertex&gt; graph, int i, int j) &#123; LinkedList&lt;String&gt; stack = new LinkedList&lt;&gt;(); System.out.print(&quot;[&quot; + graph.get(i).name + &quot;,&quot; + graph.get(j).name + &quot;] &quot;); stack.push(graph.get(j).name); while (i != j) &#123; Vertex p = prev[i][j]; stack.push(p.name); j = graph.indexOf(p); &#125; System.out.println(stack); &#125; static void print(int[][] dist) &#123; System.out.println(&quot;-------------&quot;); for (int[] row : dist) &#123; System.out.println(Arrays.stream(row).boxed() .map(x -&gt; x == Integer.MAX_VALUE ? &quot;∞&quot; : String.valueOf(x)) .map(s -&gt; String.format(&quot;%2s&quot;, s)) .collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;))); &#125; &#125; static void print(Vertex[][] prev) &#123; System.out.println(&quot;-------------------------&quot;); for (Vertex[] row : prev) &#123; System.out.println(Arrays.stream(row).map(v -&gt; v == null ? &quot;null&quot; : v.name) .map(s -&gt; String.format(&quot;%5s&quot;, s)) .collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;))); &#125; &#125;&#125; 负环 如果在 3 层循环结束后，在 dist 数组的对角线处（i&#x3D;&#x3D;j 处）发现了负数，表示出现了负环 8) 最小生成树Prim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Prim &#123; public static void main(String[] args) &#123; Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); Vertex v5 = new Vertex(&quot;v5&quot;); Vertex v6 = new Vertex(&quot;v6&quot;); Vertex v7 = new Vertex(&quot;v7&quot;); v1.edges = List.of(new Edge(v2, 2), new Edge(v3, 4), new Edge(v4, 1)); v2.edges = List.of(new Edge(v1, 2), new Edge(v4, 3), new Edge(v5, 10)); v3.edges = List.of(new Edge(v1, 4), new Edge(v4, 2), new Edge(v6, 5)); v4.edges = List.of(new Edge(v1, 1), new Edge(v2, 3), new Edge(v3, 2), new Edge(v5, 7), new Edge(v6, 8), new Edge(v7, 4)); v5.edges = List.of(new Edge(v2, 10), new Edge(v4, 7), new Edge(v7, 6)); v6.edges = List.of(new Edge(v3, 5), new Edge(v4, 8), new Edge(v7, 1)); v7.edges = List.of(new Edge(v4, 4), new Edge(v5, 6), new Edge(v6, 1)); List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6, v7); prim(graph, v1); &#125; static void prim(List&lt;Vertex&gt; graph, Vertex source) &#123; ArrayList&lt;Vertex&gt; list = new ArrayList&lt;&gt;(graph); source.dist = 0; while (!list.isEmpty()) &#123; Vertex min = chooseMinDistVertex(list); updateNeighboursDist(min); list.remove(min); min.visited = true; System.out.println(&quot;---------------&quot;); for (Vertex v : graph) &#123; System.out.println(v); &#125; &#125; &#125; private static void updateNeighboursDist(Vertex curr) &#123; for (Edge edge : curr.edges) &#123; Vertex n = edge.linked; if (!n.visited) &#123; int dist = edge.weight; if (dist &lt; n.dist) &#123; n.dist = dist; n.prev = curr; &#125; &#125; &#125; &#125; private static Vertex chooseMinDistVertex(ArrayList&lt;Vertex&gt; list) &#123; Vertex min = list.get(0); for (int i = 1; i &lt; list.size(); i++) &#123; if (list.get(i).dist &lt; min.dist) &#123; min = list.get(i); &#125; &#125; return min; &#125;&#125; Kruskal1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class Kruskal &#123; static class Edge implements Comparable&lt;Edge&gt; &#123; List&lt;Vertex&gt; vertices; int start; int end; int weight; public Edge(List&lt;Vertex&gt; vertices, int start, int end, int weight) &#123; this.vertices = vertices; this.start = start; this.end = end; this.weight = weight; &#125; public Edge(int start, int end, int weight) &#123; this.start = start; this.end = end; this.weight = weight; &#125; @Override public int compareTo(Edge o) &#123; return Integer.compare(this.weight, o.weight); &#125; @Override public String toString() &#123; return vertices.get(start).name + &quot;&lt;-&gt;&quot; + vertices.get(end).name + &quot;(&quot; + weight + &quot;)&quot;; &#125; &#125; public static void main(String[] args) &#123; Vertex v1 = new Vertex(&quot;v1&quot;); Vertex v2 = new Vertex(&quot;v2&quot;); Vertex v3 = new Vertex(&quot;v3&quot;); Vertex v4 = new Vertex(&quot;v4&quot;); Vertex v5 = new Vertex(&quot;v5&quot;); Vertex v6 = new Vertex(&quot;v6&quot;); Vertex v7 = new Vertex(&quot;v7&quot;); List&lt;Vertex&gt; vertices = List.of(v1, v2, v3, v4, v5, v6, v7); PriorityQueue&lt;Edge&gt; queue = new PriorityQueue&lt;&gt;(List.of( new Edge(vertices,0, 1, 2), new Edge(vertices,0, 2, 4), new Edge(vertices,0, 3, 1), new Edge(vertices,1, 3, 3), new Edge(vertices,1, 4, 10), new Edge(vertices,2, 3, 2), new Edge(vertices,2, 5, 5), new Edge(vertices,3, 4, 7), new Edge(vertices,3, 5, 8), new Edge(vertices,3, 6, 4), new Edge(vertices,4, 6, 6), new Edge(vertices,5, 6, 1) )); kruskal(vertices.size(), queue); &#125; static void kruskal(int size, PriorityQueue&lt;Edge&gt; queue) &#123; List&lt;Edge&gt; result = new ArrayList&lt;&gt;(); DisjointSet set = new DisjointSet(size); while (result.size() &lt; size - 1) &#123; Edge poll = queue.poll(); int s = set.find(poll.start); int e = set.find(poll.end); if (s != e) &#123; result.add(poll); set.union(s, e); &#125; &#125; for (Edge edge : result) &#123; System.out.println(edge); &#125; &#125;&#125; 9) 不相交集合（并查集合）基础123456789101112131415161718192021222324252627282930313233343536public class DisjointSet &#123; int[] s; // 索引对应顶点 // 元素是用来表示与之有关系的顶点 /* 索引 0 1 2 3 4 5 6 元素 [0, 1, 2, 3, 4, 5, 6] 表示一开始顶点直接没有联系（只与自己有联系） */ public DisjointSet(int size) &#123; s = new int[size]; for (int i = 0; i &lt; size; i++) &#123; s[i] = i; &#125; &#125; // find 是找到老大 public int find(int x) &#123; if (x == s[x]) &#123; return x; &#125; return find(s[x]); &#125; // union 是让两个集合“相交”，即选出新老大，x、y 是原老大索引 public void union(int x, int y) &#123; s[y] = x; &#125; @Override public String toString() &#123; return Arrays.toString(s); &#125;&#125; 路径压缩123456public int find(int x) &#123; // x = 2 if (x == s[x]) &#123; return x; &#125; return s[x] = find(s[x]); // 0 s[2]=0&#125; Union By Size123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DisjointSetUnionBySize &#123; int[] s; int[] size; public DisjointSetUnionBySize(int size) &#123; s = new int[size]; this.size = new int[size]; for (int i = 0; i &lt; size; i++) &#123; s[i] = i; this.size[i] = 1; &#125; &#125; // find 是找到老大 - 优化：路径压缩 public int find(int x) &#123; // x = 2 if (x == s[x]) &#123; return x; &#125; return s[x] = find(s[x]); // 0 s[2]=0 &#125; // union 是让两个集合“相交”，即选出新老大，x、y 是原老大索引 public void union(int x, int y) &#123;// s[y] = x; if (size[x] &lt; size[y]) &#123; int t = x; x = y; y = t; &#125; s[y] = x; size[x] = size[x] + size[y]; &#125; @Override public String toString() &#123; return &quot;内容：&quot;+Arrays.toString(s) + &quot; 大小：&quot; + Arrays.toString(size); &#125; public static void main(String[] args) &#123; DisjointSetUnionBySize set = new DisjointSetUnionBySize(5); set.union(1, 2); set.union(3, 4); set.union(1, 3); System.out.println(set); &#125;&#125; 图-相关题目 题目编号 题目标题 算法思想 547 省份数量 DFS、BFS、并查集 797 所有可能路径 DFS、BFS 1584 连接所有点的最小费用 最小生成树 743 网络延迟时间 单源最短路径 787 K 站中转内最便宜的航班 单源最短路径 207 课程表 拓扑排序 210 课程表 II 拓扑排序 4.2 Greedy Algorithm1) 贪心例子称之为贪心算法或贪婪算法，核心思想是 将寻找最优解的问题分为若干个步骤 每一步骤都采用贪心原则，选取当前最优解 因为没有考虑所有可能，局部最优的堆叠不一定让最终解最优 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优(即最有利)的选择，从而希望导致结果是最好或最优的算法。这种算法通常用于求解优化问题，如最小生成树、背包问题等。 贪心算法的应用： 背包问题：给定一组物品和一个背包，每个物品有一定的重量和价值，要求在不超过背包容量的情况下，尽可能多地装入物品。 活动选择问题：在一个活动集合中，每次只能参加一个活动，问如何安排时间以最大化所有活动的收益。 编辑距离问题：给定两个字符串，求它们之间的最小编辑距离(即将一个字符串转换为另一个字符串所需的最少操作次数)。 网络流问题：给定一张有向图和一些起点和终点，求最大流量。 找零问题：给定一定数量的硬币和需要找零的金额，求使用最少的硬币数。 常见问题及解答： 贪心算法一定会找到最优解吗？答：不一定。贪心算法只保证在每一步选择中都是最优的，但并不能保证整个问题的最优解。例如，背包问题中的贪心算法可能会导致最后一个物品没有被装入背包。 如何判断一个问题是否适合用贪心算法解决？答：一个问题如果可以用递归的方式分解成若干个子问题，且每个子问题都有明确的最优解(即局部最优),那么这个问题就可以用贪心算法解决。 贪心算法的时间复杂度是多少？答：贪心算法的时间复杂度取决于问题的规模和具体实现。一般来说，对于规模较小的问题，贪心算法的时间复杂度可以达到O(nlogn)或O(n^2);对于规模较大的问题，可能需要O(n^3)或更高。 几个贪心的例子 Dijkstra1234567891011// ...while (!list.isEmpty()) &#123; // 选取当前【距离最小】的顶点 Vertex curr = chooseMinDistVertex(list); // 更新当前顶点邻居距离 updateNeighboursDist(curr); // 移除当前顶点 list.remove(curr); // 标记当前顶点已经处理过 curr.visited = true;&#125; 没找到最短路径的例子：负边存在时，可能得不到正确解 问题出在贪心的原则会认为本次已经找到了该顶点的最短路径，下次不会再处理它（curr.visited &#x3D; true） 与之对比，Bellman-Ford 并没有考虑局部距离最小的顶点，而是每次都处理所有边，所以不会出错，当然效率不如 Dijkstra Prim1234567891011// ...while (!list.isEmpty()) &#123; // 选取当前【距离最小】的顶点 Vertex curr = chooseMinDistVertex(list); // 更新当前顶点邻居距离 updateNeighboursDist(curr); // 移除当前顶点 list.remove(curr); // 标记当前顶点已经处理过 curr.visited = true;&#125; Kruskal123456789101112// ...while (list.size() &lt; size - 1) &#123; // 选取当前【距离最短】的边 Edge poll = queue.poll(); // 判断两个集合是否相交 int i = set.find(poll.start); int j = set.find(poll.end); if (i != j) &#123; // 未相交 list.add(poll); set.union(i, j); // 相交 &#125;&#125; 其它贪心的例子 选择排序、堆排序 拓扑排序 并查集合中的 union by size 和 union by height 哈夫曼编码 钱币找零，英文搜索关键字 change-making problem find Minimum number of Coins 任务编排 求复杂问题的近似解 2) 零钱兑换问题有几个解（零钱兑换 II）Leetcode 51812345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Leetcode518 &#123; public int change(int[] coins, int amount) &#123; return rec(0, coins, amount, new LinkedList&lt;&gt;(), true); &#125; /** * 求凑成剩余金额的解的个数 * * @param index 当前硬币索引 * @param coins 硬币面值数组 * @param remainder 剩余金额 * @param stack - * @param first - * @return 解的个数 */ public int rec(int index, int[] coins, int remainder, LinkedList&lt;Integer&gt; stack, boolean first) &#123; if(!first) &#123; stack.push(coins[index]); &#125; // 情况1：剩余金额 &lt; 0 - 无解 int count = 0; if (remainder &lt; 0) &#123; print(&quot;无解：&quot;, stack); &#125; // 情况2：剩余金额 == 0 - 有解 else if (remainder == 0) &#123; print(&quot;有解：&quot;, stack); count = 1; &#125; // 情况3：剩余金额 &gt; 0 - 继续递归 else &#123; for (int i = index; i &lt; coins.length; i++) &#123; count += rec(i, coins, remainder - coins[i], stack, false); &#125; &#125; if (!stack.isEmpty()) &#123; stack.pop(); &#125; return count; &#125; private static void print(String prompt, LinkedList&lt;Integer&gt; stack) &#123; ArrayList&lt;Integer&gt; print = new ArrayList&lt;&gt;(); ListIterator&lt;Integer&gt; iterator = stack.listIterator(stack.size()); while (iterator.hasPrevious()) &#123; print.add(iterator.previous()); &#125; System.out.println(prompt + print); &#125; public static void main(String[] args) &#123; Leetcode518 leetcode = new Leetcode518();// int count = leetcode.coinChange(new int[]&#123;1, 5, 10, 25&#125;, 41);// int count = leetcode.coinChange(new int[]&#123;25, 10, 5, 1&#125;, 41);// int count = leetcode.coinChange(new int[]&#123;5, 2, 1&#125;, 5);// int count = leetcode.coinChange(new int[]&#123;1, 2, 5&#125;, 5); int count = leetcode.change(new int[]&#123;15, 10, 1&#125;, 21); System.out.println(count); &#125;&#125; 最优解（零钱兑换）- 穷举法 Leetcode 3221234567891011121314151617181920212223242526272829303132333435363738394041public class Leetcode322 &#123; static int min = -1; // 需要的最少硬币数 2 3 public int coinChange(int[] coins, int amount) &#123; rec(0, coins, amount, new AtomicInteger(-1), new LinkedList&lt;&gt;(), true); return min; &#125; // count 代表某一组合 钱币的总数 public void rec(int index, int[] coins, int remainder, AtomicInteger count, LinkedList&lt;Integer&gt; stack, boolean first) &#123; if (!first) &#123; stack.push(coins[index]); &#125; count.incrementAndGet(); // count++ if (remainder == 0) &#123; System.out.println(stack); if (min == -1) &#123; min = count.get(); &#125; else &#123; min = Integer.min(min, count.get()); &#125; &#125; else if (remainder &gt; 0) &#123; for (int i = index; i &lt; coins.length; i++) &#123; rec(i, coins, remainder - coins[i], count, stack, false); &#125; &#125; count.decrementAndGet(); // count-- if (!stack.isEmpty()) &#123; stack.pop(); &#125; &#125; public static void main(String[] args) &#123; Leetcode322 leetcode = new Leetcode322();// int count = leetcode.coinChange(new int[]&#123;5, 2, 1&#125;, 5); int count = leetcode.coinChange(new int[]&#123;25, 10, 5, 1&#125;, 41);// int count = leetcode.coinChange(new int[]&#123;2&#125;, 3);// int count = leetcode.coinChange(new int[]&#123;15, 10, 1&#125;, 21); System.out.println(count); &#125;&#125; 最优解（零钱兑换）- 贪心法 Leetcode 3221234567891011121314151617181920212223242526272829303132333435public class Leetcode322 &#123; public int coinChange(int[] coins, int amount) &#123; int remainder = amount; int count = 0; for (int coin : coins) &#123; while (remainder - coin &gt; 0) &#123; remainder -= coin; count++; &#125; if (remainder - coin == 0) &#123; remainder = 0; count++; break; &#125; &#125; if (remainder &gt; 0) &#123; return -1; &#125; else &#123; return count; &#125; &#125; public static void main(String[] args) &#123; Leetcode322 leetcode = new Leetcode322(); int count = leetcode.coinChange(new int[]&#123;5, 2, 1&#125;, 5);// int count = leetcode.coinChange(new int[]&#123;25, 10, 5, 1&#125;, 41);// int count = leetcode.coinChange(new int[]&#123;2&#125;, 3); // 问题1 没有回头，导致找到更差的解// int count = leetcode.coinChange(new int[]&#123;15, 10, 1&#125;, 21); // 问题2 没有回头，导致无解// int count = leetcode.coinChange(new int[]&#123;15, 10&#125;, 20); System.out.println(count); &#125;&#125; 3) Huffman 编码问题问题引入什么是编码？ 简单说就是建立【字符】到【数字】的对应关系，如下面大家熟知的 ASC II 编码表，例如，可以查表得知字符【a】对应的数字是十六进制数【0x61】 \\ 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 0000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 0010 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 0020 20 ! “ # $ % &amp; ‘ ( ) * + , - . &#x2F; 0030 0 1 2 3 4 5 6 7 8 9 : ; &lt; &#x3D; &gt; ? 0040 @ A B C D E F G H I J K L M N O 0050 P Q R S T U V W X Y Z [ \\ ] ^ _ 0060 &#96; a b c d e f g h i j k l m n o 0070 p q r s t u v w x y z { | } ~ 7f 注：一些直接以十六进制数字标识的是那些不可打印字符 传输时的编码 java 中每个 char 对应的数字会占用固定长度 2 个字节 如果在传输中仍采用上述规则，传递 abbccccccc 这 10 个字符 实际的字节为 0061006200620063006300630063006300630063（16进制表示） 总共 20 个字节，不经济 现在希望找到一种最节省字节的传输方式，怎么办？ 假设传输的字符中只包含 a，b，c 这 3 个字符，有同学重新设计一张二进制编码表，见下图 0 表示 a 1 表示 b 10 表示 c 现在还是传递 abbccccccc 这 10 个字符 实际的字节为 01110101010101010 （二进制表示） 总共需要 17 bits，也就是 2 个字节多一点，行不行？ 不行，因为解码会出现问题，因为 10 会被错误的解码成 ba，而不是 c 解码后结果为 abbbababababababa，是错误的 怎么解决？必须保证编码后的二进制数字，要能区分它们的前缀（prefix-free） 用满二叉树结构编码，可以确保前缀不重复 向左走 0，向右走 1 走到叶子字符，累计起来的 0 和 1 就是该字符的二进制编码 再来试一遍 a 的编码 0 b 的编码 10 c 的编码 11 现在还是传递 abbccccccc 这 10 个字符 实际的字节为 0101011111111111111（二进制表示） 总共需要 19 bits，也是 2 个字节多一点，并且解码没有问题了，行不行？ 这回解码没问题了，但并非最少字节，因为 c 的出现频率高（7 次）a 的出现频率低（1 次），因此出现频率高的字符编码成短数字更经济 考察下面的树 00 表示 a 01 表示 b 1 表示 c 现在还是传递 abbccccccc 这 10 个字符 实际的字节为 000101 1111111 （二进制表示） 总共需要 13 bits，这棵树就称之为 Huffman 树 根据 Huffman 树对字符和数字进行编解码，就是 Huffman 编解码 Huffman 树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class HuffmanTree &#123; /* Huffman 树的构建过程 1. 将统计了出现频率的字符，放入优先级队列 2. 每次出队两个频次最低的元素，给它俩找个爹 3. 把爹重新放入队列，重复 2~3 4. 当队列只剩一个元素时，Huffman 树构建完成 */ static class Node &#123; Character ch; // 字符 int freq; // 频次 Node left; Node right; String code; // 编码 public Node(Character ch) &#123; this.ch = ch; &#125; public Node(int freq, Node left, Node right) &#123; this.freq = freq; this.left = left; this.right = right; &#125; int freq() &#123; return freq; &#125; boolean isLeaf() &#123; return left == null; &#125; @Override public String toString() &#123; return &quot;Node&#123;&quot; + &quot;ch=&quot; + ch + &quot;, freq=&quot; + freq + &#x27;&#125;&#x27;; &#125; &#125; String str; Map&lt;Character, Node&gt; map = new HashMap&lt;&gt;(); public HuffmanTree(String str) &#123; this.str = str; // 功能1：统计频率 char[] chars = str.toCharArray(); for (char c : chars) &#123; /*if (!map.containsKey(c)) &#123; map.put(c, new Node(c)); &#125; Node node = map.get(c); node.freq++;*/ Node node = map.computeIfAbsent(c, Node::new); node.freq++; &#125; // 功能2: 构造树 PriorityQueue&lt;Node&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(Node::freq)); queue.addAll(map.values()); while (queue.size() &gt;= 2) &#123; Node x = queue.poll(); Node y = queue.poll(); int freq = x.freq + y.freq; queue.offer(new Node(freq, x, y)); &#125; Node root = queue.poll(); // 功能3：计算每个字符的编码, 功能4：字符串编码后占用 bits int sum = dfs(root, new StringBuilder()); for (Node node : map.values()) &#123; System.out.println(node + &quot; &quot; + node.code); &#125; System.out.println(&quot;总共会占用 bits:&quot; + sum); &#125; private int dfs(Node node, StringBuilder code) &#123; int sum = 0; if (node.isLeaf()) &#123; node.code = code.toString(); sum = node.freq * code.length(); &#125; else &#123; sum += dfs(node.left, code.append(&quot;0&quot;)); sum += dfs(node.right, code.append(&quot;1&quot;)); &#125; if (code.length() &gt; 0) &#123; code.deleteCharAt(code.length() - 1); &#125; return sum; &#125; public static void main(String[] args) &#123; new HuffmanTree(&quot;abbccccccc&quot;); &#125;&#125; 注意 Node::new 是一个 Function，根据 key（即字符）生成 Node 对象 对应的是 public Node(Character ch) 有参构造 Huffman 编解码补充两个方法，注意为了简单期间用了编解码都用字符串演示，实际应该按 bits 编解码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HuffmanTree &#123; // ... // 编码 public String encode() &#123; char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(); for (char c : chars) &#123; sb.append(map.get(c).code); &#125; return sb.toString(); &#125; // 解码 public String decode(String str) &#123; /* 从根节点，寻找数字对应的字符 数字是 0 向左走 数字是 1 向右走 如果没走到头，每走一步数字的索引 i++ 走到头就可以找到解码字符，再将 node 重置为根节点 */ char[] chars = str.toCharArray(); int i = 0; StringBuilder sb = new StringBuilder(); Node node = root; while (i &lt; chars.length) &#123; if (!node.isLeaf()) &#123; // 非叶子 if(chars[i] == &#x27;0&#x27;) &#123; // 向左走 node = node.left; &#125; else if(chars[i] == &#x27;1&#x27;) &#123; // 向右走 node = node.right; &#125; i++; &#125; if (node.isLeaf()) &#123; sb.append(node.ch); node = root; &#125; &#125; return sb.toString(); &#125; @SuppressWarnings(&quot;all&quot;) public static void main(String[] args) &#123; HuffmanTree tree = new HuffmanTree(&quot;abbccccccc&quot;); String encoded = tree.encode(); System.out.println(encoded); System.out.println(tree.decode(encoded)); &#125;&#125; 注意 循环中非叶子节点 i 要自增，但叶子节点 i 暂不自增 第一个非叶子的 if 判断结束后，仍需要第二个叶子的 if 判断，因为在第一个 if 内 node 发生了变化 相关题目 题目编号 题目标题 算法思路 1167（Plus 题目） 连接棒材的最低费用 Huffman 树、贪心 参考解答 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * &lt;h3&gt;连接棒材的最低费用&lt;/h3&gt; * &lt;p&gt;为了装修新房，你需要加工一些长度为正整数的棒材。如果要将长度分别为 X 和 Y 的两根棒材连接在一起，你需要支付 X + Y 的费用。 返回讲所有棒材连成一根所需要的最低费用。&lt;/p&gt; */public class Leetcode1167 &#123; /* 举例 棒材为 [1,8,3,5] 如果以如下顺序连接(非最优) - 1+8=9 - 9+3=12 - 12+5=17 总费用为 9+12+17=38 如果以如下顺序连接(最优) - 1+3=4 - 4+5=9 - 8+9=17 总费用为 4+9+17=30 */ int connectSticks(int[] sticks) &#123; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for (int stick : sticks) &#123; queue.offer(stick); &#125; int sum = 0; while (queue.size() &gt;= 2) &#123; Integer x = queue.poll(); Integer y = queue.poll(); int c = x + y; sum += c; queue.offer(c); &#125; return sum; &#125; public static void main(String[] args) &#123; Leetcode1167 leetcode = new Leetcode1167(); System.out.println(leetcode.connectSticks(new int[]&#123;1, 8, 3, 5&#125;)); // 30 System.out.println(leetcode.connectSticks(new int[]&#123;2, 4, 3&#125;)); // 14 &#125;&#125; 4) 活动选择问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class ActivitySelectionProblem &#123; /* 要在一个会议室举办 n 个活动 - 每个活动有它们各自的起始和结束时间 - 找出在时间上互不冲突的活动组合，能够最充分利用会议室（举办的活动次数最多） 例1 0 1 2 3 4 5 6 7 8 9 |-------) |-------) |-------) 例2 0 1 2 3 4 5 6 7 8 9 |---) |---) |-----------------------) |-------) |---) |---------------) 几种贪心策略 1. 优先选择持续时间最短的活动 0 1 2 3 4 5 6 7 8 9 |---------------) |-------) |---------------) 2. 优先选择冲突最少的活动 0 1 2 3 4 5 6 7 8 9 |-------) 3 |-------) 4 |-------) 4 |-------) 4 |-------) 4 |-------) 2 |-----------) 4 |-------) 4 |-------) 4 |-------) 4 |-------) 3 3. 优先选择最先开始的活动 0 1 2 3 4 5 6 7 8 9 |-----------------------------------) |---) |---) |---) 4. 优先选择最后结束的活动 */ static class Activity &#123; int index; int start; int finish; public Activity(int index, int start, int finish) &#123; this.index = index; this.start = start; this.finish = finish; &#125; @Override public String toString() &#123; return &quot;Activity(&quot; + index + &quot;)&quot;; &#125; &#125; public static void main(String[] args) &#123; Activity[] activities = new Activity[]&#123; new Activity(0, 1, 3), new Activity(1, 2, 4), new Activity(2, 3, 5) &#125;;// Activity[] activities = new Activity[]&#123;// new Activity(0, 1, 2),// new Activity(1, 3, 4),// new Activity(2, 0, 6),// new Activity(3, 5, 7),// new Activity(4, 8, 9),// new Activity(5, 5, 9)// &#125;; select(activities, activities.length); &#125; public static void select(Activity[] activities, int n) &#123; List&lt;Activity&gt; result = new ArrayList&lt;&gt;(); int i, j; i = 0; result.add(activities[i]); for (j = 1; j &lt; n; j++) &#123; if (activities[j].start &gt;= activities[i].finish) &#123; result.add(activities[j]); i = j; &#125; &#125; System.out.println(result); &#125;&#125; 无重叠区间-Leetcode 435 题目编号 题目标题 算法思路 435 无重叠区间 贪心 参考解答 1234567891011121314// 下面代码为 Leetcode 435 题解public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[1])); int i, j; i = 0; int count = 1; for (j = 1; j &lt; intervals.length; j++) &#123; if (intervals[j][0] &gt;= intervals[i][1]) &#123; i = j; count++; &#125; &#125; return intervals.length - count;&#125; 找到不重叠的最多的活动数（count），即活动选择问题原始需求 在此基础上，活动总数 - count，就是题目要的排除数量 5) 分数背包问题贪心法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class FractionalKnapsackProblem &#123; /* 1. n个物品都是液体，有重量和价值 2. 现在你要取走 10升 的液体 3. 每次可以不拿，全拿，或拿一部分，问最高价值是多少 编号 重量(升) 价值 0 4 24 水 1 8 160 牛奶 选中 7/8 2 2 4000 五粮液 选中 3 6 108 可乐 4 1 4000 茅台 选中 8140 简化起见，给出的数据都是【价值/重量】能够整除，避免计算结果中出现小数，增加心算难度 */ static class Item &#123; int index; int weight; int value; public Item(int index, int weight, int value) &#123; this.index = index; this.weight = weight; this.value = value; &#125; int unitPrice() &#123; return value / weight; &#125; @Override public String toString() &#123; return &quot;Item(&quot; + index + &quot;)&quot;; &#125; &#125; public static void main(String[] args) &#123; Item[] items = new Item[]&#123; new Item(0, 4, 24), new Item(1, 8, 160), new Item(2, 2, 4000), new Item(3, 6, 108), new Item(4, 1, 4000), &#125;; select(items, 10); &#125; static void select(Item[] items, int total) &#123; Arrays.sort(items, Comparator.comparingInt(Item::unitPrice).reversed()); int remainder = total; int max = 0; for (Item item : items) &#123; if (remainder - item.weight &gt; 0) &#123; max += item.value; remainder -= item.weight; &#125; else &#123; max += remainder * item.unitPrice(); break; &#125; &#125; System.out.println(&quot;最高价值为：&quot; + max); &#125;&#125; 6) 0-1 背包问题贪心法可能得不到最优解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class KnapsackProblem &#123; /* 1. n个物品都是固体，有重量和价值 2. 现在你要取走不超过 10克 的物品 3. 每次可以不拿或全拿，问最高价值是多少 编号 重量(g) 价值(元) 0 1 1_000_000 钻戒一枚 1 4 1600 黄金一块 2 8 2400 红宝石戒指一枚 3 5 30 白银一块 */ static class Item &#123; int index; int weight; int value; public Item(int index, int weight, int value) &#123; this.index = index; this.weight = weight; this.value = value; &#125; public int unitValue() &#123; return value / weight; &#125; @Override public String toString() &#123; return &quot;Item(&quot; + index + &quot;)&quot;; &#125; &#125; public static void main(String[] args) &#123; Item[] items = new Item[]&#123; new Item(0, 1, 1_000_000), new Item(1, 4, 1600), new Item(2, 8, 2400), new Item(3, 5, 30) &#125;; select(items, 10); &#125; static void select(Item[] items, int total) &#123; Arrays.sort(items, Comparator.comparingInt(Item::unitValue).reversed()); int max = 0; // 最大价值 for (Item item : items) &#123; System.out.println(item); if (total &gt;= item.weight) &#123; // 可以拿完 total -= item.weight; max += item.value; &#125; else &#123; // 拿不完// max += total * item.unitValue();// break; &#125; &#125; System.out.println(&quot;最大价值是:&quot; + max); &#125;&#125; 贪心算法的局限 问题名称 是否能用贪心得到最优解 替换解法 Dijkstra(不存在负边) ✔️ Dijkstra(存在负边) ❌ Bellman-Ford Prim ✔️ Kruskal ✔️ 零钱兑换 ❌ 动态规划 Huffman 树 ✔️ 活动选择问题 ✔️ 分数背包问题 ✔️ 0-1 背包问题 ❌ 动态规划 7) Set cover problem集合覆盖问题 4.3 Dynamic-Programming1) Fibonacci123456789101112131415161718public class Fibonacci &#123; public static void main(String[] args) &#123; System.out.println(fibonacci(13)); &#125; public static int fibonacci(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; if (n &lt; 2) &#123; return dp[n]; &#125; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 2] + dp[i - 1]; &#125; return dp[n]; &#125;&#125; 降维12345678910111213141516171819202122public class Fibonacci &#123; public static void main(String[] args) &#123; System.out.println(fibonacci(13)); &#125; public static int fibonacci(int n) &#123; if (n == 0) &#123; return 0; &#125; if (n == 1) &#123; return 1; &#125; int a = 0; int b = 1; for (int i = 2; i &lt;= n; i++) &#123; int c = b + a; a = b; b = c; &#125; return b; &#125;&#125; 2) 最短路径 - Bellman-Ford12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class BellmanFord &#123; static class Edge &#123; int from; int to; int weight; public Edge(int from, int to, int weight) &#123; this.from = from; this.to = to; this.weight = weight; &#125; &#125; /* f(v) 用来表示从起点出发，到达 v 这个顶点的最短距离 初始时 f(v) = 0 当 v==起点 时 f(v) = ∞ 当 v!=起点 时 之后 新 旧 所有from f(to) = min(f(to), f(from) + from.weight) from 从哪来 to 到哪去 f(v4) = min( ∞, f(v3) + 11 ) = 20 f(v4) = min( 20, f(v2) + 15 ) = 20 v1 v2 v3 v4 v5 v6 0 ∞ ∞ ∞ ∞ ∞ 0 7 9 ∞ ∞ 14 第一轮 0 7 9 20 23 11 第二轮 0 7 9 20 20 11 第三轮 0 7 9 20 20 11 第四轮 0 7 9 20 20 11 第五轮 */ public static void main(String[] args) &#123; List&lt;Edge&gt; edges = List.of( new Edge(6, 5, 9), new Edge(4, 5, 6), new Edge(1, 6, 14), new Edge(3, 6, 2), new Edge(3, 4, 11), new Edge(2, 4, 15), new Edge(1, 3, 9), new Edge(1, 2, 7) ); int[] dp = new int[7]; // 一维数组用来缓存结果 dp[1] = 0; for (int i = 2; i &lt; dp.length; i++) &#123; dp[i] = Integer.MAX_VALUE; &#125; print(dp); for (int i = 0; i &lt; 5; i++) &#123; for (Edge e : edges) &#123; if(dp[e.from] != Integer.MAX_VALUE) &#123; dp[e.to] = Integer.min(dp[e.to], dp[e.from] + e.weight); &#125; &#125; &#125; print(dp); &#125; static void print(int[] dp) &#123; System.out.println(Arrays.stream(dp) .mapToObj(i -&gt; i == Integer.MAX_VALUE ? &quot;∞&quot; : String.valueOf(i)) .collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;))); &#125;&#125; 3) 不同路径-Leetcode 62机器人要从左上角走到右下角，每次只能向右或向下，问一共有多少条不同路径？ 分析，先考虑较为简单的情况 可能路径有三种情况： 👉 👇 👇 👇 👇👉 👇👉👇 分析：设坐标为，共有 m 行 n 列 123(0,0)\t(0,1)(1,0)\t(1,1)(2,0)\t(2,1) 如果终点是 (0,1) 那么只有一种走法 如果终点是 (1,0) 那么也只有一种走法 如果终点是 (1,1) 呢，它的走法是从它的上方走下来，或者从它的左边走过来，因此走法 &#x3D; (0,1) + (1,0) &#x3D; 2种 如果终点是 (2,0) 那么也只有一种走法 如果终点是 (2,1) 呢，它的走法是从它的上方走下来，或者从它的左边走过来，因此走法 &#x3D; (1,1) + (2,0) &#x3D; 3种 总结规律发现： 终点是 (0,1) (0,2) (0,3) … (0,n) 走法只有1种 终点是 (1,0) (2,0) (3,0) … (m,0) 走法也只有1种 除了上面两种情况以外，(i,j) 处的走法等于(i-1,j) + (i,j-1) 的走法之和，即为递推公式 画表格 1230\t1\t1\t1\t1\t1\t11\t2\t3\t4\t5\t6\t71\t3\t6\t10\t15\t21\t28 题解 12345678910111213141516171819202122public class UniquePaths &#123; public static void main(String[] args) &#123; int count = new UniquePaths().uniquePaths(3, 7); System.out.println(count); &#125; public int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; dp[i][0] = 1; &#125; for (int j = 0; j &lt; n; j++) &#123; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 降维123456789101112131415161718public class UniquePaths &#123; public static void main(String[] args) &#123; int count = new UniquePaths().uniquePaths(3, 7); System.out.println(count); &#125; public int uniquePaths(int m, int n) &#123; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; m; i++) &#123; dp[0] = 1; for (int j = 1; j &lt; n; j++) &#123; dp[j] = dp[j] + dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125; 类似于不规则的杨辉三角 4) 0-1 背包问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class KnapsackProblem &#123; /* 1. n个物品都是固体，有重量和价值 2. 现在你要取走不超过 10克 的物品 3. 每次可以不拿或全拿，问最高价值是多少 编号 重量(g) 价值(元) 简称 1 4 1600 黄金一块 400 A 2 8 2400 红宝石一粒 300 R 3 5 30 白银一块 S 0 1 1_000_000 钻石一粒 D 1_001_630 1_002_400 */ /* 1 2 3 4 5 6 7 8 9 10 a a r a r d da da dr dr */ static class Item &#123; int index; String name; int weight; int value; public Item(int index, String name, int weight, int value) &#123; this.index = index; this.name = name; this.weight = weight; this.value = value; &#125; @Override public String toString() &#123; return &quot;Item(&quot; + name + &quot;)&quot;; &#125; &#125; public static void main(String[] args) &#123; Item[] items = new Item[]&#123; new Item(1, &quot;黄金&quot;, 4, 1600), new Item(2, &quot;宝石&quot;, 8, 2400), new Item(3, &quot;白银&quot;, 5, 30), new Item(4, &quot;钻石&quot;, 1, 10_000), &#125;; System.out.println(select(items, 10)); &#125; static int select(Item[] items, int total) &#123; int[][] dp = new int[items.length][total + 1]; print(dp); Item item0 = items[0]; for (int j = 0; j &lt; total + 1; j++) &#123; if (j &gt;= item0.weight) &#123; dp[0][j] = item0.value; &#125; &#125; print(dp); for (int i = 1; i &lt; dp.length; i++) &#123; Item item = items[i]; for (int j = 1; j &lt; total + 1; j++) &#123; // x: 上一次同容量背包的最大价值 int x = dp[i - 1][j]; if (j &gt;= item.weight) &#123; // j-item.weight: 当前背包容量-这次物品重量=剩余背包空间 // y: 剩余背包空间能装下的最大价值 + 这次物品价值 int y = dp[i - 1][j - item.weight] + item.value; dp[i][j] = Integer.max(x, y); &#125; else &#123; dp[i][j] = x; &#125; &#125; print(dp); &#125; return dp[dp.length - 1][total]; &#125; static void print(int[][] dp) &#123; System.out.println(&quot; &quot; + &quot;-&quot;.repeat(63)); Object[] array = IntStream.range(0, dp[0].length + 1).boxed().toArray(); System.out.printf((&quot;%5d &quot;.repeat(dp[0].length)) + &quot;%n&quot;, array); for (int[] d : dp) &#123; array = Arrays.stream(d).boxed().toArray(); System.out.printf((&quot;%5d &quot;.repeat(d.length)) + &quot;%n&quot;, array); &#125; &#125;&#125; 降维123456789101112static int select(Item[] items, int total) &#123; int[] dp = new int[total + 1]; for (Item item : items) &#123; for (int j = total; j &gt; 0; j--) &#123; if (j &gt;= item.weight) &#123; // 装得下 dp[j] = Integer.max(dp[j], item.value + dp[j - item.weight]); &#125; &#125; System.out.println(Arrays.toString(dp)); &#125; return dp[total];&#125; 注意：内层循环需要倒序，否则 dp[j - item.weight] 的结果会被提前覆盖 5) 完全背包问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class KnapsackProblemComplete &#123; static class Item &#123; int index; String name; int weight; int value; public Item(int index, String name, int weight, int value) &#123; this.index = index; this.name = name; this.weight = weight; this.value = value; &#125; @Override public String toString() &#123; return &quot;Item(&quot; + name + &quot;)&quot;; &#125; &#125; public static void main(String[] args) &#123; Item[] items = new Item[]&#123; new Item(1, &quot;青铜&quot;, 2, 3), // c new Item(2, &quot;白银&quot;, 3, 4), // s new Item(3, &quot;黄金&quot;, 4, 7), // a &#125;; System.out.println(select(items, 6)); &#125; /* 0 1 2 3 4 5 6 1 0 0 c c cc cc ccc 2 0 0 c s cc cs ccc 3 0 0 c s a a ac */ private static int select(Item[] items, int total) &#123; int[][] dp = new int[items.length][total + 1]; Item item0 = items[0]; for (int j = 0; j &lt; total + 1; j++) &#123; if (j &gt;= item0.weight) &#123; dp[0][j] = dp[0][j - item0.weight] + item0.value; &#125; &#125; print(dp); for (int i = 1; i &lt; items.length; i++) &#123; Item item = items[i]; for (int j = 1; j &lt; total + 1; j++) &#123; // x: 上一次同容量背包的最大价值 int x = dp[i - 1][j]; if (j &gt;= item.weight) &#123; // j-item.weight: 当前背包容量-这次物品重量=剩余背包空间 // y: 剩余背包空间能装下的最大价值 + 这次物品价值 int y = dp[i][j - item.weight] + item.value; dp[i][j] = Integer.max(x, y); &#125; else &#123; dp[i][j] = x; &#125; &#125; print(dp); &#125; return dp[dp.length - 1][total]; &#125; static void print(int[][] dp) &#123; System.out.println(&quot; &quot; + &quot;-&quot;.repeat(63)); Object[] array = IntStream.range(0, dp[0].length + 1).boxed().toArray(); System.out.printf((&quot;%5d &quot;.repeat(dp[0].length)) + &quot;%n&quot;, array); for (int[] d : dp) &#123; array = Arrays.stream(d).boxed().toArray(); System.out.printf((&quot;%5d &quot;.repeat(d.length)) + &quot;%n&quot;, array); &#125; &#125;&#125; 降维123456789101112private static int select(Item[] items, int total) &#123; int[] dp = new int[total + 1]; for (Item item : items) &#123; for (int j = 0; j &lt; total + 1; j++) &#123; if (j &gt;= item.weight) &#123; dp[j] = Integer.max(dp[j], dp[j - item.weight] + item.value); &#125; &#125; System.out.println(Arrays.toString(dp)); &#125; return dp[total];&#125; 6) 零钱兑换问题-Leetcode322123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ChangeMakingProblemLeetcode322 &#123; public int coinChange(int[] coins, int amount) &#123; int max = amount + 1; int[][] dp = new int[coins.length][amount + 1]; for (int j = 1; j &lt; amount + 1; j++) &#123; if (j &gt;= coins[0]) &#123; dp[0][j] = 1 + dp[0][j - coins[0]]; &#125; else &#123; dp[0][j] = max; &#125; &#125; for (int i = 1; i &lt; coins.length; i++) &#123; for (int j = 1; j &lt; amount + 1; j++) &#123; if (j &gt;= coins[i]) &#123; dp[i][j] = Math.min(dp[i - 1][j], 1 + dp[i][j - coins[i]]); &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; print(dp); &#125; int r = dp[coins.length - 1][amount]; return r &gt; amount ? -1 : r; &#125; public static void main(String[] args) &#123; ChangeMakingProblemLeetcode322 leetcode = new ChangeMakingProblemLeetcode322(); int count = leetcode.coinChange(new int[]&#123;1, 2, 5&#125;, 5);// int count = leetcode.coinChange(new int[]&#123;25, 10, 5, 1&#125;, 41);// int count = leetcode.coinChange(new int[]&#123;2&#125;, 3);// int count = leetcode.coinChange(new int[]&#123;15, 10, 1&#125;, 21); System.out.println(count); &#125; static void print(int[][] dp) &#123; System.out.println(&quot;-&quot;.repeat(18)); Object[] array = IntStream.range(0, dp[0].length + 1).boxed().toArray(); System.out.printf((&quot;%2d &quot;.repeat(dp[0].length)) + &quot;%n&quot;, array); for (int[] d : dp) &#123; array = Arrays.stream(d).boxed().toArray(); System.out.printf((&quot;%2d &quot;.repeat(d.length)) + &quot;%n&quot;, array); &#125; &#125;&#125; 降维123456789101112public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); dp[0] = 0; for (int coin : coins) &#123; for (int j = coin; j &lt; amount + 1; j++) &#123; dp[j] = Math.min(dp[j], 1 + dp[j - coin]); &#125; &#125; int r = dp[amount]; return r &gt; amount ? -1 : r;&#125; 零钱兑换 II-Leetcode 5181234567891011121314151617181920212223242526272829303132public class ChangeMakingProblemLeetcode518 &#123; /* 面值 0 1 2 3 4 5 1 1 1 1 1 1 1 2 1 1 2 2 3 3 5 1 1 2 2 3 4 面值 0 1 2 3 1 0 0 0 2 1 0 1 0 */ public int change(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) &#123; for (int j = coin; j &lt; amount + 1; j++) &#123; dp[j] = dp[j] + dp[j - coin]; &#125; &#125; return dp[amount]; &#125; public static void main(String[] args) &#123; ChangeMakingProblemLeetcode518 leetcode = new ChangeMakingProblemLeetcode518(); int count = leetcode.change(new int[]&#123;1, 2, 5&#125;, 5); System.out.println(count); &#125;&#125; 7) 钢条切割问题1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CutRodProblem &#123; /* 1 5 8 9 0 1 2 3 4 1 1 11 111 1111 (1) (2) (3) (4) 2 11 111 1111 2 21 211 22 (1) (5) (6) (10) 3 1 11 111 1111 2 21 211 3 22 31 (1) (5) (8) (10) 4 1 11 111 1111 2 21 211 3 22 31 4 (1) (5) (8) (10) */ static int cut(int[] values, int n) &#123; int[][] dp = new int[values.length][n + 1]; for (int i = 1; i &lt; values.length; i++) &#123; int v = values[i]; for (int j = 1; j &lt; n + 1; j++) &#123; if (j &gt;= i) &#123; dp[i][j] = Integer.max(dp[i - 1][j], v + dp[i][j - i]); &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; print(dp); &#125; return dp[values.length - 1][n]; &#125; public static void main(String[] args) &#123; System.out.println(cut(new int[]&#123;0, 1, 5, 8, 9&#125;, 4)); &#125;&#125; 降维1234567891011static int cut(int[] values, int n) &#123; int[] dp = new int[n + 1]; for (int i = 1; i &lt; values.length; i++) &#123; int v = values[i]; for (int j = i; j &lt; n + 1; j++) &#123; dp[j] = Integer.max(dp[j], v + dp[j - i]); &#125; System.out.println(Arrays.toString(dp)); &#125; return dp[n];&#125; 本质上是完全背包问题，把钢条总长度看作背包容量，切分后的钢条看作物品。只是 此时的背包容量&#x3D;物品数量，例如，钢条总长度为4，可以看作有四种物品： 长度1的钢条 长度2的钢条 长度3的钢条 长度4的钢条 另外，这个场景下，总能装满背包 类似题目 Leetcode-343 整数拆分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Leetcode343 &#123; /* 0 1 2 3 4 1 1 1 11 111 1111 2 1 1 11 111 1111 2 21 211 22 (1) (2) (2) (4) 3 1 1 11 111 1111 2 21 211 3 22 31 (1) (2) (3) (4) 4 1 1 11 111 1111 2 21 211 3 22 31 4 (1) (2) (3) (4) */ public int integerBreak(int n) &#123; int[] dp = new int[n + 1]; Arrays.fill(dp, 1); dp[0] = 1; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; n + 1; j++) &#123; if (j &gt;= i) &#123; dp[j] = Integer.max(dp[j], i * dp[j - i]); &#125; &#125; System.out.println(Arrays.toString(dp)); &#125; return dp[n]; &#125; public int integerBreak2(int n) &#123; int[][] dp = new int[n][n + 1]; Arrays.fill(dp[0], 1); for (int i = 1; i &lt; n; i++) &#123; dp[i][0] = 1; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; n + 1; j++) &#123; if (j &gt;= i) &#123; dp[i][j] = Integer.max(dp[i - 1][j], i * dp[i][j - i]); &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; print(dp); &#125; return dp[n - 1][n]; &#125; public static void main(String[] args) &#123; Leetcode343 code = new Leetcode343(); System.out.println(code.integerBreak(4)); System.out.println(code.integerBreak(10)); &#125;&#125; 8) 最长公共子串123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LCSubstring &#123; static int lcs(String a, String b) &#123; int[][] dp = new int[b.length()][a.length()]; int max = 0; for (int i = 0; i &lt; b.length(); i++) &#123; for (int j = 0; j &lt; a.length(); j++) &#123; if (a.charAt(j) == b.charAt(i)) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; max = Integer.max(dp[i][j], max); &#125; else &#123; dp[i][j] = 0; &#125; &#125; &#125; print(dp, a, b); return max; &#125; static void print(int[][] dp, String a, String b) &#123; System.out.println(&quot;-&quot;.repeat(23)); Object[] array = a.chars().mapToObj(i -&gt; String.valueOf((char) i)).toArray(); System.out.printf(&quot; &quot;+&quot;%2s &quot;.repeat(a.length()) + &quot;%n&quot;, array); for (int i = 0; i &lt; b.length(); i++) &#123; int[] d = dp[i]; array = Arrays.stream(d).boxed().toArray(); System.out.printf(b.charAt(i) + &quot; &quot; + &quot;%2d &quot;.repeat(d.length) + &quot;%n&quot;, array); &#125; &#125; /* i t h e i m a t 0 1 0 0 0 0 0 h 0 0 2 0 0 0 0 e 0 0 0 3 0 0 0 n 0 0 0 0 0 0 0 */ public static void main(String[] args) &#123; System.out.println(lcs(&quot;itheima&quot;, &quot;then&quot;)); &#125;&#125; 类似题目 Leetcode-718 最长重复子数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Leetcode718 &#123; public int findLength(int[] nums1, int[] nums2) &#123; int m = nums1.length + 1; int n = nums2.length + 1; int[] dp = new int[n]; int max = 0; for (int i = 1; i &lt; m; i++) &#123; for (int j = n - 1; j &gt; 0; j--) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[j] = dp[j - 1] + 1; max = Integer.max(max, dp[j]); &#125; else &#123; dp[j] = 0; &#125; &#125; &#125; return max; &#125; public int findLength1(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int[] dp = new int[n]; int max = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; if (nums1[i] == nums2[j]) &#123; if (i == 0 || j == 0) &#123; dp[j] = 1; &#125; else &#123; dp[j] = dp[j - 1] + 1; &#125; max = Integer.max(max, dp[j]); &#125; else &#123; dp[j] = 0; &#125; &#125; &#125; return max; &#125; public int findLength2(int[] nums1, int[] nums2) &#123; int[][] dp = new int[nums1.length][nums2.length]; int max = 0; for (int i = 0; i &lt; nums1.length; i++) &#123; for (int j = 0; j &lt; nums2.length; j++) &#123; if (nums1[i] == nums2[j]) &#123; if (i == 0 || j == 0) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; max = Integer.max(max, dp[i][j]); &#125; else &#123; dp[i][j] = 0; &#125; &#125; &#125; return max; &#125; public static void main(String[] args) &#123; Leetcode718 code = new Leetcode718(); System.out.println(code.findLength(new int[]&#123;1, 2, 3, 2, 1&#125;, new int[]&#123;3, 2, 1, 4, 7&#125;)); System.out.println(code.findLength(new int[]&#123;1, 0, 0, 0, 1&#125;, new int[]&#123;1, 0, 0, 1, 1&#125;)); &#125;&#125; 9) 最长公共子序列最长公共子序列-Leetcode 114312345678910111213141516171819202122232425262728293031323334353637public class LCSubsequence &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(); int n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &lt; m + 1; i++) &#123; char a = text1.charAt(i - 1); for (int j = 1; j &lt; n + 1; j++) &#123; char b = text2.charAt(j - 1); if (a == b) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Integer.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; print(dp, text2, text1); return dp[m][n]; &#125; static void print(int[][] dp, String a, String b) &#123; System.out.println(&quot;-&quot;.repeat(23)); Object[] array = a.chars().mapToObj(i -&gt; String.valueOf((char) i)).toArray(); System.out.printf(&quot; &quot; + &quot;%2s &quot;.repeat(a.length()) + &quot;%n&quot;, array); for (int i = 0; i &lt; b.length(); i++) &#123; int[] d = dp[i + 1]; array = Arrays.stream(d).boxed().toArray(); System.out.printf(b.charAt(i) + &quot; &quot; + &quot;%2d &quot;.repeat(d.length) + &quot;%n&quot;, array); &#125; &#125; public static void main(String[] args) &#123; LCSubsequence code = new LCSubsequence(); System.out.println(code.longestCommonSubsequence(&quot;abcde&quot;, &quot;ace&quot;)); System.out.println(code.longestCommonSubsequence(&quot;ba&quot;, &quot;yby&quot;)); &#125;&#125; 两个字符串的删除操作-Leetcode 58312345678910111213141516171819202122232425262728public class Leetcode538 &#123; public static void main(String[] args) &#123; Leetcode538 code = new Leetcode538(); System.out.println(code.minDistance(&quot;leetcode&quot;, &quot;etco&quot;)); // 4 System.out.println(code.minDistance(&quot;eat&quot;, &quot;sea&quot;)); // 2 System.out.println(code.minDistance(&quot;park&quot;, &quot;spake&quot;)); // 3 &#125; public int minDistance(String word1, String word2) &#123; int m = word1.length(); int n = word2.length(); char[] chars1 = word1.toCharArray(); char[] chars2 = word2.toCharArray(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &lt; m + 1; i++) &#123; int x = chars1[i - 1]; for (int j = 1; j &lt; n + 1; j++) &#123; int y = chars2[j - 1]; if (x == y) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = Integer.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; return m + n - dp[m][n] - dp[m][n]; &#125;&#125; 10) 最长上升子序列-Leetcode 300123456789101112131415161718192021222324252627282930313233343536373839public class Leetcode300 &#123; /* 1 2 3 4 1 3 6 4 9 1 13 16 14 19 136 134 139 169 1369 149 1349 (1) (2) (3) (3) (4) 4 */ public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; Arrays.fill(dp, 1); for (int i = 1; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; // 满足了升序条件 // 用之前递增子序列的最大长度 + 1 更新当前长度 dp[i] = Integer.max(dp[i], dp[j] + 1); &#125; &#125; System.out.println(Arrays.toString(dp)); &#125; return Arrays.stream(dp).max().getAsInt(); &#125; public static void main(String[] args) &#123; Leetcode300 code = new Leetcode300(); System.out.println(code.lengthOfLIS(new int[]&#123;1, 3, 6, 4, 9&#125;));// System.out.println(code.lengthOfLIS(new int[]&#123;10, 9, 2, 5, 3, 7, 101, 18&#125;));// System.out.println(code.lengthOfLIS(new int[]&#123;1, 3, 6, 7, 9, 4, 10, 5, 6&#125;)); // 1 3 6 7 9 10 = 6 // 1 3 4 5 6 = 5// System.out.println(code.lengthOfLIS(new int[]&#123;0, 1, 0, 3, 2, 3&#125;));// System.out.println(code.lengthOfLIS(new int[]&#123;7, 7, 7, 7, 7, 7, 7&#125;)); &#125;&#125; 11) Catalan 数1234567891011121314151617181920public class Catalan &#123; public static void main(String[] args) &#123; System.out.println(catalan(6)); &#125; static int catalan(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt; n + 1; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(&quot;(&quot; + j + &quot; &quot; + (i - 1 - j) + &quot;)\\t&quot;); dp[i] += dp[j] * dp[i - 1 - j]; &#125; System.out.println(); System.out.println(Arrays.toString(dp)); &#125; return dp[n]; &#125;&#125; Leetcode-96 不同的二叉搜索树12345678910111213class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int j = 2; j &lt; n + 1; j++) &#123; for (int i = 0; i &lt; j; i++) &#123; dp[j] += dp[i] * dp[j - 1 - i]; &#125; &#125; return dp[n]; &#125;&#125; Leetcode-22 括号生成12345678910111213141516171819202122232425262728public class Leetcode22 &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; ArrayList&lt;String&gt;[] dp = new ArrayList[n + 1]; dp[0] = new ArrayList&lt;&gt;(List.of(&quot;&quot;)); dp[1] = new ArrayList&lt;&gt;(List.of(&quot;()&quot;)); for (int j = 2; j &lt; n + 1; j++) &#123; dp[j] = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; j; i++) &#123; // 第j个卡特兰数的拆分 System.out.printf(&quot;(%d,%d)\\t&quot;, i, j - 1 - i);// dp[j] += dp[i] * dp[j - 1 - i];// dp[j].add(&quot;(&quot; + dp[i] + &quot;)&quot; + dp[j - 1 - i]); for (String k1 : dp[i]) &#123; for (String k2 : dp[j - 1 - i]) &#123; dp[j].add(&quot;(&quot; + k1 + &quot;)&quot; + k2); &#125; &#125; &#125; System.out.println(dp[j]); &#125; return dp[n]; &#125; public static void main(String[] args) &#123; Leetcode22 code = new Leetcode22(); System.out.println(code.generateParenthesis(4)); &#125;&#125; 买票找零问题售票处售卖球票，每张票 50 元。有2n人前来买票 其中一半人手持 50 元钞票 另一半人手持 100 元钞票 若售票处开始没有任何零钱，问：有多少种排队方式，能够让售票顺畅进行。 思路： 把手持 50 元钞票的人视为左括号 把手持 100 元钞票的人视为右括号 左右括号合法配对，即先出现左括号，再出现右括号，就可以让售票顺畅执行 可以看到，问题又变成了求解 n 的卡特兰数 其它问题 题号 标题 Leetcode 331 验证二叉树的前序序列化 Leetcode 894 所有可能的满二叉树 12) 打家劫舍-Leetcode 198123456789101112131415161718192021222324252627282930313233343536373839public class HouseRobberLeetcode198 &#123; /* 房子价值 0 1 2 3 4 2 7 9 3 1 0 1 2 3 4 0 0 0 0 0 2 7 11 10 12 0 1 2 3 2 1 1 2 0 1 2 3 2 2 3 4 */ public int rob(int[] nums) &#123; int len = nums.length; if (len == 1) &#123; return nums[0]; &#125; int[] dp = new int[len]; dp[0] = nums[0]; dp[1] = Integer.max(nums[0], nums[1]); for (int i = 2; i &lt; len; i++) &#123; dp[i] = Integer.max(dp[i - 2] + nums[i], dp[i - 1]); &#125; return dp[len - 1]; &#125; public static void main(String[] args) &#123; HouseRobberLeetcode198 code = new HouseRobberLeetcode198(); System.out.println(code.rob(new int[]&#123;2, 7, 9, 3, 1&#125;)); System.out.println(code.rob(new int[]&#123;2, 1, 1, 2&#125;)); &#125;&#125; 13) Travelling salesman problem旅行商问题 java 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153public class TravellingSalesmanProblem &#123; /* 0 1 2 3 0 0 1 2 3 1 1 0 6 4 2 2 6 0 5 3 3 4 5 0 d(0,&#123;1,2,3&#125;) =&gt; c01+d(1,&#123;2,3&#125;) =&gt; c12+d(2,&#123;3&#125;) =&gt; c23+d(3,&#123;&#125;) c13+d(3,&#123;2&#125;) =&gt; c32+d(2,&#123;&#125;) c02+d(2,&#123;1,3&#125;) =&gt; c21+d(1,&#123;3&#125;) =&gt; c13+d(3,&#123;&#125;) c23+d(3,&#123;1&#125;) =&gt; c31+d(1,&#123;&#125;) c03+d(3,&#123;1,2&#125;) =&gt; c31+d(1,&#123;2&#125;) =&gt; c12+d(2,&#123;&#125;) c32+d(2,&#123;1&#125;) =&gt; c21+d(1,&#123;&#125;) d(0,&#123;1&#125;) =&gt; c01+d(1,&#123;&#125;) 0-&gt;1-&gt;0 d(1,&#123;1&#125;) d(2,&#123;1&#125;) =&gt; c21+d(1,&#123;&#125;) 2-&gt;1-&gt;0 d(3,&#123;1&#125;) =&gt; c31+d(1,&#123;&#125;) 3-&gt;1-&gt;0 d(0,&#123;2&#125;) =&gt; c02+d(2,&#123;&#125;) 0-&gt;2-&gt;0 d(1,&#123;2&#125;) =&gt; c12+d(2,&#123;&#125;) 1-&gt;2-&gt;0 d(2,&#123;2&#125;) d(3,&#123;2&#125;) =&gt; c32+d(2,&#123;&#125;) 3-&gt;2-&gt;0 d(0,&#123;1,2&#125;) =&gt; c01+d(1,&#123;2&#125;) =&gt; 0-&gt;1-&gt;2-&gt;0 c02+d(2,&#123;1&#125;) =&gt; 0-&gt;2-&gt;1-&gt;0 d(3,&#123;1,2&#125;) =&gt; c31+d(1,&#123;2&#125;) =&gt; 3-&gt;1-&gt;2-&gt;0 c32+d(2,&#123;1&#125;) =&gt; 3-&gt;2-&gt;1-&gt;0 d(0,&#123;3&#125;) =&gt; c03+d(3,&#123;&#125;) 0-&gt;3-&gt;0 d(1,&#123;3&#125;) =&gt; c13+d(3,&#123;&#125;) 1-&gt;3-&gt;0 d(2,&#123;3&#125;) =&gt; c23+d(3,&#123;&#125;) 2-&gt;3-&gt;0 d(3,&#123;3&#125;) d(0,&#123;1,3&#125;) =&gt; c01+d(1,&#123;3&#125;) =&gt; 0-&gt;1-&gt;3-&gt;0 c03+d(3,&#123;1&#125;) =&gt; 0-&gt;3-&gt;1-&gt;0 d(2,&#123;1,3&#125;) =&gt; c21+d(1,&#123;3&#125;) =&gt; 2-&gt;1-&gt;3-&gt;0 c23+d(3,&#123;1&#125;) =&gt; 2-&gt;3-&gt;1-&gt;0 d(0,&#123;2,3&#125;) =&gt; c02+d(2,&#123;3&#125;) =&gt; 0-&gt;2-&gt;3-&gt;0 c03+d(3,&#123;2&#125;) =&gt; 0-&gt;3-&gt;2-&gt;0 d(1,&#123;2,3&#125;) =&gt; c12+d(2,&#123;3&#125;) =&gt; 1-&gt;2-&gt;3-&gt;0 c13+d(3,&#123;2&#125;) =&gt; 1-&gt;3-&gt;2-&gt;0 d(0,&#123;1,2,3&#125;) =&gt; c01+d(1,&#123;2,3&#125;) 11+1 c02+d(2,&#123;1,3&#125;) 10+2 c03+d(3,&#123;1,2&#125;) 12+3 0 1 2 12 3 13 23 123 0 1 2 3 4 5 6 7 0 0 2 4 9 6 8 10 12 1 1 _ 8 _ 7 _ 11 _ 2 2 7 _ _ 8 10 _ _ 3 3 5 7 12 _ _ _ _ */ public static void main(String[] args) &#123; int[][] graph = &#123; &#123;0, 1, 2, 3&#125;, &#123;1, 0, 6, 4&#125;, &#123;2, 6, 0, 5&#125;, &#123;3, 4, 5, 0&#125;, &#125;;// System.out.println(tsp(graph)); System.out.println(6 &gt;&gt; (0-1)); &#125; static int tsp1(int[][] graph) &#123; int n = graph.length; int[][] dp = new int[1 &lt;&lt; n][n]; for (int[] row : dp) &#123; Arrays.fill(row, Integer.MAX_VALUE / 2); &#125; dp[1][0] = 0; for (int mask = 1; mask &lt; 1 &lt;&lt; n; mask++) &#123; for (int i = 0; i &lt; n; i++) &#123; if ((mask &amp; 1 &lt;&lt; i) == 0) continue; for (int j = 0; j &lt; n; j++) &#123; if ((mask &amp; 1 &lt;&lt; j) != 0) continue; dp[mask | 1 &lt;&lt; j][j] = Math.min(dp[mask | 1 &lt;&lt; j][j], dp[mask][i] + graph[i][j]); &#125; &#125; print(dp); &#125; int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; res = Math.min(res, dp[(1 &lt;&lt; n) - 1][i] + graph[i][0]); &#125; return res; &#125; /* 110 是否包含 0 = 0 &amp; 1 = 0 110 是否包含 1 = 110 &amp; 1 = 0 110 是否包含 2 = 11 &amp; 1 = 1 110 是否包含 3 = 1 &amp; 1 = 1 110 是否包含 4 = 0 &amp; 1 = 0 */ static boolean contains(int set, int city) &#123; return (set &gt;&gt; (city - 1) &amp; 1) == 1; &#125; /* 110 110 ^100 ^010 ---- ---- 10 100 */ static int exclude(int set, int city) &#123; return set ^ (1 &lt;&lt; (city - 1)); &#125; static int tsp(int[][] g) &#123; int n = g.length; int m = 1 &lt;&lt; (n - 1); int[][] dp = new int[n][m]; for (int i = 0; i &lt; n; i++) &#123; dp[i][0] = g[i][0]; &#125; for (int j = 1; j &lt; m; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; dp[i][j] = Integer.MAX_VALUE / 2; if (contains(j, i)) continue; for (int k = 1; k &lt; n; k++) &#123; if (contains(j, k)) &#123;// System.out.println(&quot;(&quot; + k + &quot;,&quot; + (j ^ (1 &lt;&lt; (k - 1))) + &quot;)&quot;); dp[i][j] = Math.min(dp[i][j], g[i][k] + dp[k][exclude(j, k)]); &#125; &#125; &#125; print(dp); &#125; return dp[0][m - 1]; &#125; static void print(int[][] dist) &#123; System.out.println(&quot;-------------------------&quot;); for (int[] row : dist) &#123; System.out.println(Arrays.stream(row).boxed() .map(x -&gt; x &gt;= Integer.MAX_VALUE / 2 ? &quot;∞&quot; : String.valueOf(x)) .map(s -&gt; String.format(&quot;%2s&quot;, s)) .collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;))); &#125; &#125;&#125; 其它题目 题号 标题 无 集合覆盖问题 无 扔鸡蛋问题 Leetcode 72 编辑距离 Leetcode 121 买股票的最佳时机 组合总和 IV-Leetcode 377不要被题目名字误导了，本题类似于零钱兑换518题，区别在于零钱兑换求的是组合数，本题求的是排列数 123456789101112131415161718192021222324252627282930313233343536373839404142public class CombinationLeetcode377 &#123; static int combinationSum4(int[] nums, int target) &#123; return change(nums, target); &#125; /* 0 1 2 3 4 总金额 1 1 11 111 1111 2 1 11 111 1111 2 12 112 21 121 22 211 3 1 11 111 1111 2 12 112 21 121 3 13 211 22 31 面值 dp[j] = dp[j-1] + dp[j-2] + dp[j-3] */ static int change(int[] coins, int amount) &#123; int[] dp = new int[amount + 1]; dp[0] = 1; for (int j = 1; j &lt; amount + 1; j++) &#123; for (int coin : coins) &#123; if (j &gt;= coin) &#123; dp[j] += dp[j - coin]; &#125; &#125; System.out.println(Arrays.toString(dp)); &#125; return dp[amount]; &#125; public static void main(String[] args) &#123; System.out.println(combinationSum4(new int[]&#123;1, 2, 3&#125;, 4)); &#125;&#125; 4.4 Divide and Conquer1) 概述分治思想 将大问题划分为两个到多个子问题 子问题可以继续拆分成更小的子问题，直到能够简单求解 如有必要，将子问题的解进行合并，得到原始问题的解 之前学过的一些经典分而治之的例子 二分查找 快速排序 归并排序 合并K个排序链表 - LeetCode 23 二分查找 1234567891011121314151617public static int binarySearch(int[] a, int target) &#123; return recursion(a, target, 0, a.length - 1);&#125;public static int recursion(int[] a, int target, int i, int j) &#123; if (i &gt; j) &#123; return -1; &#125; int m = (i + j) &gt;&gt;&gt; 1; if (target &lt; a[m]) &#123; return recursion(a, target, i, m - 1); &#125; else if (a[m] &lt; target) &#123; return recursion(a, target, m + 1, j); &#125; else &#123; return m; &#125;&#125; 减而治之，每次搜索范围内元素减少一半 快速排序 123456789101112public static void sort(int[] a) &#123; quick(a, 0, a.length - 1);&#125;private static void quick(int[] a, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int p = partition(a, left, right); quick(a, left, p - 1); quick(a, p + 1, right);&#125; 分而治之，这次分区基准点，在划分后两个区域分别进行下次分区 归并排序 12345678910111213141516171819public static void sort(int[] a1) &#123; int[] a2 = new int[a1.length]; split(a1, 0, a1.length - 1, a2);&#125;private static void split(int[] a1, int left, int right, int[] a2) &#123; int[] array = Arrays.copyOfRange(a1, left, right + 1); // 2. 治 if (left == right) &#123; return; &#125; // 1. 分 int m = (left + right) &gt;&gt;&gt; 1; split(a1, left, m, a2); split(a1, m + 1, right, a2); // 3. 合 merge(a1, left, m, m + 1, right, a2); System.arraycopy(a2, left, a1, left, right - left + 1);&#125; 分而治之，分到区间内只有一个元素，合并区间 合并K个排序链表 - LeetCode 23123456789101112131415161718public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) &#123; return null; &#125; return split(lists, 0, lists.length - 1);&#125;public ListNode split(ListNode[] lists, int i, int j) &#123; System.out.println(i + &quot; &quot; + j); if (j == i) &#123; return lists[i]; &#125; int m = (i + j) &gt;&gt;&gt; 1; return mergeTwoLists( split(lists, i, m), split(lists, m + 1, j) );&#125; 分而治之，分到区间内只有一个链表，合并区间 对比动态规划 都需要拆分子问题 动态规划的子问题有重叠、因此需要记录之前子问题解，避免重复运算 分而治之的子问题无重叠 2) 快速选择算法1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Utils &#123; static int quick(int[] a, int left, int right, int index) &#123; int p = partition(a, left, right); if (p == index) &#123; return a[p]; &#125; if (p &lt; index) &#123; return quick(a, p + 1, right, index); &#125; else &#123; return quick(a, left, p - 1, index); &#125; &#125; static int partition(int[] a, int left, int right) &#123; int idx = ThreadLocalRandom.current().nextInt(right - left + 1) + left; swap(a, left, idx); int pv = a[left]; int i = left + 1; int j = right; while (i &lt;= j) &#123; // i 从左向右找大的或者相等的 while (i &lt;= j &amp;&amp; a[i] &lt; pv) &#123; i++; &#125; // j 从右向左找小的或者相等的 while (i &lt;= j &amp;&amp; a[j] &gt; pv) &#123; j--; &#125; if (i &lt;= j) &#123; swap(a, i, j); i++; j--; &#125; &#125; swap(a, j, left); return j; &#125; static void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125;&#125; 数组中第k个最大元素-Leetcode 215123456789101112131415161718192021public class FindKthLargestLeetcode215 &#123; /* 目标 index = 4 3 2 1 5 6 4 =&gt; 3 2 1 4 5 6 (3) =&gt; 3 2 1 4 5 6 (5) =&gt; 3 2 1 4 5 6 (4) */ public int findKthLargest(int[] a, int k) &#123; return Utils.quick(a, 0, a.length - 1, a.length - k); &#125; public static void main(String[] args) &#123; // 应为5 FindKthLargestLeetcode215 code = new FindKthLargestLeetcode215(); System.out.println(code.findKthLargest(new int[]&#123;3, 2, 1, 5, 6, 4&#125;, 2)); // 应为4 System.out.println(code.findKthLargest(new int[]&#123;3, 2, 3, 1, 2, 4, 5, 5, 6&#125;, 4)); &#125;&#125; 数组中位数12345678910111213141516171819202122232425262728293031public class FindMedian &#123; /* 偶数个 3 1 5 4 奇数个 4 5 1 4 5 1 6 3 */ public static double findMedian(int[] nums) &#123; if (nums.length % 2 != 0) &#123; return findIndex(nums, nums.length / 2); &#125; else &#123; System.out.println((nums.length / 2 - 1) + &quot;,&quot; + (nums.length / 2)); int a = findIndex(nums, nums.length / 2); int b = findIndex(nums, nums.length / 2 - 1); return (a + b) / 2.0; &#125; &#125; public static void main(String[] args) &#123; System.out.println(findMedian(new int[]&#123;3, 1, 5, 4&#125;)); System.out.println(findMedian(new int[]&#123;3, 1, 5, 4, 7, 8&#125;)); System.out.println(findMedian(new int[]&#123;4, 5, 1&#125;)); System.out.println(findMedian(new int[]&#123;4, 5, 1, 6, 3&#125;)); &#125; static int findIndex(int[] a, int index) &#123; return Utils.quick(a, 0, a.length - 1, index); &#125;&#125; 3) 快速幂-Leetcode 50123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class QuickPowLeetcode50 &#123; /* 2^10 / \\ 2^5 2^5 / \\ / \\ 2 2^2 2^2 2 2^2 2^2 / \\ / \\ / \\ / \\ 2 2 2 2 2 2 2 2 256 n=1 x=65536 mul=1024 / \\ 16 16 n=2 x=256 mul=4 / \\ / \\ 2 4 4 2 4 4 n=5 x=16 mul=4 / \\ / \\ / \\ / \\ 2 2 2 2 2 2 2 2 n=10 x=4 mul=1 */ static double myPow(double x, int n) &#123; if (n == 0) &#123; return 1; &#125; double mul = 1; long N = n; if (n &lt; 0) &#123; N = -N; &#125; while (N &gt; 0) &#123; if ((N &amp; 1) == 1) &#123; mul *= x; &#125; x = x * x; N = N &gt;&gt; 1; &#125; return n &gt; 0 ? mul : 1 / mul; &#125; static double myPow1(double x, int n) &#123; long N = n; if (N &lt; 0) &#123; return 1.0 / rec(x, -N); &#125; return rec(x, n); &#125; static double rec(double x, long n) &#123; if (n == 0) &#123; return 1; &#125; if (n == 1) &#123; return x; &#125; double y = rec(x, n / 2); if ((n &amp; 1) == 1) &#123; return x * y * y; &#125; return y * y; &#125; public static void main(String[] args) &#123; System.out.println(myPow(2, 10)); // 1024.0 System.out.println(myPow(2.1, 3)); // 9.261 System.out.println(myPow(2, -2)); // 0.25 System.out.println(myPow(2, 0)); // 1.0 System.out.println(myPow(2, -2147483648)); // 1.0 &#125;&#125; 4) 平方根整数部分-Leetcode 69123456789101112131415161718192021222324public class SqrtLeetcode69 &#123; static int mySqrt(int x) &#123; int i = 1, j = x; int r = 0; while (i &lt;= j) &#123; int m = (i + j) &gt;&gt;&gt; 1; if (x / m &gt;= m) &#123; r = m; i = m+1; &#125; else &#123; j = m-1; &#125; &#125; return r; &#125; public static void main(String[] args) &#123; System.out.println(mySqrt(1)); System.out.println(mySqrt(2)); System.out.println(mySqrt(4)); System.out.println(mySqrt(8)); System.out.println(mySqrt(9)); &#125;&#125; while(i &lt;&#x3D; j) 含义是在此区间内，只要有数字还未尝试，就不算结束 r 的作用是保留最近一次当 $m^2 &lt;&#x3D; x$ 的 m 的值 使用除法而非乘法，避免大数相乘越界 5) 至少k个重复字符的最长子串-Leetcode 39512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LongestSubstringLeetcode395 &#123; static int longestSubstring(String s, int k) &#123; // 子串落选情况 if (s.length() &lt; k) &#123; return 0; &#125; int[] counts = new int[26]; // 索引对应字符 值用来存储该字符出现了几次 char[] chars = s.toCharArray(); for (char c : chars) &#123; // &#x27;a&#x27; -&gt; 0 &#x27;b&#x27; -&gt; 1 .... counts[c - &#x27;a&#x27;]++; &#125; System.out.println(Arrays.toString(counts)); for (int i = 0; i &lt; chars.length; i++) &#123; char c = chars[i]; int count = counts[c - &#x27;a&#x27;]; // i字符出现次数 if (count &gt; 0 &amp;&amp; count &lt; k) &#123; int j = i + 1; while(j &lt; s.length() &amp;&amp; counts[chars[j] - &#x27;a&#x27;] &lt; k) &#123; j++; &#125; System.out.println(s.substring(0, i) + &quot;\\t&quot; + s.substring(j)); return Integer.max( longestSubstring(s.substring(0, i), k), longestSubstring(s.substring(j), k) ); &#125; &#125; // 子串入选情况 return s.length(); &#125; public static void main(String[] args) &#123; // i j System.out.println(longestSubstring(&quot;aaaccbbb&quot;, 3)); // ababb System.out.println(longestSubstring(&quot;dddxaabaaabaacciiiiefbff&quot;, 3));// System.out.println(longestSubstring(&quot;ababbc&quot;, 3)); // ababb// System.out.println(longestSubstring(&quot;ababbc&quot;, 2)); // ababb /* ddd aabaaabaa iiii fbff aa aaa aa f ff 统计字符串中每个字符的出现次数，移除哪些出现次数 &lt; k 的字符 剩余的子串，递归做此处理，直至 - 整个子串长度 &lt; k (排除) - 子串中没有出现次数 &lt; k 的字符 */ &#125;&#125; 4.5 Backtracking Algorithm1) 入门例子12345678910111213141516public class Backtracking &#123; public static void main(String[] args) &#123; rec(1, new LinkedList&lt;&gt;()); &#125; static void rec(int n, LinkedList&lt;String&gt; list) &#123; if (n == 3) &#123; return; &#125; System.out.println(&quot;before:&quot; + list); list.push(&quot;a&quot;); rec(n + 1, list); list.pop(); System.out.println(&quot;after:&quot; + list); &#125;&#125; 2) 全排列-Leetcode 46123456789101112131415161718192021222324252627282930313233public class PermuteLeetcode46 &#123; static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; boolean[] visited = new boolean[nums.length]; LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; r = new ArrayList&lt;&gt;(); rec(nums, visited, stack, r); return r; &#125; static void rec(int[] nums, boolean[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; r) &#123; if (stack.size() == nums.length) &#123; r.add(new ArrayList&lt;&gt;(stack)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if(visited[i])&#123; continue; &#125; stack.push(nums[i]); visited[i] = true; rec(nums, visited, stack, r); stack.pop(); visited[i] = false; &#125; &#125; public static void main(String[] args) &#123; List&lt;List&lt;Integer&gt;&gt; permute = permute(new int[]&#123;1, 2, 3&#125;); for (List&lt;Integer&gt; s : permute) &#123; System.out.println(s); &#125; &#125;&#125; 3) 全排列II-Leetcode 47123456789101112131415161718192021222324252627282930313233343536public class PermuteLeetcode47 &#123; static List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(nums, new boolean[nums.length], new LinkedList&lt;&gt;(), result); return result; &#125; static void dfs(int[] nums, boolean[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (stack.size() == nums.length) &#123; result.add(new ArrayList&lt;&gt;(stack)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i-1]) &#123; // 找出重复数字 continue; &#125; if (!visited[i]) &#123; stack.push(nums[i]); visited[i] = true; dfs(nums, visited, stack, result); visited[i] = false; stack.pop(); &#125; &#125; &#125; public static void main(String[] args) &#123; int[] nums = &#123;1, 1, 3&#125;; List&lt;List&lt;Integer&gt;&gt; permute = permuteUnique(nums); for (List&lt;Integer&gt; list : permute) &#123; System.out.println(list); &#125; &#125;&#125; 排好序，这样重复的数字会相邻 定好规则：必须 1 固定之后才能固定 1’，即 1 的 visited &#x3D; true 才能继续处理 1’ 在遍历时，遇到了 nums[i] == nums[i - 1]（即 1 和 1‘ 这种情况），进一步检查 i-1 位置的数字有没有 visited，没有，则不处理（剪枝） 4) 组合-Leetcode 771234567891011121314151617181920212223242526272829303132333435public class CombinationLeetcode77 &#123; static List&lt;List&lt;Integer&gt;&gt; combinationSum(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(n, k, 1, new LinkedList&lt;&gt;(), result); return result; &#125; static int count = 0; static void dfs(int n, int k, int start, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123; count++; if (k == 0) &#123; result.add(new ArrayList&lt;&gt;(stack)); System.out.println(stack); return; &#125;// if (k &gt; n - start + 1) &#123; return; &#125; for (int i = start; i &lt;= n; i++) &#123;// System.out.printf(&quot;k-1=%d n=%d i=%d %n&quot;, k - 1, n, i); if (k &gt; n - i + 1) &#123; continue; &#125; stack.push(i); dfs(n, k - 1, i + 1, stack, result); stack.pop(); &#125; &#125; public static void main(String[] args) &#123; List&lt;List&lt;Integer&gt;&gt; lists = combinationSum(5, 4);// for (List&lt;Integer&gt; list : lists) &#123;// System.out.println(list);// &#125; System.out.println(count); &#125;&#125; k 代表剩余要组合的个数 n - i + 1 代表剩余可用数字 剪枝条件是：剩余可用数字要大于剩余组合数 为啥放在外面不行？即这行代码：if (k &gt; n - start + 1) &#123; return; &#125; 因为它只考虑了 start 一种情况，而实际在循环内要处理的是 start，start+1 … n 这多种情况 似乎 ArrayList 作为 stack 性能高一些，见下面代码，但是这道题在 leetcode 上执行时间不稳定，相同代码都会有较大时间差异（15ms vs 9ms） 1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(k == 0 || n &lt; k) return result; dfs(n, k, 1, new ArrayList&lt;&gt;(), result); return result; &#125; static void dfs(int n, int k, int start, ArrayList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (k == 0) &#123; result.add(new ArrayList&lt;&gt;(stack)); return; &#125; for (int i = start; i &lt;= n; i++) &#123; if (k-1 &gt; n - i) &#123; continue; &#125; stack.add(i); dfs(n, k - 1, i + 1, stack, result); stack.remove(stack.size()-1); &#125; &#125;&#125; 5) 组合总和-Leetcode 39123456789101112131415161718192021222324252627282930public class CombinationLeetcode39 &#123; static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(target, 0,candidates, new LinkedList&lt;&gt;(), result); return result; &#125; static void dfs(int target, int start, int[] candidates, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(stack)); return; &#125; for (int i = start; i &lt; candidates.length; i++) &#123; int candidate = candidates[i]; if (target &lt; candidate) &#123; continue; &#125; stack.push(candidate); dfs(target - candidate, i, candidates, stack, result); stack.pop(); &#125; &#125; public static void main(String[] args) &#123; List&lt;List&lt;Integer&gt;&gt; lists = combinationSum(new int[]&#123;6, 3, 2, 7&#125;, 7); for (List&lt;Integer&gt; list : lists) &#123; System.out.println(list); &#125; &#125;&#125; 与之前的零钱兑换问题其实是一样的，只是 本题求的是：所有组合的具体信息 零钱兑换问题求的是：所有组合中数字最少的、所有组合个数… 6) 组合总和 II-Leetcode 4012345678910111213141516171819202122232425262728293031323334353637public class CombinationLeetcode40 &#123; static List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(target, 0, candidates, new boolean[candidates.length], new LinkedList&lt;&gt;(), result); return result; &#125; static void dfs(int target, int start, int[] candidates, boolean[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(stack)); return; &#125; for (int i = start; i &lt; candidates.length; i++) &#123; int candidate = candidates[i]; if (target &lt; candidate) &#123; continue; &#125; if (i &gt; 0 &amp;&amp; candidate == candidates[i - 1] &amp;&amp; !visited[i - 1]) &#123; continue; &#125; visited[i] = true; stack.push(candidate); dfs(target - candidate, i + 1, candidates, visited, stack, result); stack.pop(); visited[i] = false; &#125; &#125; public static void main(String[] args) &#123; int[] candidates = &#123;10, 1, 2, 7, 6, 1, 5&#125;; List&lt;List&lt;Integer&gt;&gt; lists = combinationSum2(candidates, 8); for (List&lt;Integer&gt; list : lists) &#123; System.out.println(list); &#125; &#125;&#125; 7) 组合总和 III-Leetcode 216123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CombinationLeetcode216 &#123; // 此 target 代表数字组合后的和 static List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(1, target, k, new LinkedList&lt;&gt;(), result); return result; &#125; static int count = 0; static void dfs(int start, int target, int k, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123;// System.out.println(stack); count++; if (target == 0 &amp;&amp; stack.size() == k) &#123; result.add(new ArrayList&lt;&gt;(stack)); return; &#125; for (int i = start; i &lt;= 9; i++) &#123; // 还差几个数字 剩余可用数字 /*if (k - stack.size() &gt; 9 - i + 1) &#123; continue; &#125;*/ if(target &lt; i)&#123; continue; &#125; if(stack.size() == k) &#123; continue; &#125; stack.push(i); dfs(i + 1, target - i, k, stack, result); stack.pop(); &#125; &#125; public static void main(String[] args) &#123;// List&lt;List&lt;Integer&gt;&gt; lists = combinationSum3(3, 7); List&lt;List&lt;Integer&gt;&gt; lists = combinationSum3(2, 18); // 9 8 for (List&lt;Integer&gt; list : lists) &#123; System.out.println(list); &#125; System.out.println(count); &#125;&#125; 这道题更类似于 77 题，区别在于 77 题的数字范围 n 更大 [1,20]，而本题数字范围限制为 [1,9] 本题不仅仅找到组合，还要让组合之和等于 target（类似于 39 题） 剪枝优化 如果剩余的和 target 还没 i 大，这时减完 i 是负数，肯定无法满足要求，因此有剪枝条件： target &lt; i 如果组合的数字个数已经到达了上限 k，还没有凑够 target，也没必要继续递归，因此有： stack.size() == k 8) N 皇后 Leetcode 5112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class NQueenLeetcode51 &#123; static List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); char[][] table = new char[n][n]; for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(table[i], &#x27;.&#x27;); &#125; dfs(0, n, table, result); return result; &#125; static void dfs(int i, int n, char[][] table, List&lt;List&lt;String&gt;&gt; result) &#123; if (i == n) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (char[] chars : table) &#123; list.add(String.valueOf(chars)); &#125; result.add(list); return; &#125; for (int j = 0; j &lt; n; j++) &#123; if (notValid(table, i, j)) &#123; continue; &#125; table[i][j] = &#x27;Q&#x27;; dfs(i + 1, n, table, result); table[i][j] = &#x27;.&#x27;; &#125; &#125; /* . . . . . . . . . ? . . . . . . */ static boolean notValid(char[][] table, int row, int col) &#123; int n = table.length; for (int i = 0; i &lt; n; i++) &#123; if (table[i][col] == &#x27;Q&#x27;) &#123; // 上 return true; &#125; &#125; for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123; if (table[i][j] == &#x27;Q&#x27;) &#123; return true; &#125; &#125; for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123; if (table[i][j] == &#x27;Q&#x27;) &#123; return true; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; int count = 0; for (List&lt;String&gt; table : solveNQueens(8)) &#123; for (String row : table) &#123; System.out.println(row); &#125; count++; System.out.println(&quot;--------------------- &quot; + count); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class NQueenLeetcode51 &#123; static List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); char[][] table = new char[n][n]; boolean[] va = new boolean[n]; boolean[] vb = new boolean[2 * n - 1]; boolean[] vc = new boolean[2 * n - 1]; for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(table[i], &#x27;.&#x27;); &#125; dfs(0, n, table, result, va, vb, vc); return result; &#125; static void dfs(int i, int n, char[][] table, List&lt;List&lt;String&gt;&gt; result, boolean[] va, boolean[] vb, boolean[] vc) &#123; if (i == n) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (char[] chars : table) &#123; list.add(String.valueOf(chars)); &#125; result.add(list); return; &#125; for (int j = 0; j &lt; n; j++) &#123; if (va[j] || vb[i + j] || vc[i - j + n - 1]) &#123; continue; &#125; va[j] = true; vb[i + j] = true; vc[i - j + n - 1] = true; table[i][j] = &#x27;Q&#x27;; dfs(i + 1, n, table, result, va, vb, vc); table[i][j] = &#x27;.&#x27;; va[j] = false; vb[i + j] = false; vc[i - j + n - 1] = false; &#125; &#125; public static void main(String[] args) &#123; int count = 0; for (List&lt;String&gt; table : solveNQueens(4)) &#123; for (String row : table) &#123; System.out.println(row); &#125; count++; System.out.println(&quot;--------------------- &quot; + count); &#125; &#125;&#125; 9) 解数独-Leetcode371234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class SudokuLeetcode37 &#123; record Pair(int i, int j) &#123; &#125; static void solveSudoku(char[][] table) &#123; int n = 9; boolean[][] va = new boolean[n][n]; boolean[][] vb = new boolean[n][n]; boolean[][][] vc = new boolean[3][3][n]; List&lt;Pair&gt; blanks = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (table[i][j] != &#x27;.&#x27;) &#123; int x = table[i][j] - &#x27;0&#x27; - 1; va[i][x] = true; vb[j][x] = true; vc[i / 3][j / 3][x] = true; &#125; else &#123; blanks.add(new Pair(i, j)); &#125; &#125; &#125; dfs(0, blanks, table, va, vb, vc); &#125; static boolean dfs(int p, List&lt;Pair&gt; blanks, char[][] table, boolean[][] va, boolean[][] vb, boolean[][][] vc) &#123; if (p == blanks.size()) &#123; print(table); return true; &#125; int n = table.length; for (int d = 0; d &lt; n; d++) &#123; Pair pair = blanks.get(p); if (va[pair.i][d] || vb[pair.j][d] || vc[pair.i / 3][pair.j / 3][d]) &#123; continue; &#125; char ch = (char) (d + &#x27;0&#x27; + 1); table[pair.i][pair.j] = ch; va[pair.i][d] = true; vb[pair.j][d] = true; vc[pair.i / 3][pair.j / 3][d] = true; boolean dfs = dfs(p + 1, blanks, table, va, vb, vc); if (dfs) &#123; return true; &#125; table[pair.i][pair.j] = &#x27;.&#x27;; va[pair.i][d] = false; vb[pair.j][d] = false; vc[pair.i / 3][pair.j / 3][d] = false; &#125; return false; &#125; public static void main(String[] args) &#123; char[][] table = &#123; &#123;&#x27;5&#x27;, &#x27;3&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;&#125;, &#123;&#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;5&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;&#125;, &#123;&#x27;.&#x27;, &#x27;9&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;&#125;, &#123;&#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;3&#x27;&#125;, &#123;&#x27;4&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;3&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;&#125;, &#123;&#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;2&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;&#125;, &#123;&#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;.&#x27;&#125;, &#123;&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;4&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;5&#x27;&#125;, &#123;&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;7&#x27;, &#x27;9&#x27;&#125; &#125;; solveSudoku(table); print(table); &#125; static char[][] solved = &#123; &#123;&#x27;5&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;1&#x27;, &#x27;2&#x27;&#125;, &#123;&#x27;6&#x27;, &#x27;7&#x27;, &#x27;2&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;5&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;8&#x27;&#125;, &#123;&#x27;1&#x27;, &#x27;9&#x27;, &#x27;8&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;2&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;&#125;, &#123;&#x27;8&#x27;, &#x27;5&#x27;, &#x27;9&#x27;, &#x27;7&#x27;, &#x27;6&#x27;, &#x27;1&#x27;, &#x27;4&#x27;, &#x27;2&#x27;, &#x27;3&#x27;&#125;, &#123;&#x27;4&#x27;, &#x27;2&#x27;, &#x27;6&#x27;, &#x27;8&#x27;, &#x27;5&#x27;, &#x27;3&#x27;, &#x27;7&#x27;, &#x27;9&#x27;, &#x27;1&#x27;&#125;, &#123;&#x27;7&#x27;, &#x27;1&#x27;, &#x27;3&#x27;, &#x27;9&#x27;, &#x27;2&#x27;, &#x27;4&#x27;, &#x27;8&#x27;, &#x27;5&#x27;, &#x27;6&#x27;&#125;, &#123;&#x27;9&#x27;, &#x27;6&#x27;, &#x27;1&#x27;, &#x27;5&#x27;, &#x27;3&#x27;, &#x27;7&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;4&#x27;&#125;, &#123;&#x27;2&#x27;, &#x27;8&#x27;, &#x27;7&#x27;, &#x27;4&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;6&#x27;, &#x27;3&#x27;, &#x27;5&#x27;&#125;, &#123;&#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;6&#x27;, &#x27;1&#x27;, &#x27;7&#x27;, &#x27;9&#x27;&#125; &#125;; static void print(char[][] table) &#123; for (char[] chars : table) &#123; System.out.println(new String(chars)); &#125; System.out.println(Arrays.deepEquals(table, solved)); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class SudokuLeetcode37 &#123; static void solveSudoku(char[][] table) &#123; int n = 9; boolean[][] va = new boolean[n][n]; boolean[][] vb = new boolean[n][n]; boolean[][][] vc = new boolean[3][3][n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (table[i][j] != &#x27;.&#x27;) &#123; int x = table[i][j] - &#x27;0&#x27; - 1; va[i][x] = true; vb[j][x] = true; vc[i / 3][j / 3][x] = true; &#125; &#125; &#125; dfs(table, va, vb, vc, 0, 0); &#125; static boolean dfs(char[][] table, boolean[][] va, boolean[][] vb, boolean[][][] vc, int i, int j) &#123; while (table[i][j] != &#x27;.&#x27;) &#123; if (++j &gt;= 9) &#123; j = 0; i++; &#125; if (i &gt;= 9) &#123; return true; &#125; &#125; int n = table.length; for (int d = 0; d &lt; n; d++) &#123; if (va[i][d] || vb[j][d] || vc[i / 3][j / 3][d]) &#123; continue; &#125; char ch = (char) (d + &#x27;0&#x27; + 1); table[i][j] = ch; va[i][d] = true; vb[j][d] = true; vc[i / 3][j / 3][d] = true; boolean dfs = dfs(table, va, vb, vc, i, j); if (dfs) &#123; return true; &#125; table[i][j] = &#x27;.&#x27;; va[i][d] = false; vb[j][d] = false; vc[i / 3][j / 3][d] = false; &#125; return false; &#125; public static void main(String[] args) &#123; char[][] table = &#123; &#123;&#x27;5&#x27;, &#x27;3&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;&#125;, &#123;&#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;5&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;&#125;, &#123;&#x27;.&#x27;, &#x27;9&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;&#125;, &#123;&#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;3&#x27;&#125;, &#123;&#x27;4&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;3&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;1&#x27;&#125;, &#123;&#x27;7&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;2&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;6&#x27;&#125;, &#123;&#x27;.&#x27;, &#x27;6&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;.&#x27;&#125;, &#123;&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;4&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;5&#x27;&#125;, &#123;&#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;8&#x27;, &#x27;.&#x27;, &#x27;.&#x27;, &#x27;7&#x27;, &#x27;9&#x27;&#125; &#125;; solveSudoku(table); print(table); &#125; static char[][] solved = &#123; &#123;&#x27;5&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;1&#x27;, &#x27;2&#x27;&#125;, &#123;&#x27;6&#x27;, &#x27;7&#x27;, &#x27;2&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;5&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;8&#x27;&#125;, &#123;&#x27;1&#x27;, &#x27;9&#x27;, &#x27;8&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;2&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;&#125;, &#123;&#x27;8&#x27;, &#x27;5&#x27;, &#x27;9&#x27;, &#x27;7&#x27;, &#x27;6&#x27;, &#x27;1&#x27;, &#x27;4&#x27;, &#x27;2&#x27;, &#x27;3&#x27;&#125;, &#123;&#x27;4&#x27;, &#x27;2&#x27;, &#x27;6&#x27;, &#x27;8&#x27;, &#x27;5&#x27;, &#x27;3&#x27;, &#x27;7&#x27;, &#x27;9&#x27;, &#x27;1&#x27;&#125;, &#123;&#x27;7&#x27;, &#x27;1&#x27;, &#x27;3&#x27;, &#x27;9&#x27;, &#x27;2&#x27;, &#x27;4&#x27;, &#x27;8&#x27;, &#x27;5&#x27;, &#x27;6&#x27;&#125;, &#123;&#x27;9&#x27;, &#x27;6&#x27;, &#x27;1&#x27;, &#x27;5&#x27;, &#x27;3&#x27;, &#x27;7&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;4&#x27;&#125;, &#123;&#x27;2&#x27;, &#x27;8&#x27;, &#x27;7&#x27;, &#x27;4&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;6&#x27;, &#x27;3&#x27;, &#x27;5&#x27;&#125;, &#123;&#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;6&#x27;, &#x27;1&#x27;, &#x27;7&#x27;, &#x27;9&#x27;&#125; &#125;; static void print(char[][] table) &#123; for (char[] chars : table) &#123; System.out.println(new String(chars)); &#125; System.out.println(Arrays.deepEquals(table, solved)); &#125;&#125; 其它题目 题号 标题 说明 Leetcode 1219 黄金矿工 无 马踏棋盘（The Knight’s tour problem） 无 Rat in a Maze 与 Leetcode 62 不同路径区别在于，该题问的是有多少种走法，而本题只是找到其中一种走法实现 4.6 Leetcode 双指针下面是的题目都会涉及双指针，除此外，还有 Leetcode3 最长不重复子串，在 hash 表部分讲过了 快排中 二分中 … 移动零-Leetcode 283123456789101112131415161718192021public class MoveZeroesLeetcode283 &#123; static void moveZeroes(int[] nums) &#123; int i = 0; int j = 0; while (j &lt; nums.length) &#123; if (nums[j] != 0) &#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t; i++; &#125; j++; &#125; &#125; public static void main(String[] args) &#123; int[] nums = &#123;0, 1, 0, 3, 12&#125;; moveZeroes(nums); System.out.println(Arrays.toString(nums)); &#125;&#125; 两数之和 II-Leetcode 16712345678910111213141516171819202122public class SumLeetcode167 &#123; public static void main(String[] args) &#123; System.out.println(Arrays.toString(twoSum(new int[]&#123;2, 7, 11, 15&#125;, 9))); &#125; static public int[] twoSum(int[] numbers, int target) &#123; return twoSum(numbers, 0, numbers.length - 1, target); &#125; static int[] twoSum(int[] nums, int left, int right, int target) &#123; int i = left; int j = right; while (i &lt; j) &#123; if (nums[i] + nums[j] &lt; target) &#123; i++; &#125; else if (nums[i] + nums[j] &gt; target) &#123; j--; &#125; else &#123; break; &#125; &#125; return new int[]&#123;i + 1, j + 1&#125;; &#125;&#125; 与 Leetcode 1 的两数之和区别在于，本题的数组是升序排好的 三数之和-Leetcode 15123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class SumLeetcode15 &#123; static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); dfs(3, 0, nums.length - 1, 0, nums, new LinkedList&lt;&gt;(), result); return result; &#125; static void dfs(int n, int i, int j, int target, int[] nums, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (n == 2) &#123; // 套用两数之和求解 twoSum(i, j, nums, target, stack, result); return; &#125; for (int k = i; k &lt; j - (n - 2); k++) &#123; // 检查重复 if (k &gt; i &amp;&amp; nums[k] == nums[k - 1]) &#123; continue; &#125; // 固定一个数字，再尝试 n-1 数字之和 stack.push(nums[k]); dfs(n - 1, k + 1, j, target - nums[k], nums, stack, result); stack.pop(); &#125; &#125; static int count; static public void twoSum(int i, int j, int[] numbers, int target, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123; count++; while (i &lt; j) &#123; int sum = numbers[i] + numbers[j]; if (sum &lt; target) &#123; i++; &#125; else if (sum &gt; target) &#123; j--; &#125; else &#123; // 找到解 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(stack); list.add(numbers[i]); list.add(numbers[j]); result.add(list); // 继续查找其它的解 i++; j--; while (i &lt; j &amp;&amp; numbers[i] == numbers[i - 1]) &#123; i++; &#125; while (i &lt; j &amp;&amp; numbers[j] == numbers[j + 1]) &#123; j--; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); int[] candidates = &#123;-4, -1, -1, 0, 0, 1, 1, 2&#125;; System.out.println(&quot;数据量:&quot; + candidates.length); System.out.println(threeSum(candidates)); System.out.println(&quot;耗费时间:&quot; + (System.currentTimeMillis() - start)); System.out.println(&quot;递归次数:&quot; + count); &#125;&#125; 本题与之前的两数之和（Leetcode 1 和 Leetcode 167）相比，区别在于 两数之和里明确说了，只有一个答案，而本题要找出所有答案 本题要考虑去重 本题类似于 组合总和 II（Leetcode 40） 区别在于 40 题要求列出任意数之和等于 target 的所有组合，而本题要求三数之和等于 target 的所有组合 40 题使用回溯的办法时间复杂度是 $O(2^n * n)$，而本题的三数限制了递归次数仅有一次，并且每次递归终点是求两数之和时间复杂度为 $O(n)$，因此总时间复杂度为 $O(n^2)$ 小优化：固定数字时，应该预留三个数字做三数之和，预览两个数字做两数之和，因此有 k &lt; j - (n - 2) 四数之和-Leetcode 18123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class SumLeetcode18 &#123; static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); dfs(4, 0, nums.length - 1, target, nums, new LinkedList&lt;&gt;(), result); return result; &#125; static void dfs(int n, int i, int j, int target, int[] nums, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (n == 2) &#123; // 套用两数之和求解 twoSum(i, j, nums, target, stack, result); return; &#125; for (int k = i; k &lt; j - (n - 2); k++) &#123; // 四数之和 i &lt;j-2 三数之和 i &lt;j-1 // 检查重复 if (k &gt; i &amp;&amp; nums[k] == nums[k - 1]) &#123; continue; &#125; // 固定一个数字，再尝试 n-1 数字之和 stack.push(nums[k]); dfs(n - 1, k + 1, j, target - nums[k], nums, stack, result); stack.pop(); &#125; &#125; static int count; static public void twoSum(int i, int j, int[] numbers, int target, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result) &#123; count++; while (i &lt; j) &#123; int sum = numbers[i] + numbers[j]; if (sum &lt; target) &#123; i++; &#125; else if (sum &gt; target) &#123; j--; &#125; else &#123; // 找到解 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(stack); list.add(numbers[i]); list.add(numbers[j]); result.add(list); // 继续查找其它的解 i++; j--; while (i &lt; j &amp;&amp; numbers[i] == numbers[i - 1]) &#123; i++; &#125; while (i &lt; j &amp;&amp; numbers[j] == numbers[j + 1]) &#123; j--; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; System.out.println(fourSum(new int[]&#123;1, 0, -1, 0, -2, 2&#125;, 0));// System.out.println(fourSum(new int[]&#123;2, 2, 2, 2, 2&#125;, 8));// System.out.println(fourSum(new int[]&#123;1000000000,1000000000,1000000000,1000000000&#125;, -294967296)); &#125;&#125; 盛最多水的容器-Leetcode 111234567891011121314151617181920212223public class MostWaterLeetcode11 &#123; static int maxArea(int[] height) &#123; int i = 0; int j = height.length - 1; int max = 0; while (i &lt; j) &#123; int min = Integer.min(height[i], height[j]); max = Integer.max(max, (j - i) * min); while (i &lt; j &amp;&amp; height[i] &lt;= min) &#123; i++; &#125; while (i &lt; j &amp;&amp; height[j] &lt;= min) &#123; j--; &#125; &#125; return max; &#125; public static void main(String[] args) &#123; System.out.println(maxArea(new int[]&#123;1, 8, 6, 2, 5, 4, 8, 3, 7&#125;)); // 49 System.out.println(maxArea(new int[]&#123;2,1&#125;)); // 1 &#125;&#125; 反转字符数组-Leetcode 344双指针 12345678910111213141516171819202122232425public class ReverseStringLeetcode344 &#123; public static void main(String[] args) &#123; char[] array = &quot;abcde&quot;.toCharArray(); reverseString(array); System.out.println(Arrays.toString(array)); &#125; static void reverseString(char[] s) &#123; recursion(s, 0, s.length - 1); &#125; public static void recursion(char[] array, int i, int j) &#123; if (i &gt;= j) &#123; return; &#125; swap(array, i, j); recursion(array, ++i, --j); &#125; public static void swap(char[] array, int i, int j) &#123; char c = array[i]; array[i] = array[j]; array[j] = c; &#125;&#125; 第一次交换的是 array[0] 和 array[4] 第二次交换的是 array[1] 和 array[3] 第三次 i &#x3D; j &#x3D; 2，开始返回 如果 array.length 是偶数，则会在 i &gt; j 时返回 4.7 Leetcode 单调队列和栈单调递减队列12345678910111213141516171819202122232425262728293031public class MonotonicStack&lt;T extends Comparable&lt;T&gt;&gt; &#123; private final LinkedList&lt;T&gt; stack = new LinkedList&lt;&gt;(); public void push(T t) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek().compareTo(t) &lt; 0) &#123; stack.pop(); &#125; stack.push(t); &#125; public void pop() &#123; stack.pop(); &#125; public T peek() &#123; return stack.peek(); &#125; @Override public String toString() &#123; return stack.toString(); &#125; public static void main(String[] args) &#123; MonotonicStack&lt;Integer&gt; stack = new MonotonicStack&lt;&gt;(); for (int i : new int[]&#123;0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1&#125;) &#123; stack.push(i); System.out.println(stack); &#125; &#125;&#125; 最大滑动窗口-Leetcode 239123456789101112131415161718192021222324public class SlidingWindowMaximumLeetcode239 &#123; static int[] maxSlidingWindow(int[] nums, int k) &#123; MonotonicQueue&lt;Integer&gt; q = new MonotonicQueue&lt;&gt;(); int[] output = new int[nums.length - (k - 1)]; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt;= k &amp;&amp; nums[i - k] == q.peek()) &#123; q.poll(); &#125; int num = nums[i]; q.offer(num); if (i &gt;= k - 1) &#123; output[i - (k - 1)] = q.peek(); &#125; &#125; return output; &#125; public static void main(String[] args) &#123; System.out.println(Arrays.toString(maxSlidingWindow(new int[]&#123;1, 3, -1, -3, 5, 3, 6, 7&#125;, 3))); //[3, 3, 5, 5, 6, 7] System.out.println(Arrays.toString(maxSlidingWindow(new int[]&#123;7, 2, 4&#125;, 2))); // [7, 4] System.out.println(Arrays.toString(maxSlidingWindow(new int[]&#123;1, 3, 1, 2, 0, 5&#125;, 3))); // [3, 3, 2, 5] System.out.println(Arrays.toString(maxSlidingWindow(new int[]&#123;-7, -8, 7, 5, 7, 1, 6, 0&#125;, 4))); // [7, 7, 7, 7, 7] &#125;&#125; 如果每移动一次窗口，就在 k 个数里找最大值，时间复杂度约为 $O(n*k)$ 利用了单调队列后，每个元素都最多入队、出队一次，找最大值就在队头找，时间复杂度为 $O(n)$ 单调递减栈1234567891011121314151617181920212223242526272829303132333435public class MonotonicStack &#123; static class ValueAndIndex &#123; int value; int i; public ValueAndIndex(int value, int i) &#123; this.value = value; this.i = i; &#125; @Override public String toString() &#123;// return &quot;[%d]%d&quot;.formatted(index, value); return &quot;%d&quot;.formatted(value); &#125; &#125; private final LinkedList&lt;ValueAndIndex&gt; stack = new LinkedList&lt;&gt;(); public void push(int value, int i, TriConsumer onPop) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; value) &#123; ValueAndIndex pop = stack.pop(); ValueAndIndex peek = stack.peek(); if (peek != null) &#123; onPop.accept(pop.value, peek.value, peek.i); &#125; &#125; stack.push(new ValueAndIndex(value, i)); &#125; @Override public String toString() &#123; return stack.toString(); &#125;&#125; 接雨水-Leetcode 42123456789101112131415161718192021222324252627public class TrappingRainWaterLeetcode42 &#123; public static void main(String[] args) &#123; System.out.println(trap(new int[]&#123;0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1&#125;)); // 6 System.out.println(trap(new int[]&#123;4, 2, 0, 3, 2, 5&#125;)); // 9 &#125; record Data(int height, int i) &#123; &#125; static int trap(int[] heights) &#123; int sum = 0; LinkedList&lt;Data&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; heights.length; i++) &#123; Data right = new Data(heights[i], i); while (!stack.isEmpty() &amp;&amp; stack.peek().height &lt; heights[i]) &#123; Data pop = stack.pop(); Data left = stack.peek(); if (left != null) &#123; sum += (Integer.min(left.height, right.height) - pop.height) * (right.i - left.i - 1); &#125; &#125; stack.push(right); &#125; return sum; &#125;&#125; 维护一个单调栈 当加入新柱子（right）时，如果发现要弹出之前的柱子，表示遇到了凹陷的地方 此时栈里没有更左边的柱子，表示拦不住雨水 栈里有左边柱子（left）就可以计算雨水容量：$(right.i - left.i-1)*Min(right.height,left.height)-pop.height$ 4.8 Leetcode 字符串indexOf-Leetcode 28native string matching 123456789101112131415161718192021222324public class StrStrLeetcode28 &#123; static int strStr(String haystack, String needle) &#123; char[] text = haystack.toCharArray(); char[] pattern = needle.toCharArray(); int n = text.length; int m = pattern.length; for (int i = 0; i &lt;= n - m; i++) &#123; int j; for (j = 0; j &lt; m; j++) &#123; if (pattern[j] != text[i + j]) &#123; break; &#125; &#125; if (j == m) &#123; return i; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; System.out.println(strStr(&quot;aaacaaab&quot;, &quot;aaab&quot;)); &#125;&#125; kmp string matching 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class StrStrLeetcode28KMP &#123; static int strStr(String haystack, String needle) &#123; char[] text = haystack.toCharArray(); char[] pattern = needle.toCharArray(); int n = text.length; int m = pattern.length; int[] lps = lps(pattern); int i = 0; int j = 0; while ((n - i) &gt;= (m - j)) &#123; if (text[i] == pattern[j]) &#123; // 匹配成功 i++; j++; &#125; else if (j != 0) &#123; // 匹配失败 j = lsp[j - 1]; &#125; else &#123; // 匹配失败 j == 0 i++; &#125; if (j == m) &#123; // 找到解 return i - j; &#125; &#125; return -1; &#125; static int[] lps(char[] pattern) &#123; int[] lps = new int[pattern.length]; int i = 1; // 后缀 int j = 0; // 前缀 同时也是数量 while (i &lt; pattern.length) &#123; if (pattern[i] == pattern[j]) &#123; j++; lps[i] = j; i++; &#125; else if (j != 0) &#123; j = lps[j - 1]; &#125; else &#123; i++; &#125; &#125; return lps; &#125; public static void main(String[] args) &#123; System.out.println(strStr(&quot;aaaaaaab&quot;, &quot;aaab&quot;));// System.out.println(Arrays.toString(prefix(&quot;aaab&quot;.toCharArray()))); System.out.println(Arrays.toString(lsp(&quot;ababaca&quot;.toCharArray()))); &#125;&#125; 很多文章里[^17]，把 lps 数组的向后平移一位，lps 用 -1 填充，这个平移后的数组称为 next 这样可以用 -1 代替 j &#x3D;&#x3D; 0 的判断 并可以在 j &gt; 0 向前移动时，做少量优化（不用 next 数组也能做同样优化） 其它字符串匹配算法有：BM 算法、sunday 算法、Horspool 算法等 最长公共前缀-Leetcode 14123456789101112131415161718192021public class LCPLeetcode14 &#123; static String longestCommonPrefix(String[] strings) &#123; char[] first = strings[0].toCharArray(); for (int i = 0; i &lt; first.length; i++) &#123; char ch = first[i]; for (int j = 1; j &lt; strings.length; j++) &#123; if (i == strings[j].length() || ch != strings[j].charAt(i)) &#123; return new String(first, 0, i); &#125; &#125; &#125; return strings[0]; &#125; public static void main(String[] args) &#123; System.out.println(longestCommonPrefix(new String[]&#123;&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;&#125;)); // fl System.out.println(longestCommonPrefix(new String[]&#123;&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;&#125;)); // System.out.println(longestCommonPrefix(new String[]&#123;&quot;ab&quot;,&quot;a&quot;&#125;)); // a System.out.println(longestCommonPrefix(new String[]&#123;&quot;dog&quot;,&quot;dogaa&quot;,&quot;dogbb&quot;&#125;)); // dog &#125;&#125; 最长回文子串-Leetcode 51234567891011121314151617181920212223242526272829303132333435363738394041public class LongestPalindromeLeetcode5 &#123; public static void main(String[] args) &#123; System.out.println(longestPalindrome(&quot;babad&quot;)); // bab System.out.println(longestPalindrome(&quot;cbbd&quot;)); // bb System.out.println(longestPalindrome(&quot;a&quot;)); // a &#125; record Result(int i, int length) &#123; static Result max(Result r1, Result r2, Result r3) &#123; Result m = r1; if (r2.length &gt; m.length) &#123; m = r2; &#125; if (r3.length &gt; m.length) &#123; m = r3; &#125; return m; &#125; &#125; static String longestPalindrome(String s) &#123; char[] chars = s.toCharArray(); Result max = new Result(0, 1); for (int i = 0; i &lt; chars.length - 1; i++) &#123; Result r1 = extend(chars, i, i); Result r2 = extend(chars, i, i + 1); max = Result.max(max, r1, r2); &#125; return new String(chars, max.i, max.length); &#125; private static Result extend(char[] chars, int i, int j) &#123; int len = chars.length; while (i &gt;= 0 &amp;&amp; j &lt; len &amp;&amp; chars[i] == chars[j]) &#123; i--; j++; &#125; i++; return new Result(i, j - i); &#125;&#125; 还有时间复杂度更低的算法：Manacher 最小覆盖子串-Leetcode 76123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MinWindowLeetcode76_2 &#123; public static void main(String[] args) &#123; System.out.println(minWindow(&quot;ADOBECODEBANC&quot;, &quot;ABC&quot;)); // BANC System.out.println(minWindow(&quot;aaabbbbbcdd&quot;, &quot;abcdd&quot;)); // abbbbbcdd &#125; record Answer(int count, int i, int j) &#123; &#125; static String minWindow(String s, String t) &#123; char[] source = s.toCharArray(); char[] target = t.toCharArray(); int[] targetCountMap = new int[128]; int[] windowCountMap = new int[128]; for (char ch : target) &#123; targetCountMap[ch]++; &#125; int i = 0; int j = 0; Answer answer = new Answer(Integer.MAX_VALUE, i, j); int passCount = 0; for (int count : targetCountMap) &#123; if (count &gt; 0) &#123; passCount++; &#125; &#125; int pass = 0; while (j &lt; source.length) &#123; char right = source[j]; int c = ++windowCountMap[right]; if (c == targetCountMap[right]) &#123; pass++; &#125; while (pass == passCount &amp;&amp; i &lt;= j) &#123; if (j - i &lt; answer.count) &#123; answer = new Answer(j - i, i, j); &#125; char left = source[i]; windowCountMap[left]--; if (windowCountMap[left] &lt; targetCountMap[left]) &#123; pass--; &#125; i++; &#125; j++; &#125; return answer.count != Integer.MAX_VALUE ? s.substring(answer.i, answer.j + 1) : &quot;&quot;; &#125;&#125; 4.9 Leetcode 设计LRU 缓存-Leetcode 1461234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class LRUCacheLeetcode146 &#123; static class LRUCache &#123; static class Node &#123; Node prev; Node next; int key; int value; public Node(int key, int value) &#123; this.key = key; this.value = value; &#125; &#125; static class DoublyLinkedList &#123; private final Node head; private final Node tail; DoublyLinkedList() &#123; head = tail = new Node(-1, -1); head.next = tail; tail.prev = head; &#125; void addFirst(Node newFirst) &#123; Node oldFirst = head.next; newFirst.prev = head; newFirst.next = oldFirst; head.next = newFirst; oldFirst.prev = newFirst; &#125; void remove(Node node) &#123; Node prev = node.prev; Node next = node.next; prev.next = next; next.prev = prev; &#125; Node removeLast() &#123; Node last = tail.prev; remove(last); return last; &#125; &#125; private final HashMap&lt;Integer, Node&gt; map = new HashMap&lt;&gt;(); private final DoublyLinkedList linkedList = new DoublyLinkedList(); private final int capacity; public LRUCache(int capacity) &#123; this.capacity = capacity; &#125; public int get(int key) &#123; Node node = map.get(key); if (node == null) &#123; return -1; &#125; linkedList.remove(node); linkedList.addFirst(node); return node.value; &#125; public void put(int key, int value) &#123; if (map.containsKey(key)) &#123; Node node = map.get(key); node.value = value; linkedList.remove(node); linkedList.addFirst(node); &#125; else &#123; Node node = new Node(key, value); map.put(key, node); linkedList.addFirst(node); if (map.size() &gt; capacity) &#123; Node last = linkedList.removeLast(); map.remove(last.key); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; LRUCache cache = new LRUCache(2); cache.put(1, 1); cache.put(2, 2); System.out.println(cache.get(1)); // 1 cache.put(3, 3); System.out.println(cache.get(2)); // -1 cache.put(4, 4); System.out.println(cache.get(1)); // -1 System.out.println(cache.get(3)); // 3 &#125;&#125; 注意： 这里很重要的一点是，map 中存储 node，可以省去在双向链表中查找 node 的时间，这样让使用最近访问的节点移动到链表头时达到 $O(1)$ 的需求 同时我们应当意识到，node 的引用不能修改了（不方便修改，真要改得同时改链表） 例如，不能在更新时用新的 node 对象替换，而应该在原有的 node 上修改 value LFU 缓存-Leetcode 460123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public class LFUCacheLeetcode460 &#123; static class LFUCache &#123; static class Node &#123; Node prev; Node next; int key; int value; int freq; public Node() &#123; &#125; public Node(int key, int value, int freq) &#123; this.key = key; this.value = value; this.freq = freq; &#125; &#125; static class DoublyLinkedList &#123; private final Node head; private final Node tail; int size = 0; public DoublyLinkedList() &#123; head = tail = new Node(); head.next = tail; tail.prev = head; &#125; void remove(Node node) &#123; Node prev = node.prev; Node next = node.next; prev.next = next; next.prev = prev; node.prev = node.next = null; size--; &#125; void addFirst(Node newFirst) &#123; Node oldFirst = head.next; newFirst.prev = head; newFirst.next = oldFirst; head.next = newFirst; oldFirst.prev = newFirst; size++; &#125; Node removeLast() &#123; Node last = tail.prev; remove(last); return last; &#125; boolean isEmpty() &#123; return size == 0; &#125; &#125; private final HashMap&lt;Integer, DoublyLinkedList&gt; freqMap = new HashMap&lt;&gt;(); private final HashMap&lt;Integer, Node&gt; kvMap = new HashMap&lt;&gt;(); private final int capacity; private int minFreq; public LFUCache(int capacity) &#123; this.capacity = capacity; &#125; public int get(int key) &#123; Node node = kvMap.get(key); if (node == null) &#123; return -1; &#125; DoublyLinkedList list = freqMap.get(node.freq); list.remove(node); if (node.freq == minFreq &amp;&amp; list.isEmpty()) &#123; minFreq++; &#125; node.freq++; freqMap.computeIfAbsent(node.freq, k -&gt; new DoublyLinkedList()).addFirst(node); return node.value; &#125; public void put(int key, int value) &#123; if (kvMap.containsKey(key)) &#123; Node node = kvMap.get(key); DoublyLinkedList list = freqMap.get(node.freq); list.remove(node); if (node.freq == minFreq &amp;&amp; list.isEmpty()) &#123; minFreq++; &#125; node.freq++; node.value = value; freqMap.computeIfAbsent(node.freq, k -&gt; new DoublyLinkedList()).addFirst(node); &#125; else &#123; if (kvMap.size() == capacity) &#123; Node last = freqMap.get(minFreq).removeLast(); kvMap.remove(last.key); &#125; Node node = new Node(key, value, 1); kvMap.put(key, node); minFreq = 1; freqMap.computeIfAbsent(node.freq, k -&gt; new DoublyLinkedList()).addFirst(node); &#125; &#125; &#125; public static void main(String[] args) &#123; LFUCache cache = new LFUCache(2); cache.put(1, 1); cache.put(2, 2); System.out.println(cache.get(1)); // 1 freq=2 cache.put(3, 3); System.out.println(cache.get(2)); // -1 System.out.println(cache.get(3)); // 3 freq=2 cache.put(4, 4); System.out.println(cache.get(1)); // -1 System.out.println(cache.get(3)); // 3 freq=3 System.out.println(cache.get(4)); // 4 freq=2 &#125;&#125; 随机数线性同余发生器公式 $nextSeed &#x3D; (seed * a + c) \\mod m$ 123456789101112131415161718192021222324public class MyRandom &#123; private final int a; private final int c; private final int m; private int seed; public MyRandom(int a, int c, int m, int seed) &#123; this.a = a; this.c = c; this.m = m; this.seed = seed; &#125; public int nextInt() &#123; return seed = (a * seed + c) % m; &#125; public static void main(String[] args) &#123; MyRandom r1 = new MyRandom(7, 0, 11, 1); System.out.println(Arrays.toString(IntStream.generate(r1::nextInt).limit(30).toArray())); MyRandom r2 = new MyRandom(7, 0, Integer.MAX_VALUE, 1); System.out.println(Arrays.toString(IntStream.generate(r2::nextInt).limit(30).toArray())); &#125;&#125; 32 位随机数生成器 乘法会超过 int 范围导致随机性被破坏 java 版1234567891011121314151617181920212223public class MyRandom2 &#123; private static final long a = 0x5DEECE66DL; private static final long c = 0xBL; private static final long m = 1L &lt;&lt; 48; private long seed; public MyRandom2(long seed) &#123; this.seed = (seed ^ a) &amp; (m - 1); &#125; public int nextInt() &#123; seed = (a * seed + c) &amp; (m - 1); return ((int) (seed &gt;&gt;&gt; 16)); &#125; public static void main(String[] args) &#123; Random r1 = new Random(1); MyRandom2 r2 = new MyRandom2(1); System.out.println(Arrays.toString(IntStream.generate(r1::nextInt).limit(10).toArray())); System.out.println(Arrays.toString(IntStream.generate(r2::nextInt).limit(10).toArray())); &#125;&#125; 0x5DEECE66DL * 0x5DEECE66DL 不会超过 long 的范围 m 决定只取 48 位随机数 对于 nextInt，只取 48 位随机数的高 32 位 跳表-Leetcode 1206randomLevel设计一个方法调用若干次，每次返回 1~max 的数字，从 1 开始，返回数字的比例减半，例如 max &#x3D; 4，让大概 50% 的几率返回 1 25% 的几率返回 2 12.5% 的几率返回 3 12.5% 的几率返回 4 123456789101112/* 第一轮有 500 个(level 1) &gt;= 0.5 退出循环，剩下 500 个(level 2) 第二轮有 250 个(level 2) &gt;= 0.5 退出循环，剩下 125 个(level 3) 第三轮有 63 个(level 3) &gt;= 0.5 退出循环，剩下 62 个(level 4) 由于第二个条件退出循环 */static int randomLevel(int max) &#123; int level = 1; while (Math.random() &lt; 0.5 &amp;&amp; level &lt; max) &#123; level++; &#125; return level;&#125; 跳表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class SkipListLeetcode1206 &#123; public static void main(String[] args) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) &#123; int level = Skiplist.randomLevel(); map.compute(level, (k, v) -&gt; v == null ? 1 : v + 1); &#125; System.out.println(map.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -&gt; String.format(&quot;%d%%&quot;, e.getValue() * 100 / 1000)))); &#125; static class Skiplist &#123; static final int MAX = 4; static int randomLevel() &#123; int level = 1; while (Math.random() &lt; 0.5 &amp;&amp; level &lt; MAX) &#123; level++; &#125; /* 第一轮有 500 个(level 1) &gt;= 0.5 退出循环，剩下 500 个(level 2) 第二轮有 250 个(level 2) &gt;= 0.5 退出循环，剩下 125 个(level 3) 第三轮有 63 个(level 3) &gt;= 0.5 退出循环，剩下 62 个(level 4) 由于第二个条件退出循环 */ return level; &#125; private final Node head = new Node(-1); static class Node &#123; int val; Node[] next; public Node(int val) &#123; this.val = val; this.next = new Node[MAX]; &#125; &#125; private Node[] find(int val) &#123; Node[] path = new Node[MAX]; Node curr = head; for (int lvl = MAX - 1; lvl &gt;= 0; lvl--) &#123; while (curr.next[lvl] != null &amp;&amp; curr.next[lvl].val &lt; val) &#123; curr = curr.next[lvl]; &#125; path[lvl] = curr; &#125; return path; &#125; public boolean search(int val) &#123; Node[] path = find(val); Node node = path[0].next[0]; return node != null &amp;&amp; node.val == val; &#125; public void add(int val) &#123; Node[] path = find(val); int lv = randomLevel(); Node node = new Node(val); for (int i = 0; i &lt; lv; i++) &#123; node.next[i] = path[i].next[i]; path[i].next[i] = node; &#125; &#125; public boolean erase(int val) &#123; Node[] path = find(val); Node node = path[0].next[0]; if (node == null || node.val != val) &#123; return false; &#125; for (int i = 0; i &lt; MAX; i++) &#123; if (path[i].next[i] != node) &#123; break; &#125; path[i].next[i] = node.next[i]; &#125; return true; &#125; &#125;&#125; 下楼梯规则 若 next 指针为 null，或者 next 指向的节点值 &gt;&#x3D; 目标，向下找 若 next 指针不为 null，且 next 指向的节点值 &lt; 目标，向右找 节点的【高度】 高度并不需要额外属性来记录，而是由之前节点 next &#x3D;&#x3D; 本节点的个数来决定，或是本节点 next 数组长度 本实现选择了第一种方式来决定高度，本节点的 next 数组长度统一为 MAX 最小栈-Leetcode 155解法1 1234567891011121314151617181920212223242526272829static class MinStack &#123; LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; min = new LinkedList&lt;&gt;(); public MinStack() &#123; min.push(Integer.MAX_VALUE); &#125; public void push(int val) &#123; stack.push(val); min.push(Math.min(val, min.peek())); &#125; public void pop() &#123; if (stack.isEmpty()) &#123; return; &#125; stack.pop(); min.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min.peek(); &#125;&#125; 解法2 123456789101112131415161718192021222324252627static class MinStack2 &#123; record Data(int val, int min) &#123; &#125; final LinkedList&lt;Data&gt; stack = new LinkedList&lt;&gt;(); public void push(int val) &#123; if (stack.isEmpty()) &#123; stack.push(new Data(val, val)); &#125; else &#123; Data peek = stack.peek(); stack.push(new Data(val, Math.min(val, peek.min))); &#125; &#125; public void pop() &#123; stack.pop(); &#125; public int top() &#123; return stack.peek().val; &#125; public int getMin() &#123; return stack.peek().min; &#125;&#125; TinyURL 的加密与解密-Leetcode 535123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class TinyURLLeetcode535 &#123; public static void main(String[] args) &#123; /*CodecSequence codec = new CodecSequence(); String encoded = codec.encode(&quot;https://leetcode.cn/problems/1&quot;); System.out.println(encoded); encoded = codec.encode(&quot;https://leetcode.cn/problems/2&quot;); System.out.println(encoded);*/// for (int i = 0; i &lt;= 62; i++) &#123;// System.out.println(i + &quot;\\t&quot; + CodecSequence.toBase62(i));// &#125; System.out.println(CodecSequence.toBase62(237849728)); &#125; /* 要让【长】【短】网址一一对应 1. 用【随机数】作为短网址标识 2. 用【hash码】作为短网址标识 3. 用【递增数】作为短网址标识 1) 多线程下可以使用吗？ 2) 分布式下可以使用吗？ 3) 4e9iAk 是怎么生成的？ a-z 0-9 A-Z 62进制的数字 0 1 2 3 4 5 6 7 8 9 a b c d e f 十进制 =&gt; 十六进制 31 1f 31 % 16 = 15 31 / 16 = 1 1 % 16 = 1 1 / 16 = 0 长网址： https://leetcode.cn/problems/encode-and-decode-tinyurl/description/ 对应的短网址： http://tinyurl.com/4e9iAk */ static class CodecSequence &#123; private static final char[] toBase62 = &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27; &#125;; public static String toBase62(int number) &#123; if (number == 0) &#123; return String.valueOf(toBase62[0]); &#125; StringBuilder sb = new StringBuilder(); while (number &gt; 0) &#123; int r = number % 62; sb.append(toBase62[r]); number = number / 62; &#125; return sb.toString(); &#125; private final Map&lt;String, String&gt; longToShort = new HashMap&lt;&gt;(); private final Map&lt;String, String&gt; shortToLong = new HashMap&lt;&gt;(); private static final String SHORT_PREFIX = &quot;http://tinyurl.com/&quot;; private static int id = 1; public String encode(String longUrl) &#123; String shortUrl = longToShort.get(longUrl); if (shortUrl != null) &#123; return shortUrl; &#125; // 生成短网址 shortUrl = SHORT_PREFIX + id; longToShort.put(longUrl, shortUrl); shortToLong.put(shortUrl, longUrl); id++; return shortUrl; &#125; public String decode(String shortUrl) &#123; return shortToLong.get(shortUrl); &#125; &#125; static class CodecHashCode &#123; private final Map&lt;String, String&gt; longToShort = new HashMap&lt;&gt;(); private final Map&lt;String, String&gt; shortToLong = new HashMap&lt;&gt;(); private static final String SHORT_PREFIX = &quot;http://tinyurl.com/&quot;; public String encode(String longUrl) &#123; String shortUrl = longToShort.get(longUrl); if (shortUrl != null) &#123; return shortUrl; &#125; // 生成短网址 int id = longUrl.hashCode(); // int while (true) &#123; shortUrl = SHORT_PREFIX + id; if (!shortToLong.containsKey(shortUrl)) &#123; longToShort.put(longUrl, shortUrl); shortToLong.put(shortUrl, longUrl); break; &#125; id++; &#125; return shortUrl; &#125; public String decode(String shortUrl) &#123; return shortToLong.get(shortUrl); &#125; &#125; static class CodecRandom &#123; private final Map&lt;String, String&gt; longToShort = new HashMap&lt;&gt;(); private final Map&lt;String, String&gt; shortToLong = new HashMap&lt;&gt;(); private static final String SHORT_PREFIX = &quot;http://tinyurl.com/&quot;; public String encode(String longUrl) &#123; String shortUrl = longToShort.get(longUrl); if (shortUrl != null) &#123; return shortUrl; &#125; // 生成短网址 while (true) &#123; int id = ThreadLocalRandom.current().nextInt();// 1 shortUrl = SHORT_PREFIX + id; if (!shortToLong.containsKey(shortUrl)) &#123; longToShort.put(longUrl, shortUrl); shortToLong.put(shortUrl, longUrl); break; &#125; &#125; return shortUrl; &#125; public String decode(String shortUrl) &#123; return shortToLong.get(shortUrl); &#125; &#125;&#125; 设计 Twitter-Leetcode 355线性合并 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105static class Twitter2 &#123; static int time; static class Tweet &#123; int id; int time; Tweet next; public Tweet(int id, int time, Tweet next) &#123; this.id = id; this.time = time; this.next = next; &#125; public int id() &#123; return id; &#125; public int time() &#123; return time; &#125; &#125; static class User &#123; Integer id; public User(Integer id) &#123; this.id = id; &#125; Set&lt;Integer&gt; followees = new HashSet&lt;&gt;(); Tweet head = new Tweet(-1, -1, null); &#125; private final Map&lt;Integer, User&gt; userMap = new HashMap&lt;Integer, User&gt;(); public void postTweet(int userId, int tweetId) &#123; User user = userMap.computeIfAbsent(userId, User::new); user.head.next = new Tweet(tweetId, time++, user.head.next); &#125; public List&lt;Integer&gt; getNewsFeed(int userId) &#123; User user = userMap.get(userId); if (user == null) &#123; return List.of(); &#125; Tweet p1 = user.head.next; for (Integer id : user.followees) &#123; p1 = merge(p1, userMap.get(id).head.next); &#125; LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); int count = 0; while (p1 != null &amp;&amp; count &lt; 10) &#123; result.addLast(p1.id); p1 = p1.next; count++; &#125; return result; &#125; private Tweet merge(Tweet p1, Tweet p2) &#123; Tweet head = new Tweet(-1, -1, null); Tweet p0 = head; int count = 0; while (p1 != null &amp;&amp; p2 != null &amp;&amp; count &lt; 10) &#123; if (p1.time &gt; p2.time) &#123; p0.next = new Tweet(p1.id, p1.time, null); p0 = p0.next; p1 = p1.next; &#125; else &#123; p0.next = new Tweet(p2.id, p2.time, null); p0 = p0.next; p2 = p2.next; &#125; count++; &#125; while (p1 != null &amp;&amp; count &lt; 10) &#123; p0.next = new Tweet(p1.id, p1.time, null); p0 = p0.next; p1 = p1.next; count++; &#125; while (p2 != null &amp;&amp; count &lt; 10) &#123; p0.next = new Tweet(p2.id, p2.time, null); p0 = p0.next; p2 = p2.next; count++; &#125; return head.next; &#125; public void follow(int userId, int followeeId) &#123; User user = userMap.computeIfAbsent(userId, User::new); User followee = userMap.computeIfAbsent(followeeId, User::new); user.followees.add(followeeId); &#125; public void unfollow(int userId, int followeeId) &#123; User user = userMap.get(userId); if (user != null) &#123; user.followees.remove(followeeId); &#125; &#125;&#125; 优先级队列合并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class TwitterLeetcode355 &#123; static class Twitter &#123; static class Tweet &#123; int id; int time; Tweet next; public Tweet(int id, int time, Tweet next) &#123; this.id = id; this.time = time; this.next = next; &#125; public int getId() &#123; return id; &#125; public int getTime() &#123; return time; &#125; &#125; static class User &#123; int id; public User(int id) &#123; this.id = id; &#125; Set&lt;Integer&gt; followees = new HashSet&lt;&gt;(); Tweet head = new Tweet(-1, -1, null); &#125; private final Map&lt;Integer, User&gt; userMap = new HashMap&lt;&gt;(); private static int time; // 发布文章 public void postTweet(int userId, int tweetId) &#123; User user = userMap.computeIfAbsent(userId, User::new); user.head.next = new Tweet(tweetId, time++, user.head.next); &#125; // 新增关注 public void follow(int userId, int followeeId) &#123; User user = userMap.computeIfAbsent(userId, User::new); User followee = userMap.computeIfAbsent(followeeId, User::new); user.followees.add(followee.id); &#125; // 取消关注 public void unfollow(int userId, int followeeId) &#123; User user = userMap.get(userId); if (user != null) &#123; user.followees.remove(followeeId); &#125; &#125; // 获取最新10篇文章（包括自己和关注用户） public List&lt;Integer&gt; getNewsFeed(int userId) &#123; User user = userMap.get(userId); if (user == null) &#123; return List.of(); &#125; PriorityQueue&lt;Tweet&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(Tweet::getTime).reversed()); if(user.head.next != null) &#123; queue.offer(user.head.next); &#125; for (Integer id : user.followees) &#123; User followee = userMap.get(id); if(followee.head.next != null) &#123; queue.offer(followee.head.next); &#125; &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int count = 0; while (!queue.isEmpty() &amp;&amp; count &lt; 10) &#123; Tweet max = queue.poll(); res.add(max.id); if (max.next != null) &#123; queue.offer(max.next); &#125; count++; &#125; return res; &#125; &#125;&#125; 4.10 股票问题Leetcode 121123456789101112131415161718192021public class SharesI &#123; static int maxProfit(int[] prices) &#123; int i = 0; int j = 1; int max = 0; while (j &lt; prices.length) &#123; if (prices[j] - prices[i] &gt; 0) &#123; max = Math.max(max, prices[j] - prices[i]); j++; &#125; else &#123; i = j; j++; &#125; &#125; return max; &#125; public static void main(String[] args) &#123; System.out.println(maxProfit(new int[]&#123;9, 3, 12, 1, 2, 3, 11&#125;)); &#125;&#125; Leetcode 1221234567891011121314151617181920public class SharesIILeetcode122 &#123; static int maxProfit(int[] prices) &#123; int i = 0; int j = 1; int max = 0; while (j &lt; prices.length) &#123; if (prices[j] - prices[i] &gt; 0) &#123; // 有利润 max += prices[j] - prices[i]; &#125; i = j; j++; &#125; return max; &#125; public static void main(String[] args) &#123; System.out.println(maxProfit(new int[]&#123;9, 3, 12, 1, 2, 3&#125;)); // 11 System.out.println(maxProfit(new int[]&#123;7, 1, 5, 3, 6, 4&#125;)); // 7 &#125;&#125; Leetcode 7141234567891011121314151617181920212223242526272829303132public class SharesLeetcode714 &#123; /* 0 1 2 3 4 5 1 3 2 8 4 9 买 -1 等-1 √ 等-1 √ 等-1 √ -1 等1 √ 买-3 买-2 买-8 买1 √ 买-4 卖 0 等0 √ 等0 √ 等0 等5 √ 等5 卖0 卖-1 卖5 √ 卖1 卖8 √ */ static int maxProfit(int[] prices, int fee) &#123; int b1 = -prices[0]; int s1 = 0; for (int i = 1; i &lt; prices.length; i++) &#123; int s0 = Math.max(s1, b1 + prices[i] - fee); int b0 = Math.max(b1, s1 - prices[i]); s1 = s0; b1 = b0; &#125; return s1; &#125; public static void main(String[] args) &#123; System.out.println(maxProfit(new int[]&#123;1, 3, 2, 8, 4, 9&#125;, 2)); // 8 System.out.println(maxProfit(new int[]&#123;1, 3, 7, 2, 18, 3&#125;, 3)); // 16// System.out.println(maxProfit(new int[]&#123;1, 3, 7, 5, 10, 3&#125;, 3)); // 6 System.out.println(maxProfit(new int[]&#123;1, 3, 7, 5, 10, 11, 3&#125;, 3)); // 7 System.out.println(maxProfit(new int[]&#123;2,1,4,4,2,3,2,5,1,2&#125;, 1)); // 4 &#125;&#125; 降维 123456789101112static int maxProfit(int[] prices, int fee) &#123; // _buy _sell 代表上一次 buy sell 代表这一次 int _buy = -prices[0]; int _sell = 0; for (int i = 1; i &lt; prices.length; i++) &#123; int buy = Math.max(_buy, _sell - prices[i]); int sell = Math.max(_sell, _buy + prices[i] - fee); _buy = buy; _sell = sell; &#125; return _sell;&#125; 结构优化（非性能） 1234567891011121314151617static int maxProfit(int[] prices, int fee) &#123; int buy = Integer.MIN_VALUE; int sell = 0; for (int price : prices) &#123; buy = Math.max(buy, sell - price); /* 若 max 是 上次 buy，那么显然用这次 buy 是一样的 若 max 是 上次 sell - prices[i], 则 Math.max(sell, sell - prices[i] + prices[i] - fee); ==&gt; Math.max(sell, sell - fee); 显然后面的式子不可能比上次 sell 更大，此时新的 sell 只由上次 sell 决定，与 上次 buy 无关 */ sell = Math.max(sell, buy + price - fee); &#125; return sell;&#125; 在计算这次的 sell 时，用这次的 buy 代替上次 buy（证明见上方注释） 设置 buy 的初始值为最小，可以让循环统一从 0 开始 Leetcode 30912345678910111213141516171819202122232425262728293031public class SharesLeetcode309 &#123; /* 0 1 2 3 4 1 2 3 0 2 买 -1 -2 -3 1√ 0 等 -1√ -1√ -1 1√ 卖 0 1√ 2√ -1 3√ 等 0 1 2√ 2 */ static int maxProfit(int[] prices) &#123; if (prices.length == 1) &#123; return 0; &#125; int[] buy = new int[prices.length]; int[] sell = new int[prices.length]; buy[0] = -prices[0]; sell[0] = 0; buy[1] = Math.max(-prices[0], -prices[1]); sell[1] = Math.max(sell[0], buy[0] + prices[1]); for (int i = 2; i &lt; prices.length; i++) &#123; buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]); &#125; return sell[prices.length - 1]; &#125; public static void main(String[] args) &#123; System.out.println(maxProfit(new int[]&#123;1, 2, 3, 0, 2&#125;)); // 3 &#125;&#125; 降维 12345678910111213141516static int maxProfit(int[] prices) &#123; if (prices.length == 1) &#123; return 0; &#125; int __sell = 0; int _sell = 0; int _buy = -prices[0]; for (int i = 1; i &lt; prices.length; i++) &#123; int buy = Math.max(_buy, __sell - prices[i]); int sell = Math.max(_sell, prices[i] + _buy); _buy = buy; __sell = _sell; _sell = sell; &#125; return _sell;&#125; Leetcode 12312345678910111213141516171819public class SharesIIILeetcode123 &#123; static int maxProfit(int[] prices) &#123; int buy1 = Integer.MIN_VALUE; int sell1 = 0; int buy2 = Integer.MIN_VALUE; int sell2 = 0; for (int price : prices) &#123; buy1 = Math.max(buy1, -price); sell1 = Math.max(sell1, buy1 + price); buy2 = Math.max(buy2, sell1 - price); sell2 = Math.max(sell2, buy2 + price); &#125; return sell2; &#125; public static void main(String[] args) &#123; System.out.println(maxProfit(new int[]&#123;3, 3, 5, 0, 0, 3, 1, 4&#125;)); // 6 &#125;&#125; Leetcode 1881234567891011121314151617181920212223242526272829303132333435363738public class SharesLeetcode188 &#123; static int maxProfit(int[] prices) &#123; int i = 0; int j = 1; int sum = 0; while (j &lt; prices.length) &#123; if (prices[j] - prices[i] &gt; 0) &#123; // 有利润 sum += prices[j] - prices[i]; &#125; i++; j++; &#125; return sum; &#125; static int maxProfit(int k, int[] prices) &#123; if (k &gt; prices.length / 2) &#123; return maxProfit(prices); &#125; int[] buy = new int[k]; int[] sell = new int[k]; Arrays.fill(buy, Integer.MIN_VALUE); for (int price : prices) &#123; buy[0] = Math.max(buy[0], -price); sell[0] = Math.max(sell[0], buy[0] + price); for (int j = 1; j &lt; k; j++) &#123; buy[j] = Math.max(buy[j], sell[j - 1] - price); sell[j] = Math.max(sell[j], buy[j] + price); &#125; &#125; return sell[k - 1]; &#125; public static void main(String[] args) &#123;// System.out.println(maxProfit(2, new int[]&#123;3, 2, 6, 5, 0, 3&#125;)); // 7 System.out.println(maxProfit(2, new int[]&#123;3, 3, 5, 0, 0, 3, 1, 4&#125;)); // 6 &#125;&#125; 对于天数 n &#x3D; 6，最多进行 3 次交易，如果此时 k &gt; 3，意味着不限次交易 对于天数 n &#x3D; 7，最多进行 3 次交易，如果此时 k &gt; 3，意味着不限次交易 附录参考文章[^1]: “Definition of ALGORITHM”. Merriam-Webster Online Dictionary. Archived from the original on February 14, 2020. Retrieved November 14, 2019.[^2]: Introduction to Algorithm 中文译作《算法导论》[^3]: 主要参考文档 https://en.wikipedia.org/wiki/Binary_search_algorithm[^4]: 图片及概念均摘自 Introduction to Algorithm 4th，3.1节，3.2 节[^5]: 图片引用自 wikipedia linkedlist 条目，https://en.wikipedia.org/wiki/Linked_list [^6]: 也称为 Pascal’s triangle https://en.wikipedia.org/wiki/Pascal%27s_triangle [^7]: 递归求解斐波那契数列的时间复杂度——几种简洁证明 - 知乎 (zhihu.com)[^8]: Fibonacci 介绍：https://en.wikipedia.org/wiki/Fibonacci_number[^9]: 几种计算Fibonacci数列算法的时间复杂度比较 - 知乎 (zhihu.com)[^10]: 几种斐波那契数列算法比较 Fast Fibonacci algorithms (nayuki.io) [^11]: 我知道的有 C++，Scala[^12]: jdk 版本有关，64 位 jdk，按 8 字节对齐[^13]: 汉诺塔图片资料均来自 https://en.wikipedia.org/wiki/Tower_of_Hanoi[^14]: 与主定理类似的还有 Akra–Bazzi method，https://en.wikipedia.org/wiki/Akra%E2%80%93Bazzi_method [^15]: 龟兔赛跑动画来自于 Floyd’s Hare and Tortoise Algorithm Demo - One Step! Code (onestepcode.com) [^16]: Josephus problem 主要参考 https://en.wikipedia.org/wiki/Josephus_problem [^17]: KMP 算法中 next 数组的说明 KMP算法的Next数组详解 - 唐小喵 - 博客园 (cnblogs.com) 推荐图书入门图书 系统学习 扩展阅读 面试 案头装 B 吐槽 英文版封面设计本来挺好看的，机工非要套个黑壳子 力扣高评价题目列表引用自 面试最常考的 100 道算法题分类整理！ - 知乎 (zhihu.com) 带 ✔️ 是本课程讲解过的 1. Two Sum (两数之和), Easy, 11757 likes ✔️ 2. Add Two Numbers (两数相加), Medium, 6524 likes ✔️ 3. Longest Substring Without Repeating Characters (无重复字符的最长子串), Medium, 5845 likes ✔️ 4. Median of Two Sorted Arrays (寻找两个正序数组的中位数), Hard, 4303 likes 5. Longest Palindromic Substring (最长回文子串), Medium, 3896 likes ✔️ 15. 3Sum (三数之和), Medium, 3582 likes ✔️ 53. Maximum Subarray (最大子序和), Easy, 3533 likes 7. Reverse Integer (整数反转), Easy, 2970 likes 11. Container With Most Water (盛最多水的容器), Medium, 2659 likes ✔️ 42. Trapping Rain Water (接雨水), Hard, 2552 likes ✔️ 20. Valid Parentheses (有效的括号), Easy, 2544 likes ✔️ 10. Regular Expression Matching (正则表达式匹配), Hard, 2273 likes 26. Remove Duplicates from Sorted Array (删除有序数组中的重复项), Easy, 2146 likes ✔️ 136. Single Number (只出现一次的数字), Easy, 1958 likes ✔️ 22. Generate Parentheses (括号生成), Medium, 1946 likes ✔️ 206. Reverse Linked List (反转链表), Easy, 1886 likes ✔️ 21. Merge Two Sorted Lists (合并两个有序链表), Easy, 1832 likes ✔️ 70. Climbing Stairs (爬楼梯), Easy, 1791 likes ✔️ 300. Longest Increasing Subsequence (最长递增子序列), Medium, 1773 likes ✔️ 121. Best Time to Buy and Sell Stock (买卖股票的最佳时机), Easy, 1766 likes ✔️ 72. Edit Distance (编辑距离), Hard, 1743 likes 14. Longest Common Prefix (最长公共前缀), Easy, 1707 likes ✔️ 198. House Robber (打家劫舍), Medium, 1585 likes ✔️ 9. Palindrome Number (回文数), Easy, 1568 likes 146. LRU Cache (LRU 缓存机制), Medium, 1544 likes ✔️ 19. Remove Nth Node From End of List (删除链表的倒数第 N 个结点), Medium, 1494 likes ✔️ 33. Search in Rotated Sorted Array (搜索旋转排序数组), Medium, 1493 likes 46. Permutations (全排列), Medium, 1484 likes ✔️ 101. Symmetric Tree (对称二叉树), Easy, 1483 likes ✔️ 84. Largest Rectangle in Histogram (柱状图中最大的矩形), Hard, 1472 likes 39. Combination Sum (组合总和), Medium, 1466 likes ✔️ 13. Roman to Integer (罗马数字转整数), Easy, 1436 likes 23. Merge k Sorted Lists (合并K个升序链表), Hard, 1436 likes ✔️ 17. Letter Combinations of a Phone Number (电话号码的字母组合), Medium, 1436 likes 322. Coin Change (零钱兑换), Medium, 1414 likes ✔️ 32. Longest Valid Parentheses (最长有效括号), Hard, 1400 likes 287. Find the Duplicate Number (寻找重复数), Medium, 1325 likes 122. Best Time to Buy and Sell Stock II (买卖股票的最佳时机 II), Easy, 1306 likes ✔️ 160. Intersection of Two Linked Lists (相交链表), Easy, 1302 likes ✔️ 55. Jump Game (跳跃游戏), Medium, 1292 likes 76. Minimum Window Substring (最小覆盖子串), Hard, 1280 likes ✔️ 200. Number of Islands (岛屿数量), Medium, 1270 likes 78. Subsets (子集), Medium, 1269 likes 31. Next Permutation (下一个排列), Medium, 1260 likes 96. Unique Binary Search Trees (不同的二叉搜索树), Medium, 1257 likes ✔️ 148. Sort List (排序链表), Medium, 1248 likes 236. Lowest Common Ancestor of a Binary Tree (二叉树的最近公共祖先), Medium, 1238 likes ✔️ 25. Reverse Nodes in k-Group (K 个一组翻转链表), Hard, 1230 likes 6. ZigZag Conversion (Z 字形变换), Medium, 1226 likes 152. Maximum Product Subarray (乘积最大子数组), Medium, 1223 likes 215. Kth Largest Element in an Array (数组中的第K个最大元素), Medium, 1211 likes ✔️ 8. String to Integer (atoi) (字符串转换整数 (atoi)), Medium, 1168 likes 41. First Missing Positive (缺失的第一个正数), Hard, 1163 likes 283. Move Zeroes (移动零), Easy, 1162 likes ✔️ 141. Linked List Cycle (环形链表), Easy, 1161 likes ✔️ 98. Validate Binary Search Tree (验证二叉搜索树), Medium, 1156 likes ✔️ 124. Binary Tree Maximum Path Sum (二叉树中的最大路径和), Hard, 1152 likes 105. Construct Binary Tree from Preorder and Inorder Traversal (从前序与中序遍历序列构造二叉树), Medium, 1149 likes ✔️ 34. Find First and Last Position of Element in Sorted Array (在排序数组中查找元素的第一个和最后一个位置), Medium, 1137 likes ✔️ 239. Sliding Window Maximum (滑动窗口最大值), Hard, 1114 likes ✔️ 142. Linked List Cycle II (环形链表 II), Medium, 1097 likes ✔️ 139. Word Break (单词拆分), Medium, 1097 likes 45. Jump Game II (跳跃游戏 II), Medium, 1094 likes 169. Majority Element (多数元素), Easy, 1089 likes 234. Palindrome Linked List (回文链表), Easy, 1072 likes ✔️ 62. Unique Paths (不同路径), Medium, 1072 likes ✔️ 189. Rotate Array (旋转数组), Medium, 1057 likes 94. Binary Tree Inorder Traversal (二叉树的中序遍历), Easy, 1052 likes ✔️ 56. Merge Intervals (合并区间), Medium, 1051 likes 88. Merge Sorted Array (合并两个有序数组), Easy, 1041 likes ✔️ 560. Subarray Sum Equals K (和为K的子数组), Medium, 1036 likes 279. Perfect Squares (完全平方数), Medium, 1035 likes 35. Search Insert Position (搜索插入位置), Easy, 1005 likes ✔️ 24. Swap Nodes in Pairs (两两交换链表中的节点), Medium, 996 likes 85. Maximal Rectangle (最大矩形), Hard, 983 likes 28. Implement strStr() (实现 strStr()), Easy, 982 likes ✔️ 92. Reverse Linked List II (反转链表 II), Medium, 980 likes 155. Min Stack (最小栈), Easy, 979 likes ✔️ 79. Word Search (单词搜索), Medium, 979 likes 27. Remove Element (移除元素), Easy, 967 likes 51. N-Queens (N 皇后), Hard, 965 likes ✔️ 75. Sort Colors (颜色分类), Medium, 961 likes 102. Binary Tree Level Order Traversal (二叉树的层序遍历), Medium, 960 likes ✔️ 48. Rotate Image (旋转图像), Medium, 960 likes 95. Unique Binary Search Trees II (不同的二叉搜索树 II), Medium, 955 likes 64. Minimum Path Sum (最小路径和), Medium, 954 likes 406. Queue Reconstruction by Height (根据身高重建队列), Medium, 947 likes 226. Invert Binary Tree (翻转二叉树), Easy, 941 likes ✔️ 437. Path Sum III (路径总和 III), Medium, 937 likes 104. Maximum Depth of Binary Tree (二叉树的最大深度), Easy, 937 likes ✔️ 237. Delete Node in a Linked List (删除链表中的节点), Easy, 936 likes ✔️ 337. House Robber III (打家劫舍 III), Medium, 929 likes 18. 4Sum (四数之和), Medium, 918 likes ✔️ 91. Decode Ways (解码方法), Medium, 904 likes 207. Course Schedule (课程表), Medium, 897 likes 37. Sudoku Solver (解数独), Hard, 897 likes ✔️ 175. Combine Two Tables (组合两个表), Easy, 891 likes 416. Partition Equal Subset Sum (分割等和子集), Medium, 886 likes 238. Product of Array Except Self (除自身以外数组的乘积), Medium, 885 likes 114. Flatten Binary Tree to Linked List (二叉树展开为链表), Medium, 877 likes","tags":["java"],"categories":["java"]},{"title":"招协工作总结","path":"/2024/08/25/招协工作总结/","content":"招协工作总结加入招协+&emsp;&emsp;2023年入学前，我作为大一新生加入了西安邮电大学的官方咨询群，后面了解到里面有很多回答问题的学长学姐来自西安邮电大学招生协会。&emsp;&emsp;我自以为对高考志愿报名有些熟悉，并招协是我在大学认识的第一个社团，向往之心难以抑制，很快就加入了招协的纳新群。经过学姐们的两次面试，也是成功加入了西邮招协综合事务部。 社团工作~&emsp;&emsp;招协作为学校一级社团，在校期间的社团工作并不算多，也没有网上说的整天开会写文章的那种琐事，就是主打一个轻松愉快，（学姐还请我们喝奶茶真不戳哈哈。&emsp;&emsp;到了寒假，寒假宣传活动也随之到来。我也拿着学校给的物料回到高中母校，热心地给学弟学妹们介绍西安邮电大学，&emsp;&emsp;2024年的暑假才是真正需要干活的时候。在报志愿期间要在招生办接听考生的电话，耐心地为考生和家长说明学校的政策和计划安排。 外派任务！&emsp;&emsp;记忆最深的就是那次外派任务，第一次有了学校给的身份出去外派（hahahah），是在西安太白中学，好像就是以前的西电附中把…硕大的太阳无法阻挡家长的咨询，也或许是对孩子的担心让家长无法停下，我也是经历过高考的学生，唯一能做的也就是为这些家长们提供更准确的消息，也好让他们少一些焦虑。&emsp;&emsp;Tips:学校的饭还挺丰盛挺好吃的 At the End&emsp;&emsp;招协的生活很简单，也很喜欢，很可惜没有成功留部，即使不在社团了也要为学校发光发热啊Bi8bo…… &emsp;&emsp;想写点东西总结一下，发现失去了好文笔","tags":["校园"],"categories":["校园"]},{"title":"C++核心编程","path":"/2024/08/20/C++核心编程/","content":"C++核心编程本阶段主要针对C++ &#x3D;&#x3D;面向对象&#x3D;&#x3D; 编程技术做详细讲解，探讨C++中的核心和精髓。 1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 1.1 程序运行前​\t在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 ​\t代码区： ​ 存放 CPU 执行的机器指令 ​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 ​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 ​\t全局区： ​ 全局变量和静态变量存放在此. ​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ​ &#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;. 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243//全局变量int g_a = 10;int g_b = 10;//全局常量const int c_g_a = 10;const int c_g_b = 10;int main() &#123;\t//局部变量\tint a = 10;\tint b = 10;\t//打印地址\tcout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\tcout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\tcout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl;\tcout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl;\t//静态变量\tstatic int s_a = 10;\tstatic int s_b = 10;\tcout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\tcout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\tcout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\tcout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\tconst int c_l_a = 10;\tconst int c_l_b = 10;\tcout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\tcout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 打印结果： 总结： C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后​\t栈区： ​ 由编译器自动分配释放, 存放函数的参数值,局部变量等 ​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 示例： 1234567891011121314151617int * func()&#123;\tint a = 10;\treturn &amp;a;&#125;int main() &#123;\tint *p = func();\tcout &lt;&lt; *p &lt;&lt; endl;\tcout &lt;&lt; *p &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; ​\t堆区： ​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 ​ 在C++中主要利用new在堆区开辟内存 示例： 1234567891011121314151617int* func()&#123;\tint* a = new int(10);\treturn a;&#125;int main() &#123;\tint *p = func();\tcout &lt;&lt; *p &lt;&lt; endl;//防止误操作，编译器会做一次保留\tcout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;);\treturn 0;&#125; 总结： 堆区数据由程序员管理开辟和释放 堆区数据利用new关键字进行开辟内存 1.3 new操作符​\tC++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据 ​\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D; ​\t语法： new 数据类型 ​\t利用new创建的数据，会返回该数据对应的类型的指针 示例1： 基本语法 12345678910111213141516171819202122int* func()&#123;\tint* a = new int(10);\treturn a;&#125;int main() &#123;\tint *p = func();\tcout &lt;&lt; *p &lt;&lt; endl;\tcout &lt;&lt; *p &lt;&lt; endl;\t//利用delete释放堆区数据\tdelete p;\t//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问\tsystem(&quot;pause&quot;);\treturn 0;&#125; 示例2：开辟数组 12345678910111213141516171819202122//堆区开辟数组int main() &#123;\tint* arr = new int[10];\tfor (int i = 0; i &lt; 10; i++)\t&#123; arr[i] = i + 100;\t&#125;\tfor (int i = 0; i &lt; 10; i++)\t&#123; cout &lt;&lt; arr[i] &lt;&lt; endl;\t&#125;\t//释放数组 delete 后加 []\tdelete[] arr;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 2 引用2.1 引用的基本使用**作用： **给变量起别名 语法： 数据类型 &amp;别名 = 原名 示例： 1234567891011121314151617int main() &#123;\tint a = 10;\tint &amp;b = a;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tb = 100;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例： 12345678910111213141516int main() &#123;\tint a = 10;\tint b = 20;\t//int &amp;c; //错误，引用必须初始化\tint &amp;c = a; //一旦初始化后，就不可以更改\tc = b; //这是赋值操作，不是更改引用\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//1. 值传递void mySwap01(int a, int b) &#123;\tint temp = a;\ta = b;\tb = temp;&#125;//2. 地址传递void mySwap02(int* a, int* b) &#123;\tint temp = *a;\t*a = *b;\t*b = temp;&#125;//3. 引用传递void mySwap03(int&amp; a, int&amp; b) &#123;\tint temp = a;\ta = b;\tb = temp;&#125;int main() &#123;\tint a = 10;\tint b = 20;\tmySwap01(a, b);\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\tmySwap02(&amp;a, &amp;b);\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\tmySwap03(a, b);\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单 2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 示例： 123456789101112131415161718192021222324252627282930313233//返回局部变量引用int&amp; test01() &#123;\tint a = 10; //局部变量\treturn a;&#125;//返回静态变量引用int&amp; test02() &#123;\tstatic int a = 20;\treturn a;&#125;int main() &#123;\t//不能返回局部变量的引用\tint&amp; ref = test01();\tcout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\tcout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\t//如果函数做左值，那么必须返回引用\tint&amp; ref2 = test02();\tcout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\tcout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ttest02() = 1000;\tcout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\tcout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; ​ 2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量. 讲解示例： 1234567891011121314151617//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref)&#123;\tref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123;\tint a = 10; //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\tint&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a);\treturn 0;&#125; 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作 在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参 示例： 1234567891011121314151617181920212223//引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) &#123;\t//v += 10;\tcout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123;\t//int&amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误\t//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;\tconst int&amp; ref = 10;\t//ref = 100; //加入const后不可以修改变量\tcout &lt;&lt; ref &lt;&lt; endl;\t//函数中利用常量引用防止误操作修改实参\tint a = 10;\tshowValue(a);\tsystem(&quot;pause&quot;);\treturn 0;&#125; 3 函数提高3.1 函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。 语法： 返回值类型 函数名 （参数= 默认值）&#123;&#125; 示例： 1234567891011121314151617181920int func(int a, int b = 10, int c = 10) &#123;\treturn a + b + c;&#125;//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a = 10, int b = 10);int func2(int a, int b) &#123;\treturn a + b;&#125;int main() &#123;\tcout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\tcout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 3.2 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 语法： 返回值类型 函数名 (数据类型)&#123;&#125; 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 示例： 12345678910111213//函数占位参数 ，占位参数也可以有默认参数void func(int a, int) &#123;\tcout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;&#125;int main() &#123;\tfunc(10,10); //占位参数必须填补\tsystem(&quot;pause&quot;);\treturn 0;&#125; 3.3 函数重载3.3.1 函数重载概述作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同 注意: 函数的返回值不可以作为函数重载的条件 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041//函数重载需要函数都在同一个作用域下void func()&#123;\tcout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;&#125;void func(int a)&#123;\tcout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a)&#123;\tcout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;&#125;void func(int a ,double b)&#123;\tcout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a ,int b)&#123;\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;&#125;//函数返回值不可以作为函数重载条件//int func(double a, int b)//&#123;//\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;//&#125;int main() &#123;\tfunc();\tfunc(10);\tfunc(3.14);\tfunc(10,3.14);\tfunc(3.14 , 10); system(&quot;pause&quot;);\treturn 0;&#125; 3.3.2 函数重载注意事项 引用作为重载条件 函数重载碰到函数默认参数 示例： 123456789101112131415161718192021222324252627282930313233343536373839//函数重载注意事项//1、引用作为重载条件void func(int &amp;a)&#123;\tcout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;void func(const int &amp;a)&#123;\tcout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;//2、函数重载碰到函数默认参数void func2(int a, int b = 10)&#123;\tcout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl;&#125;void func2(int a)&#123;\tcout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;&#125;int main() &#123; int a = 10;\tfunc(a); //调用无const\tfunc(10);//调用有const\t//func2(10); //碰到默认参数产生歧义，需要避免\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4 类和对象C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D; C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为 例如： ​\t人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌… ​\t车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调… ​\t具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类 4.1 封装4.1.1 封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： ​\t在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名&#123; 访问权限： 属性 / 行为 &#125;; 示例1：设计一个圆类，求圆的周长 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839//圆周率const double PI = 3.14;//1、封装的意义//将属性和行为作为一个整体，用来表现生活中的事物//封装一个圆类，求圆的周长//class代表设计一个类，后面跟着的是类名class Circle&#123;public: //访问权限 公共的权限\t//属性\tint m_r;//半径\t//行为\t//获取到圆的周长\tdouble calculateZC()\t&#123; //2 * pi * r //获取圆的周长 return 2 * PI * m_r;\t&#125;&#125;;int main() &#123;\t//通过圆类，创建圆的对象\t// c1就是一个具体的圆\tCircle c1;\tc1.m_r = 10; //给圆对象的半径 进行赋值操作\t//2 * pi * 10 = = 62.8\tcout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号 示例2代码： 123456789101112131415161718192021222324252627282930//学生类class Student &#123;public:\tvoid setName(string name) &#123; m_name = name;\t&#125;\tvoid setID(int id) &#123; m_id = id;\t&#125;\tvoid showStudent() &#123; cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\t&#125;public:\tstring m_name;\tint m_id;&#125;;int main() &#123;\tStudent stu;\tstu.setName(&quot;德玛西亚&quot;);\tstu.setID(250);\tstu.showStudent();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 封装意义二： 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 示例： 123456789101112131415161718192021222324252627282930313233343536373839//三种权限//公共权限 public 类内可以访问 类外可以访问//保护权限 protected 类内可以访问 类外不可以访问//私有权限 private 类内可以访问 类外不可以访问class Person&#123;\t//姓名 公共权限public:\tstring m_Name;\t//汽车 保护权限protected:\tstring m_Car;\t//银行卡密码 私有权限private:\tint m_Password;public:\tvoid func()\t&#123; m_Name = &quot;张三&quot;; m_Car = &quot;拖拉机&quot;; m_Password = 123456;\t&#125;&#125;;int main() &#123;\tPerson p;\tp.m_Name = &quot;李四&quot;;\t//p.m_Car = &quot;奔驰&quot;; //保护权限类外访问不到\t//p.m_Password = 123; //私有权限类外访问不到\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.1.2 struct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同 区别： struct 默认权限为公共 class 默认权限为私有 12345678910111213141516171819202122class C1&#123;\tint m_A; //默认是私有权限&#125;;struct C2&#123;\tint m_A; //默认是公共权限&#125;;int main() &#123;\tC1 c1;\tc1.m_A = 10; //错误，访问权限是私有\tC2 c2;\tc2.m_A = 10; //正确，访问权限是公共\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.1.3 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限 优点2：对于写权限，我们可以检测数据的有效性 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Person &#123;public:\t//姓名设置可读可写\tvoid setName(string name) &#123; m_Name = name;\t&#125;\tstring getName()\t&#123; return m_Name;\t&#125;\t//获取年龄 int getAge() &#123; return m_Age;\t&#125;\t//设置年龄\tvoid setAge(int age) &#123; if (age &lt; 0 || age &gt; 150) &#123; cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl; return; &#125; m_Age = age;\t&#125;\t//情人设置为只写\tvoid setLover(string lover) &#123; m_Lover = lover;\t&#125;private:\tstring m_Name; //可读可写 姓名 int m_Age; //只读 年龄\tstring m_Lover; //只写 情人&#125;;int main() &#123;\tPerson p;\t//姓名设置\tp.setName(&quot;张三&quot;);\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\t//年龄设置\tp.setAge(50);\tcout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\t//情人设置\tp.setLover(&quot;苍井&quot;);\t//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl; //只写属性，不可以读取\tsystem(&quot;pause&quot;);\treturn 0;&#125; 练习案例1：设计立方体类 设计立方体类(Cube) 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等。 练习案例2：点和圆的关系 设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。 4.2 对象的初始化和清理 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。 4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 ​\t一个对象或者变量没有初始状态，对其使用后果是未知 ​\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供 编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名()&#123;&#125; 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名()&#123;&#125; 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 1234567891011121314151617181920212223242526272829class Person&#123;public:\t//构造函数\tPerson()\t&#123; cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;\t&#125;\t//析构函数\t~Person()\t&#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\tPerson p;&#125;int main() &#123; test01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.2 构造函数的分类及调用两种分类方式： ​\t按参数分为： 有参构造和无参构造 ​\t按类型分为： 普通构造和拷贝构造 三种调用方式： ​\t括号法 ​\t显示法 ​\t隐式转换法 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//1、构造函数分类// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person &#123;public:\t//无参（默认）构造函数\tPerson() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//有参构造函数\tPerson(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//拷贝构造函数\tPerson(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\t&#125;\t//析构函数\t~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t&#125;public:\tint age;&#125;;//2、构造函数的调用//调用无参构造函数void test01() &#123;\tPerson p; //调用无参构造函数&#125;//调用有参的构造函数void test02() &#123;\t//2.1 括号法，常用\tPerson p1(10);\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\t//Person p2();\t//2.2 显式法\tPerson p2 = Person(10); Person p3 = Person(p2);\t//Person(10)单独写就是匿名对象 当前行结束之后，马上析构\t//2.3 隐式转换法\tPerson p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\t//Person p5(p4);&#125;int main() &#123;\ttest01();\t//test02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Person &#123;public:\tPerson() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; mAge = 0;\t&#125;\tPerson(int age) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; mAge = age;\t&#125;\tPerson(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; mAge = p.mAge;\t&#125;\t//析构函数在释放内存之前调用\t~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t&#125;public:\tint mAge;&#125;;//1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() &#123;\tPerson man(100); //p对象已经创建完毕\tPerson newman(man); //调用拷贝构造函数\tPerson newman2 = man; //拷贝构造\t//Person newman3;\t//newman3 = man; //不是调用拷贝构造函数，赋值操作&#125;//2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) &#123;&#125;void test02() &#123;\tPerson p; //无参构造函数\tdoWork(p);&#125;//3. 以值方式返回局部对象Person doWork2()&#123;\tPerson p1;\tcout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;\treturn p1;&#125;void test03()&#123;\tPerson p = doWork2();\tcout &lt;&lt; (int *)&amp;p &lt;&lt; endl;&#125;int main() &#123;\t//test01();\t//test02();\ttest03();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person &#123;public:\t//无参（默认）构造函数\tPerson() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//有参构造函数\tPerson(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//拷贝构造函数\tPerson(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\t&#125;\t//析构函数\t~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t&#125;public:\tint age;&#125;;void test01()&#123;\tPerson p1(18);\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\tPerson p2(p1);\tcout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;void test02()&#123;\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\tPerson p1; //此时如果用户自己没有提供默认构造，会出错\tPerson p2(10); //用户提供的有参\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供\t//如果用户提供拷贝构造，编译器不会提供其他构造函数\tPerson p4; //此时如果用户自己没有提供默认构造，会出错\tPerson p5(10); //此时如果用户自己没有提供有参，会出错\tPerson p6(p5); //用户自己提供拷贝构造&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Person &#123;public:\t//无参（默认）构造函数\tPerson() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//有参构造函数\tPerson(int age ,int height) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; m_age = age; m_height = new int(height); &#125;\t//拷贝构造函数 Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height); &#125;\t//析构函数\t~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; if (m_height != NULL) &#123; delete m_height; &#125;\t&#125;public:\tint m_age;\tint* m_height;&#125;;void test01()&#123;\tPerson p1(18, 180);\tPerson p2(p1);\tcout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\tcout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 4.2.6 初始化列表作用： C++提供了初始化列表语法，用来初始化属性 语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125; 示例： 123456789101112131415161718192021222324252627282930313233class Person &#123;public:\t////传统方式初始化\t//Person(int a, int b, int c) &#123;\t//\tm_A = a;\t//\tm_B = b;\t//\tm_C = c;\t//&#125;\t//初始化列表方式初始化\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;\tvoid PrintPerson() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\t&#125;private:\tint m_A;\tint m_B;\tint m_C;&#125;;int main() &#123;\tPerson p(1, 2, 3);\tp.PrintPerson();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： 12345class A &#123;&#125;class B&#123; A a；&#125; B类中有对象A作为成员，A为对象成员 那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？ 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Phone&#123;public:\tPhone(string name)\t&#123; m_PhoneName = name; cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;\t&#125;\t~Phone()\t&#123; cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\t&#125;\tstring m_PhoneName;&#125;;class Person&#123;public:\t//初始化列表可以告诉编译器调用哪一个构造函数\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\t&#123; cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\t&#125;\t~Person()\t&#123; cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\t&#125;\tvoid playGame()\t&#123; cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\t&#125;\tstring m_Name;\tPhone m_Phone;&#125;;void test01()&#123;\t//当类中成员是其他类对象时，我们称该成员为 对象成员\t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造\t//析构顺序与构造相反\tPerson p(&quot;张三&quot; , &quot;苹果X&quot;);\tp.playGame();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 示例1 ：静态成员变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person&#123;\tpublic:\tstatic int m_A; //静态成员变量\t//静态成员变量特点：\t//1 在编译阶段分配内存\t//2 类内声明，类外初始化\t//3 所有对象共享同一份数据private:\tstatic int m_B; //静态成员变量也是有访问权限的&#125;;int Person::m_A = 10;int Person::m_B = 10;void test01()&#123;\t//静态成员变量两种访问方式\t//1、通过对象\tPerson p1;\tp1.m_A = 100;\tcout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\tPerson p2;\tp2.m_A = 200;\tcout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据\tcout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\t//2、通过类名\tcout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\t//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 示例2：静态成员函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person&#123;public:\t//静态成员函数特点：\t//1 程序共享一个函数\t//2 静态成员函数只能访问静态成员变量 static void func()\t&#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量\t&#125;\tstatic int m_A; //静态成员变量\tint m_B; // private:\t//静态成员函数也是有访问权限的\tstatic void func2()\t&#123; cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\t&#125;&#125;;int Person::m_A = 10;void test01()&#123;\t//静态成员变量两种访问方式\t//1、通过对象\tPerson p1;\tp1.func();\t//2、通过类名\tPerson::func();\t//Person::func2(); //私有权限访问不到&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 1234567891011121314151617181920212223242526class Person &#123;public:\tPerson() &#123; mA = 0;\t&#125;\t//非静态成员变量占对象空间\tint mA;\t//静态成员变量不占对象空间\tstatic int mB; //函数也不占对象空间，所有函数共享一个函数实例\tvoid func() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;\t&#125;\t//静态成员函数也不占对象空间\tstatic void sfunc() &#123;\t&#125;&#125;;int main() &#123;\tcout &lt;&lt; sizeof(Person) &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this 1234567891011121314151617181920212223242526272829303132333435363738class Person&#123;public:\tPerson(int age)\t&#123; //1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age = age;\t&#125;\tPerson&amp; PersonAddPerson(Person p)\t&#123; this-&gt;age += p.age; //返回对象本身 return *this;\t&#125;\tint age;&#125;;void test01()&#123;\tPerson p1(10);\tcout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl;\tPerson p2(10);\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\tcout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.3.3 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 示例： 12345678910111213141516171819202122232425262728293031323334//空指针访问成员函数class Person &#123;public:\tvoid ShowClassName() &#123; cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\t&#125;\tvoid ShowPerson() &#123; if (this == NULL) &#123; return; &#125; cout &lt;&lt; mAge &lt;&lt; endl;\t&#125;public:\tint mAge;&#125;;void test01()&#123;\tPerson * p = NULL;\tp-&gt;ShowClassName(); //空指针，可以调用成员函数\tp-&gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.3.4 const修饰成员函数常函数： 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Person &#123;public:\tPerson() &#123; m_A = 0; m_B = 0;\t&#125;\t//this指针的本质是一个指针常量，指针的指向不可修改\t//如果想让指针指向的值也不可以修改，需要声明常函数\tvoid ShowPerson() const &#123; //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B = 100;\t&#125;\tvoid MyFunc() const &#123; //mA = 10000;\t&#125;public:\tint m_A;\tmutable int m_B; //可修改 可变的&#125;;//const修饰对象 常对象void test01() &#123;\tconst Person person; //常量对象 cout &lt;&lt; person.m_A &lt;&lt; endl;\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\t//常对象访问成员函数\tperson.MyFunc(); //常对象不能调用const的函数&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 &#x3D;&#x3D;friend&#x3D;&#x3D; 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142class Building&#123;\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\tfriend void goodGay(Building * building);public:\tBuilding()\t&#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;;\t&#125;public:\tstring m_SittingRoom; //客厅private:\tstring m_BedRoom; //卧室&#125;;void goodGay(Building * building)&#123;\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;\tBuilding b;\tgoodGay(&amp;b);&#125;int main()&#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.4.2 类做友元12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Building;class goodGay&#123;public:\tgoodGay();\tvoid visit();private:\tBuilding *building;&#125;;class Building&#123;\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\tfriend class goodGay;public:\tBuilding();public:\tstring m_SittingRoom; //客厅private:\tstring m_BedRoom;//卧室&#125;;Building::Building()&#123;\tthis-&gt;m_SittingRoom = &quot;客厅&quot;;\tthis-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;\tbuilding = new Building;&#125;void goodGay::visit()&#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;\tgoodGay gg;\tgg.visit();&#125;int main()&#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.4.3 成员函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Building;class goodGay&#123;public:\tgoodGay();\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\tvoid visit2(); private:\tBuilding *building;&#125;;class Building&#123;\t//告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\tfriend void goodGay::visit();public:\tBuilding();public:\tstring m_SittingRoom; //客厅private:\tstring m_BedRoom;//卧室&#125;;Building::Building()&#123;\tthis-&gt;m_SittingRoom = &quot;客厅&quot;;\tthis-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;\tbuilding = new Building;&#125;void goodGay::visit()&#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void goodGay::visit2()&#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\t//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;\tgoodGay gg;\tgg.visit();&#125;int main()&#123; test01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Person &#123;public:\tPerson() &#123;&#125;;\tPerson(int a, int b)\t&#123; this-&gt;m_A = a; this-&gt;m_B = b;\t&#125;\t//成员函数实现 + 号运算符重载\tPerson operator+(const Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp;\t&#125;public:\tint m_A;\tint m_B;&#125;;//全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;//\tPerson temp(0, 0);//\ttemp.m_A = p1.m_A + p2.m_A;//\ttemp.m_B = p1.m_B + p2.m_B;//\treturn temp;//&#125;//运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val) &#123;\tPerson temp;\ttemp.m_A = p2.m_A + val;\ttemp.m_B = p2.m_B + val;\treturn temp;&#125;void test() &#123;\tPerson p1(10, 10);\tPerson p2(20, 20);\t//成员函数方式\tPerson p3 = p2 + p1; //相当于 p2.operaor+(p1)\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\tPerson p4 = p3 + 10; //相当于 operator+(p3,10)\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;int main() &#123;\ttest();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的 总结2：不要滥用运算符重载 4.5.2 左移运算符重载作用：可以输出自定义数据类型 123456789101112131415161718192021222324252627282930313233343536373839404142class Person &#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public:\tPerson(int a, int b)\t&#123; this-&gt;m_A = a; this-&gt;m_B = b;\t&#125;\t//成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果\t//void operator&lt;&lt;(Person&amp; p)&#123;\t//&#125;private:\tint m_A;\tint m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;\tout &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;\treturn out;&#125;void test() &#123;\tPerson p1(10, 20);\tcout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程&#125;int main() &#123;\ttest();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：重载左移运算符配合友元可以实现输出自定义数据类型 4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyInteger &#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);public:\tMyInteger() &#123; m_Num = 0;\t&#125;\t//前置++\tMyInteger&amp; operator++() &#123; //先++ m_Num++; //再返回 return *this;\t&#125;\t//后置++\tMyInteger operator++(int) &#123; //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp;\t&#125;private:\tint m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;\tout &lt;&lt; myint.m_Num;\treturn out;&#125;//前置++ 先++ 再返回void test01() &#123;\tMyInteger myInt;\tcout &lt;&lt; ++myInt &lt;&lt; endl;\tcout &lt;&lt; myInt &lt;&lt; endl;&#125;//后置++ 先返回 再++void test02() &#123;\tMyInteger myInt;\tcout &lt;&lt; myInt++ &lt;&lt; endl;\tcout &lt;&lt; myInt &lt;&lt; endl;&#125;int main() &#123;\ttest01();\t//test02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 前置递增返回引用，后置递增返回值 4.5.4 赋值运算符重载c++编译器至少给一个类添加4个函数 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator&#x3D;, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person&#123;public:\tPerson(int age)\t&#123; //将年龄数据开辟到堆区 m_Age = new int(age);\t&#125;\t//重载赋值运算符 Person&amp; operator=(Person &amp;p)\t&#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this;\t&#125;\t~Person()\t&#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125;\t&#125;\t//年龄的指针\tint *m_Age;&#125;;void test01()&#123;\tPerson p1(18);\tPerson p2(20);\tPerson p3(30);\tp3 = p2 = p1; //赋值操作\tcout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\t//int a = 10;\t//int b = 20;\t//int c = 30;\t//c = b = a;\t//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\t//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\t//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Person&#123;public:\tPerson(string name, int age)\t&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;\t&#125;;\tbool operator==(Person &amp; p)\t&#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125;\t&#125;\tbool operator!=(Person &amp; p)\t&#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; else &#123; return true; &#125;\t&#125;\tstring m_Name;\tint m_Age;&#125;;void test01()&#123;\t//int a = 0;\t//int b = 0;\tPerson a(&quot;孙悟空&quot;, 18);\tPerson b(&quot;孙悟空&quot;, 18);\tif (a == b)\t&#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\t&#125;\telse\t&#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\t&#125;\tif (a != b)\t&#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\t&#125;\telse\t&#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.5.6 函数调用运算符重载 函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyPrint&#123;public:\tvoid operator()(string text)\t&#123; cout &lt;&lt; text &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//重载的（）操作符 也称为仿函数\tMyPrint myFunc;\tmyFunc(&quot;hello world&quot;);&#125;class MyAdd&#123;public:\tint operator()(int v1, int v2)\t&#123; return v1 + v2;\t&#125;&#125;;void test02()&#123;\tMyAdd add;\tint ret = add(10, 10);\tcout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;\t//匿名对象调用 cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.6 继承继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，例如下图中： 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Java页面class Java &#123;public:\tvoid header()\t&#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;\tvoid content()\t&#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//Python页面class Python&#123;public:\tvoid header()\t&#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;\tvoid content()\t&#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//C++页面class CPP &#123;public:\tvoid header()\t&#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;\tvoid content()\t&#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//Java页面\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\tJava ja;\tja.header();\tja.footer();\tja.left();\tja.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//Python页面\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\tPython py;\tpy.header();\tpy.footer();\tpy.left();\tpy.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//C++页面\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\tCPP cp;\tcp.header();\tcp.footer();\tcp.left();\tcp.content();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 继承实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//公共页面class BasePage&#123;public:\tvoid header()\t&#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;&#125;;//Java页面class Java : public BasePage&#123;public:\tvoid content()\t&#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//Python页面class Python : public BasePage&#123;public:\tvoid content()\t&#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//C++页面class CPP : public BasePage&#123;public:\tvoid content()\t&#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//Java页面\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\tJava ja;\tja.header();\tja.footer();\tja.left();\tja.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//Python页面\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\tPython py;\tpy.header();\tpy.footer();\tpy.left();\tpy.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//C++页面\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\tCPP cp;\tcp.header();\tcp.footer();\tcp.left();\tcp.content();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D; class A : public B; A 类称为子类 或 派生类 B 类称为父类 或 基类 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 4.6.2 继承方式继承的语法：class 子类 : 继承方式 父类 继承方式一共有三种： 公共继承 保护继承 私有继承 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Base1&#123;public: int m_A;protected:\tint m_B;private:\tint m_C;&#125;;//公共继承class Son1 :public Base1&#123;public:\tvoid func()\t&#123; m_A; //可访问 public权限 m_B; //可访问 protected权限 //m_C; //不可访问\t&#125;&#125;;void myClass()&#123;\tSon1 s1;\ts1.m_A; //其他类只能访问到公共权限&#125;//保护继承class Base2&#123;public:\tint m_A;protected:\tint m_B;private:\tint m_C;&#125;;class Son2:protected Base2&#123;public:\tvoid func()\t&#123; m_A; //可访问 protected权限 m_B; //可访问 protected权限 //m_C; //不可访问\t&#125;&#125;;void myClass2()&#123;\tSon2 s;\t//s.m_A; //不可访问&#125;//私有继承class Base3&#123;public:\tint m_A;protected:\tint m_B;private:\tint m_C;&#125;;class Son3:private Base3&#123;public:\tvoid func()\t&#123; m_A; //可访问 private权限 m_B; //可访问 private权限 //m_C; //不可访问\t&#125;&#125;;class GrandSon3 :public Son3&#123;public:\tvoid func()\t&#123; //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 //m_A; //m_B; //m_C;\t&#125;&#125;; 4.6.3 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？ 示例： 123456789101112131415161718192021222324252627282930class Base&#123;public:\tint m_A;protected:\tint m_B;private:\tint m_C; //私有成员只是被隐藏了，但是还是会继承下去&#125;;//公共继承class Son :public Base&#123;public:\tint m_D;&#125;;void test01()&#123;\tcout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 利用工具查看： 打开工具窗口后，定位到当前CPP文件的盘符 然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名 所属文件名 效果如下图： 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到 4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 问题：父类和子类的构造和析构顺序是谁先谁后？ 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142class Base &#123;public:\tBase()\t&#123; cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;\t&#125;\t~Base()\t&#123; cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;\t&#125;&#125;;class Son : public Base&#123;public:\tSon()\t&#123; cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;\t&#125;\t~Son()\t&#123; cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\tSon s;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Base &#123;public:\tBase()\t&#123; m_A = 100;\t&#125;\tvoid func()\t&#123; cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\t&#125;\tvoid func(int a)\t&#123; cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\t&#125;public:\tint m_A;&#125;;class Son : public Base &#123;public:\tSon()\t&#123; m_A = 200;\t&#125;\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\tvoid func()\t&#123; cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\t&#125;public:\tint m_A;&#125;;void test01()&#123;\tSon s;\tcout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\tcout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\ts.func();\ts.Base::func();\ts.Base::func(10);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn EXIT_SUCCESS;&#125; 总结： 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？ 静态成员和非静态成员出现同名，处理方式一致 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Base &#123;public:\tstatic void func()\t&#123; cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;\t&#125;\tstatic void func(int a)\t&#123; cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;\t&#125;\tstatic int m_A;&#125;;int Base::m_A = 100;class Son : public Base &#123;public:\tstatic void func()\t&#123; cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;\t&#125;\tstatic int m_A;&#125;;int Son::m_A = 200;//同名成员属性void test01()&#123;\t//通过对象访问\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\tSon s;\tcout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\tcout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\t//通过类名访问\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\tcout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;&#125;//同名成员函数void test02()&#123;\t//通过对象访问\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\tSon s;\ts.func();\ts.Base::func();\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\tSon::func();\tSon::Base::func();\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\tSon::Base::func(100);&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名） 4.6.7 多继承语法C++允许一个类继承多个类 语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议用多继承 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Base1 &#123;public:\tBase1()\t&#123; m_A = 100;\t&#125;public:\tint m_A;&#125;;class Base2 &#123;public:\tBase2()\t&#123; m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确\t&#125;public:\tint m_A;&#125;;//语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123;public:\tSon()\t&#123; m_C = 300; m_D = 400;\t&#125;public:\tint m_C;\tint m_D;&#125;;//多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01()&#123;\tSon s;\tcout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;\tcout &lt;&lt; s.Base1::m_A &lt;&lt; endl;\tcout &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域 4.6.8 菱形继承菱形继承概念： ​\t两个派生类继承同一个基类 ​\t又有某个类同时继承者两个派生类 ​\t这种继承被称为菱形继承，或者钻石继承 典型的菱形继承案例： 菱形继承问题： 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 示例： 1234567891011121314151617181920212223242526272829303132class Animal&#123;public:\tint m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123;\tSheepTuo st;\tst.Sheep::m_Age = 100;\tst.Tuo::m_Age = 200;\tcout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态4.7.1 多态的基本概念多态是C++面向对象三大特性之一 多态分为两类 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 下面通过案例进行讲解多态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Animal&#123;public:\t//Speak函数就是虚函数\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\tvirtual void speak()\t&#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;\t&#125;&#125;;class Cat :public Animal&#123;public:\tvoid speak()\t&#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;\t&#125;&#125;;class Dog :public Animal&#123;public:\tvoid speak()\t&#123; cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\t&#125;&#125;;//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal &amp; animal)&#123;\tanimal.speak();&#125;////多态满足条件： //1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象void test01()&#123;\tCat cat;\tDoSpeak(cat);\tDog dog;\tDoSpeak(dog);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 多态满足条件 有继承关系 子类重写父类中的虚函数 多态使用条件 父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 4.7.2 多态案例一-计算器类案例描述： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//普通实现class Calculator &#123;public:\tint getResult(string oper)\t&#123; if (oper == &quot;+&quot;) &#123; return m_Num1 + m_Num2; &#125; else if (oper == &quot;-&quot;) &#123; return m_Num1 - m_Num2; &#125; else if (oper == &quot;*&quot;) &#123; return m_Num1 * m_Num2; &#125; //如果要提供新的运算，需要修改源码\t&#125;public:\tint m_Num1;\tint m_Num2;&#125;;void test01()&#123;\t//普通实现测试\tCalculator c;\tc.m_Num1 = 10;\tc.m_Num2 = 10;\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;//多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator&#123;public :\tvirtual int getResult()\t&#123; return 0;\t&#125;\tint m_Num1;\tint m_Num2;&#125;;//加法计算器class AddCalculator :public AbstractCalculator&#123;public:\tint getResult()\t&#123; return m_Num1 + m_Num2;\t&#125;&#125;;//减法计算器class SubCalculator :public AbstractCalculator&#123;public:\tint getResult()\t&#123; return m_Num1 - m_Num2;\t&#125;&#125;;//乘法计算器class MulCalculator :public AbstractCalculator&#123;public:\tint getResult()\t&#123; return m_Num1 * m_Num2;\t&#125;&#125;;void test02()&#123;\t//创建加法计算器\tAbstractCalculator *abc = new AddCalculator;\tabc-&gt;m_Num1 = 10;\tabc-&gt;m_Num2 = 10;\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\tdelete abc; //用完了记得销毁\t//创建减法计算器\tabc = new SubCalculator;\tabc-&gt;m_Num1 = 10;\tabc-&gt;m_Num2 = 10;\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\tdelete abc; //创建乘法计算器\tabc = new MulCalculator;\tabc-&gt;m_Num1 = 10;\tabc-&gt;m_Num2 = 10;\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\tdelete abc;&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多 4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D; 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例： 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public:\t//纯虚函数\t//类中只要有一个纯虚函数就称为抽象类\t//抽象类无法实例化对象\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\tvirtual void func() = 0;&#125;;class Son :public Base&#123;public:\tvirtual void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\t&#125;;&#125;;void test01()&#123;\tBase * base = NULL;\t//base = new Base; // 错误，抽象类无法实例化对象\tbase = new Son;\tbase-&gt;func();\tdelete base;//记得销毁&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.7.4 多态案例二-制作饮品案例描述： 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//抽象制作饮品class AbstractDrinking &#123;public:\t//烧水\tvirtual void Boil() = 0;\t//冲泡\tvirtual void Brew() = 0;\t//倒入杯中\tvirtual void PourInCup() = 0;\t//加入辅料\tvirtual void PutSomething() = 0;\t//规定流程\tvoid MakeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething();\t&#125;&#125;;//制作咖啡class Coffee : public AbstractDrinking &#123;public:\t//烧水\tvirtual void Boil() &#123; cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;\t&#125;\t//冲泡\tvirtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;\t&#125;\t//倒入杯中\tvirtual void PourInCup() &#123; cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;\t&#125;\t//加入辅料\tvirtual void PutSomething() &#123; cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;\t&#125;&#125;;//制作茶水class Tea : public AbstractDrinking &#123;public:\t//烧水\tvirtual void Boil() &#123; cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;\t&#125;\t//冲泡\tvirtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;\t&#125;\t//倒入杯中\tvirtual void PourInCup() &#123; cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;\t&#125;\t//加入辅料\tvirtual void PutSomething() &#123; cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;\t&#125;&#125;;//业务函数void DoWork(AbstractDrinking* drink) &#123;\tdrink-&gt;MakeDrink();\tdelete drink;&#125;void test01() &#123;\tDoWork(new Coffee);\tcout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;\tDoWork(new Tea);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名()&#123;&#125; 纯虚析构语法： virtual ~类名() = 0; 类名::~类名()&#123;&#125; 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Animal &#123;public:\tAnimal()\t&#123; cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\t&#125;\tvirtual void Speak() = 0;\t//析构函数加上virtual关键字，变成虚析构函数\t//virtual ~Animal()\t//&#123;\t//\tcout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\t//&#125;\tvirtual ~Animal() = 0;&#125;;Animal::~Animal()&#123;\tcout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125;//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public:\tCat(string name)\t&#123; cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl; m_Name = new string(name);\t&#125;\tvirtual void Speak()\t&#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话!&quot; &lt;&lt; endl;\t&#125;\t~Cat()\t&#123; cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl; if (this-&gt;m_Name != NULL) &#123; delete m_Name; m_Name = NULL; &#125;\t&#125;public:\tstring *m_Name;&#125;;void test01()&#123;\tAnimal *animal = new Cat(&quot;Tom&quot;);\tanimal-&gt;Speak();\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\t//怎么解决？给基类增加一个虚析构函数\t//虚析构函数就是用来解决通过父类指针释放子类对象\tdelete animal;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： ​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 ​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 ​\t3. 拥有纯虚析构函数的类也属于抽象类 4.7.6 多态案例三-电脑组装案例描述： 电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;iostream&gt;using namespace std;//抽象CPU类class CPU&#123;public:\t//抽象的计算函数\tvirtual void calculate() = 0;&#125;;//抽象显卡类class VideoCard&#123;public:\t//抽象的显示函数\tvirtual void display() = 0;&#125;;//抽象内存条类class Memory&#123;public:\t//抽象的存储函数\tvirtual void storage() = 0;&#125;;//电脑类class Computer&#123;public:\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\t&#123; m_cpu = cpu; m_vc = vc; m_mem = mem;\t&#125;\t//提供工作的函数\tvoid work()\t&#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage();\t&#125;\t//提供析构函数 释放3个电脑零件\t~Computer()\t&#123; //释放CPU零件 if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; //释放显卡零件 if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; //释放内存条零件 if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125;\t&#125;private:\tCPU * m_cpu; //CPU的零件指针\tVideoCard * m_vc; //显卡零件指针\tMemory * m_mem; //内存条零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public:\tvirtual void calculate()\t&#123; cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;\t&#125;&#125;;class IntelVideoCard :public VideoCard&#123;public:\tvirtual void display()\t&#123; cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;\t&#125;&#125;;class IntelMemory :public Memory&#123;public:\tvirtual void storage()\t&#123; cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;\t&#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public:\tvirtual void calculate()\t&#123; cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;\t&#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public:\tvirtual void display()\t&#123; cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;\t&#125;&#125;;class LenovoMemory :public Memory&#123;public:\tvirtual void storage()\t&#123; cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//第一台电脑零件\tCPU * intelCpu = new IntelCPU;\tVideoCard * intelCard = new IntelVideoCard;\tMemory * intelMem = new IntelMemory;\tcout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\t//创建第一台电脑\tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\tcomputer1-&gt;work();\tdelete computer1;\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\t//第二台电脑组装\tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\tcomputer2-&gt;work();\tdelete computer2;\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\t//第三台电脑组装\tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\tcomputer3-&gt;work();\tdelete computer3;&#125; 5 文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D; 文件类型分为两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: ofstream：写操作 ifstream： 读操作 fstream ： 读写操作 5.1文本文件5.1.1写文件 写文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ofstream ofs; 打开文件 ofs.open(“文件路径”,打开方式); 写数据 ofs &lt;&lt; “写入的数据”; 关闭文件 ofs.close(); ​ 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意： 文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios:: out 示例： 12345678910111213141516171819202122#include &lt;fstream&gt;void test01()&#123;\tofstream ofs;\tofs.open(&quot;test.txt&quot;, ios::out);\tofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\tofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\tofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\tofs.close();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多 读文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ifstream ifs; 打开文件并判断文件是否打开成功 ifs.open(“文件路径”,打开方式); 读数据 四种方式读取 关闭文件 ifs.close(); 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123;\tifstream ifs;\tifs.open(&quot;test.txt&quot;, ios::in);\tif (!ifs.is_open())\t&#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return;\t&#125;\t//第一种方式\t//char buf[1024] = &#123; 0 &#125;;\t//while (ifs &gt;&gt; buf)\t//&#123;\t//\tcout &lt;&lt; buf &lt;&lt; endl;\t//&#125;\t//第二种\t//char buf[1024] = &#123; 0 &#125;;\t//while (ifs.getline(buf,sizeof(buf)))\t//&#123;\t//\tcout &lt;&lt; buf &lt;&lt; endl;\t//&#125;\t//第三种\t//string buf;\t//while (getline(ifs, buf))\t//&#123;\t//\tcout &lt;&lt; buf &lt;&lt; endl;\t//&#125;\tchar c;\twhile ((c = ifs.get()) != EOF)\t&#123; cout &lt;&lt; c;\t&#125;\tifs.close();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 5.2 二进制文件以二进制的方式对文件进行读写操作 打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D; 5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write 函数原型 ：ostream&amp; write(const char * buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:\tchar m_Name[64];\tint m_Age;&#125;;//二进制文件 写文件void test01()&#123;\t//1、包含头文件\t//2、创建输出流对象\tofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary); //3、打开文件\t//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\tPerson p = &#123;&quot;张三&quot; , 18&#125;;\t//4、写文件\tofs.write((const char *)&amp;p, sizeof(p));\t//5、关闭文件\tofs.close();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 文件输出流对象 可以通过write函数，以二进制方式写数据 5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char *buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:\tchar m_Name[64];\tint m_Age;&#125;;void test01()&#123;\tifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);\tif (!ifs.is_open())\t&#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\t&#125;\tPerson p;\tifs.read((char *)&amp;p, sizeof(p));\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 文件输入流对象 可以通过read函数，以二进制方式读数据","tags":["C++"],"categories":["语言"]},{"title":"Linux基础命令","path":"/2024/08/12/Linux基础命令/","content":"Linux基础命令 Linux目录结构 /根目录，是最顶级的目录 Linux有且仅有这一个顶级目录，没有Windows那些分盘分区 Linux中路径描述分区也用 / 来区分 &#x2F;home&#x2F;bob 表示根目录下的home的bob文件夹里的内容 ls命令功能：列出文件夹信息语法：ls [-l -h -a] [参数] 参数：被查看的文件夹，不提供参数，表示查看当前工作目录 -l，以列表形式查看 -h，需要配合-l，以更加人性化的方式显示文件大小 -a，显示隐藏的文件 隐藏文件、文件夹在Linux中以.开头的，均是隐藏的。默认不显示出来，需要-a选项才可查看到。 pwd命令功能：展示当前工作目录语法：pwd cd命令功能：切换工作目录语法：cd [目标目录] 参数：目标目录，要切换去的地方，不提供则默认切换到&#x3D;&#x3D;当前用户的HOME目录&#x3D;&#x3D; HOME目录每一个用户在Linux系统中的自己的专属工作目录，称之为HOME目录。 普通用户的HOME目录，默认在：/home/用户名 root用户登陆后，在/root FinalShell登录终端后，默认的工作目录就是用户的HOME目录 相对路径、绝对路径 相对路径，&#x3D;&#x3D;非&#x3D;&#x3D; /开头的称之为相对路径相对路径表示以当前目录作为起点去描述路径，如test/a.txt,表示当前工作目录内的test文件夹内的a.txt文件 绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D; /开头的称之为绝对路径绝对路径从根开始描述路径 特殊路径符 .表示当前,比如.&#x2F;a.txt，表示当前文件夹内的a.txt文件 ..表示上级目录，比如../表示上级目录，../../表示上级的上级目录 ~表示用户的HOME目录，比如cd ~,即可切回用户HOME目录","tags":["Java"],"categories":["系统"]},{"title":"Maven","path":"/2024/08/02/maven/","content":"1.Maven简介&#x3D;&#x3D;Maven是一个依赖管理工具&#x3D;&#x3D;Maven是一款为 Java 项目管理构建、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。Maven就是一个软件，掌握安装、配置、以及基本功能 （项目构建、依赖管理） 的理解和使用即可~ 2.Maven的引入①jar包：&emsp;&emsp;jar包就是 &#x3D;&#x3D;Java Archive File&#x3D;&#x3D;，是 Java 的一种文档格式，是一种与平台无关的文件格式，可将多个文件合成一个“文件”。jar 包与 zip 包非常相似——准确地说，它就是 zip 包，所以叫它文件包。&emsp;&emsp;jar 与 zip 唯一的区别就是在 jar 文件的内容中，包含了一个 META-INF&#x2F;MANIFEST.MF 文件，该文件是在生成 jar 文件的时候自动创建的，作为jar里面的”详情单”，包含了该Jar包的版本、创建人和类搜索路径Class-Path等信息。&emsp;&emsp;随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。如果一个简单的项目就需要上百个文件导入后才能运行这无疑让人感到头大。这时就需要一个工具来管理…… &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;懒惰使人类进步 &emsp;&emsp;如果使用 Maven 来引入这些 jar 包只需要配置几个『依赖』 ②jar包的来源问题 这个jar包所属技术的官网。官网通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载。 第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。 jar包的名称 jar包的版本 jar包内的具体细节 而使用 Maven 后，依赖对应的 jar 包能够自动下载，方便、快捷又规范。 ③jar包的导入问题在web工程中，jar包必须存放在指定位置： 在使用Maven之后，通过配置依赖(jar包)的坐标，查找本地仓库中相应jar包，若本地仓库没有，则统一从镜像网站或中央仓库中下载： ④jar包之间的依赖&emsp;&emsp;框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。&emsp;&emsp;而实际上 jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。&emsp;&emsp;而使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量。 3.基于IDEA 进行Maven依赖管理3.1 依赖管理概念Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。 我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven 仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。 总之，Maven 的依赖管理是 Maven 软件的一个核心功能之一，使得软件包依赖的管理和使用更加智能和方便，简化了开发过程中的工作，并提高了软件质量和可维护性。 3.2 Maven工程核心信息配置和解读（GAVP）位置：pom.xml 12345678910111213141516&lt;!-- 模型版本 --&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;&lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt;&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;&lt;artifactId&gt;project&lt;/artifactId&gt;&lt;!-- 版本号 --&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;!--打包方式 默认：jar jar指的是普通的java项目打包方式！ 项目打成jar包！ war指的是web项目打包方式！项目打成war包！ pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念--&gt;&lt;packaging&gt;jar/pom/war&lt;/packaging&gt; 3.3 Maven工程依赖管理配置位置：pom.xml 依赖管理和依赖添加 123456789101112131415161718&lt;!-- 通过编写依赖jar包的gav必要属性，引入第三方依赖！ scope属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --&gt;&lt;dependencies&gt; &lt;!-- 引入具体的依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;!-- 依赖范围 --&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖版本统一提取和维护 1234567891011121314151617&lt;!--声明版本--&gt;&lt;properties&gt; &lt;!--命名随便,内部制定版本号即可！--&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--引用properties声明版本 --&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.4 依赖范围通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境 依赖范围 描述 compile 编译依赖范围，scope 元素的缺省值。使用此依赖范围的 Maven 依赖，对于三种 classpath 均有效，即该 Maven 依赖在上述三种 classpath 均会被引入。例如，log4j 在编译、测试、运行过程都是必须的。 test 测试依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath 有效。例如，Junit 依赖只有在测试阶段才需要。 provided 已提供依赖范围。使用此依赖范围的 Maven 依赖，只对编译 classpath 和测试 classpath 有效。例如，servlet-api 依赖对于编译、测试阶段而言是需要的，但是运行阶段，由于外部容器已经提供，故不需要 Maven 重复引入该依赖。 runtime 运行时依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath、运行 classpath 有效。例如，JDBC 驱动实现依赖，其在编译时只需 JDK 提供的 JDBC 接口即可，只有测试、运行阶段才需要实现了 JDBC 接口的驱动。 system 系统依赖范围，其效果与 provided 的依赖范围一致。其用于添加非 Maven 仓库的本地依赖，通过依赖元素 dependency 中的 systemPath 元素指定本地依赖的路径。鉴于使用其会导致项目的可移植性降低，一般不推荐使用。 import 导入依赖范围，该依赖范围只能与 dependencyManagement 元素配合使用，其功能是将目标 pom.xml 文件中 dependencyManagement 的配置导入合并到当前 pom.xml 的 dependencyManagement 中。 本篇知识回顾参考尚硅谷的文章，仅作为复习or快速入门使用。","tags":["Java"],"categories":["Java"]},{"title":"md入门","path":"/2024/07/18/md入门/","content":"MarkDown学习笔记 0.前言话说md的优秀学习资源还真不好找，在小破站找了半天，还是在Github发现了宝藏https://github.com/Sakiyary/Markdown-Typora-VSCode-Doc 1.标题[数个“#”+空格前置]一级标题二级标题三级标题四级标题五级标题六级标题标题会在目录与大纲分级显示，可以跳转。 在 Typora 中建议开启严格模式，即不应为#标题，应为# 标题。 应该手动补上空格，使得Markdown语法在其他文本编辑器上兼容。 2. 强调 [用 “**” 或 “__” 包围]欢迎报考西安邮电大学! (我喜欢用这种)欢迎报考西安邮电大学!或者选中想要强调的文字按Ctrl+ B。 3. 斜体 [用 “*” 或 “_” 包围]欢迎大佬来浇浇我各种知识 (我喜欢用这种)欢迎大佬来浇浇我各种知识或者选中想要强调的文字按Ctrl+ I。 例如 欢迎大佬来浇我各种知识 (PS斜体并强调[用“***”或“___”包围]) 4. 删除线 [用 “~~” 包围]我宣布个事儿, 我是Sabiyary!例如 5. *高亮 [用“&#x3D;&#x3D;”包围](注意：此为扩展语法) &#x3D;&#x3D;我喜欢黄色, 也喜欢绿色&#x3D;&#x3D;例如 &#x3D;&#x3D;我喜欢黄色，也喜欢绿色&#x3D;&#x3D; 6. 代码 [用 “&#96;” 包围]sudo rm -rf /* 例如 sudo rm -rf &#x2F;*（没事别乱敲这个！） “请输入管理员密码: (点亮的指示灯)” 7. 代码块 [按三个“&#96;”并敲回车]1234567891011// 这里就可以开始输入你要的代码了#include &lt;stdio.h&gt;int mian() &#123; print（“Hello, world! &quot;）; retrun O;&#125; // (这三个&quot;`&quot;文本编辑器会帮你自动补全 一般不用手动输)（我之前都是用这个来展示各种语法的，应该不用说明清楚吧）显示行数的话，一般要在 Typora 的设置里勾上这个显示行数的选项。代码块里可以选择语言，其会根据语言自动高亮各个语句。 在选择语言后，```会变为````+ 对应语言。 8. 引用[“&gt;” + 空格前置] 24岁, 是学生. 学生特有的无处不在(恼)引用是可以的！ 9. 无序列表 [“-“ 或 “+” + 空格前置] 一颗是枣树 (我喜欢用这种) 另一颗还是枣树 (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)三个前置符都可以，敲回车会自动补全，可以在Typora设置中调整补全的符号，敲回车后按下Tab会缩进一级。 10. 社区列表【数字+“.” + 空格前置]我来这里就为了三件事: 公平 公平 还是tm的公平!敲回车会自动补全，敲回车后按下Tab会缩进一级。 11. *上标 [用 “^” 包围](注意：此为扩展语法) C语言中int的上限是 2^31^ - 1 &#x3D; 2147483647 12. *下标 [用 “~” 包围](注意：此为扩展语法) H2O 是剧毒的!例如 H2哦是剧毒的！ 13. *注释 [“[^]” 后置](注意：此为扩展语法) 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1] [^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.需要在文末写上注释的内容 14. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]（注意：文内动画作为扩展方式） 来看看原作者的仓库罢[基础教程: 12. 下标](#12. 下标 [用 “~” 包围])支持网页链接与文内跳转，按住Ctrl并单击鼠标左键即可跳转。 15.任务列表[“-[]”+空格前置]TodoList: 刷B站 写代码 起床使用x替换[ ]中的空格来勾选任务列表。 在 Typora&#x2F;VScode 中可以直接用鼠标左键单击复选框。 16. 表格 [用“|” 相似表格相似] 学号 姓名 年龄 114514 田所 24 1919810 浩三 25 (引号的位置代表着 左对齐, 居中, 右对齐) 第一行为表头，并由第二行分割线决定景观方式与长度，第三行及之后即表格数据 17. 图片 [直接拖板进来或者复制粘贴]我还是会选择拖板或者复制粘贴啦~在Typora的设置里也可以改变图片的存储方式。 18.分割线[按三个“*”或“-”或“_”并敲回车] — (我喜欢用这种) &#x2F;&#x2F; (其实按三个及以上都可以)由于*与_均会自动补全，所以我觉得-极其方便。 19. Emoji表情 [“:” 前面]（注意：英文输入为扩展语法） :sweat_smile::drooling_face::clown_face:&#x2F;&#x2F; (敲回车或者鼠标点击, 后置的”:”一般不需要手动输)这个功能的唯一要求就是英语水平要高，或者大概记住各个表情符号的英文名字。 对于其余普通的 Markdown 文本编辑器，可以直接将 Emoji 表情复制进来，这就是直接硬编码的 (刻进DNA里） 例如 😅🤤🤡 使用好这个功能可以让你的文本非常可爱！太抽象了 进阶1. 目录 [自动生成]&#x3D;&#x3D;[TOC]&#x3D;&#x3D;(此为 Typora 特有的, 如本文档开头)若使用 VS Code 且搭配 Markdown All in One 扩展，可在 VS Code 的命令面板（即VS Code Command Palette）输入Create Table of Contents自动生成目录，可在扩展中设置中细调目录参数。 2. 内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围] 我不会 HTML 呜呜呜... 浇浇我 简单的文字居中也可以这样 我差点忘了还有下划线这东西…只要你会写，你完全可以把 Markdown 当作HTML来写。 同时，.md文件可以直接导出成一个网页。 下划线可以选中想要下划的文字单击Ctrl+ U。 3. 内联公式 [用 “$” 包围]（注意：部分编译器会不识别部分符号） $\\LaTeX$ 是最好用的论文排版语言! 不信你看! $a^n+b^n&#x3D;c^n$ 使用$包围为单条公式，点击两个$并敲回车即生成公式块。 例如 是最好用的论文排版语言！ 不信你看！ 4. *网络图表（这是学长给我的网络图床教程，我实践过……） 分享一个Typora搭配腾讯云COS&#x2F;阿里云OSS图床的例子。 新免费用户投入了6个月的时间，另外选择了七牛云或者路过图床。 5. *Typora 的常用快捷键關鍵\t效果\t關鍵\t效果Ctrl+D\t选中当前词\tCtrl+L\t选中当前句&#x2F;行Ctrl+E\t选中当前项目\tCtrl+F\t搜索当前问题Ctrl+B\t加粗当前检查\tCtrl+H\t替换当前选项Ctrl+I\t总统当前任务\tCtrl+U\t下划当前检查Ctrl+K\t将当前选中生成链接\tCtrl+J\t屏幕滚动至顶部Ctrl+W\t关闭窗口\tCtrl+N\t打开新窗口Ctrl+O\t打开文件\tCtrl+P\t搜索结果并打开Ctrl+回车\t表格下方插入行\tCtrl+,\t展开方案Ctrl+.\t切换全角&#x2F;半角标点\tCtrl+&#x2F;\t切换正常&#x2F;来源视图Ctrl+ Shift+-\t幻灯片\tCtrl+ Shift++\t放大还有一些不常用的&#x2F;三键的主板不在此首发。 6. *Typora的主题风格与检查元素Markdown 在编译后相当于 HTML。 而Typora的正常视图就是编译Markdown后的，故Typora的主题样式本质上就是CSS文件。 可以下载各种好看的主题给Typora换上，同时也可以自己调整对应的CSS文件，或者自己手搓。 在Typora中打开调试模式后即可在正常视图右击打开检查元素，在其中就可以完全将Markdown文件当成HTML来编辑。 💯 总结至此，Markdown + Typora &#x2F; VSCode的手册教程也告一段落。 不知道你看完这么长的教程&#x2F;手册，是否能体会到 Markdown 的精妙简洁之处呢？ 其实 Markdown 只是标记语言的最开始，我的感受是会了 Markdown 之后对于理解 HTML 也有帮助，对于使用Latex来写论文也有帮助。 语言标记是为了修复Word那样虽然“所见即所得”，但又过度花哨浮华，很差的兼容性与闭源的编码的缺陷。 当你能够掌握这样的“所写即所得”时，你肯定会常用 Markdown 这类语言来处理文本的妙处！","tags":["MD"],"categories":["blog1"]},{"title":"Hello World","path":"/2024/07/18/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]