[{"title":"Go语言学习之路","path":"/2024/10/26/Gogogo！！！/","content":"0.Java转Go鼠鼠已经卷不动Java力！！最近听到各种学长消息和同学的焦虑，Java真是越来越力不从心了，其他方向的佬都能斩获各家大厂Offer，Java学长缺有些吃力，鼠鼠没办法力，学一学Go语言把~~ 1.Go的第一课鼠鼠按照惯例打开了小破站，搜索”Go语言”，寻找一圈，竟然发现大多数都是18-21年录的视频，鼠鼠心中两大幻神：“黑马”和“尚硅谷”一个是18年一个是19年，眉头一皱暗道不妙。太过久远的视频会失去时效性，语言也是在不断更新和进步的，鼠鼠也想直接学习最新的视频。万般无奈之下鼠鼠选择了播放量最高的一个视频开始了学习(https://www.bilibili.com/video/BV1gf4y1r79E/?spm_id_from=333.337.search-card.all.click)，老师讲的挺好的，只可惜用的是Linux系统，鼠鼠在删除掉Linux系统之后并不喜欢对照Linux系统的内容学习，在舍友的推荐下选择了另一个老师（==软件工艺师==）的视频(https://www.bilibili.com/video/BV1fD4y1m7TD/?spm_id_from=333.337.search-card.all.click)这让鼠鼠认为非常皓齿，喜欢捏嘻嘻嘻嘻嘻… 2.软件工艺师“光头埼玉”老师讲的非常好,鼠鼠认为比较适合有一定别的语言基础的同学学习，不用过度学习繁琐的最基础的语言逻辑(也可能是因为老师讲的比较快)，反正是非常适合鼠鼠的学习，(鼠鼠已经看完第二章力)，继续继续GOGOGO！！！","tags":["学习"],"categories":["Go"]},{"title":"后端开发小结","path":"/2024/09/14/后端/","content":"本文旨在记录在后端开发项目中遇到的一些问题，记录下来用以回顾 响应码401：HTTP状态码401表示“未授权”（Unauthorized）。当您在尝试访问某个网页或API接口时遇到401错误，这意味着您的请求缺少有效的认证信息，或者提供的认证信息（如用户名和密码）是无效的、过期的。 服务器因此拒绝了您对资源的访问请求。 需要检查一下JWT令牌，可能需要重新登录获得新的JWT令牌作为响应头","tags":["学习"],"categories":["Java"]},{"title":"招协工作总结","path":"/2024/08/25/招协工作总结/","content":"招协工作总结加入招协+&emsp;&emsp;2023年入学前，我作为大一新生加入了西安邮电大学的官方咨询群，后面了解到里面有很多回答问题的学长学姐来自西安邮电大学招生协会。&emsp;&emsp;我自以为对高考志愿报名有些熟悉，并招协是我在大学认识的第一个社团，向往之心难以抑制，很快就加入了招协的纳新群。经过学姐们的两次面试，也是成功加入了西邮招协综合事务部。 社团工作~&emsp;&emsp;招协作为学校一级社团，在校期间的社团工作并不算多，也没有网上说的整天开会写文章的那种琐事，就是主打一个轻松愉快，（学姐还请我们喝奶茶真不戳哈哈。&emsp;&emsp;到了寒假，寒假宣传活动也随之到来。我也拿着学校给的物料回到高中母校，热心地给学弟学妹们介绍西安邮电大学，&emsp;&emsp;2024年的暑假才是真正需要干活的时候。在报志愿期间要在招生办接听考生的电话，耐心地为考生和家长说明学校的政策和计划安排。 外派任务！&emsp;&emsp;记忆最深的就是那次外派任务，第一次有了学校给的身份出去外派（hahahah），是在西安太白中学，好像就是以前的西电附中把…硕大的太阳无法阻挡家长的咨询，也或许是对孩子的担心让家长无法停下，我也是经历过高考的学生，唯一能做的也就是为这些家长们提供更准确的消息，也好让他们少一些焦虑。&emsp;&emsp;Tips:学校的饭还挺丰盛挺好吃的 At the End&emsp;&emsp;招协的生活很简单，也很喜欢，很可惜没有成功留部，即使不在社团了也要为学校发光发热啊Bi8bo…… &emsp;&emsp;想写点东西总结一下，发现失去了好文笔","tags":["校园"],"categories":["校园"]},{"title":"C++核心编程","path":"/2024/08/20/C++核心编程/","content":"C++核心编程本阶段主要针对C++ &#x3D;&#x3D;面向对象&#x3D;&#x3D; 编程技术做详细讲解，探讨C++中的核心和精髓。 1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 1.1 程序运行前​\t在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 ​\t代码区： ​ 存放 CPU 执行的机器指令 ​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 ​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 ​\t全局区： ​ 全局变量和静态变量存放在此. ​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ​ &#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;. 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243//全局变量int g_a = 10;int g_b = 10;//全局常量const int c_g_a = 10;const int c_g_b = 10;int main() &#123;\t//局部变量\tint a = 10;\tint b = 10;\t//打印地址\tcout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\tcout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\tcout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl;\tcout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl;\t//静态变量\tstatic int s_a = 10;\tstatic int s_b = 10;\tcout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\tcout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\tcout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\tcout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\tconst int c_l_a = 10;\tconst int c_l_b = 10;\tcout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\tcout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 打印结果： 总结： C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后​\t栈区： ​ 由编译器自动分配释放, 存放函数的参数值,局部变量等 ​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 示例： 1234567891011121314151617int * func()&#123;\tint a = 10;\treturn &amp;a;&#125;int main() &#123;\tint *p = func();\tcout &lt;&lt; *p &lt;&lt; endl;\tcout &lt;&lt; *p &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; ​\t堆区： ​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 ​ 在C++中主要利用new在堆区开辟内存 示例： 1234567891011121314151617int* func()&#123;\tint* a = new int(10);\treturn a;&#125;int main() &#123;\tint *p = func();\tcout &lt;&lt; *p &lt;&lt; endl;//防止误操作，编译器会做一次保留\tcout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;);\treturn 0;&#125; 总结： 堆区数据由程序员管理开辟和释放 堆区数据利用new关键字进行开辟内存 1.3 new操作符​\tC++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据 ​\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D; ​\t语法： new 数据类型 ​\t利用new创建的数据，会返回该数据对应的类型的指针 示例1： 基本语法 12345678910111213141516171819202122int* func()&#123;\tint* a = new int(10);\treturn a;&#125;int main() &#123;\tint *p = func();\tcout &lt;&lt; *p &lt;&lt; endl;\tcout &lt;&lt; *p &lt;&lt; endl;\t//利用delete释放堆区数据\tdelete p;\t//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问\tsystem(&quot;pause&quot;);\treturn 0;&#125; 示例2：开辟数组 12345678910111213141516171819202122//堆区开辟数组int main() &#123;\tint* arr = new int[10];\tfor (int i = 0; i &lt; 10; i++)\t&#123; arr[i] = i + 100;\t&#125;\tfor (int i = 0; i &lt; 10; i++)\t&#123; cout &lt;&lt; arr[i] &lt;&lt; endl;\t&#125;\t//释放数组 delete 后加 []\tdelete[] arr;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 2 引用2.1 引用的基本使用**作用： **给变量起别名 语法： 数据类型 &amp;别名 = 原名 示例： 1234567891011121314151617int main() &#123;\tint a = 10;\tint &amp;b = a;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tb = 100;\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例： 12345678910111213141516int main() &#123;\tint a = 10;\tint b = 20;\t//int &amp;c; //错误，引用必须初始化\tint &amp;c = a; //一旦初始化后，就不可以更改\tc = b; //这是赋值操作，不是更改引用\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tcout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//1. 值传递void mySwap01(int a, int b) &#123;\tint temp = a;\ta = b;\tb = temp;&#125;//2. 地址传递void mySwap02(int* a, int* b) &#123;\tint temp = *a;\t*a = *b;\t*b = temp;&#125;//3. 引用传递void mySwap03(int&amp; a, int&amp; b) &#123;\tint temp = a;\ta = b;\tb = temp;&#125;int main() &#123;\tint a = 10;\tint b = 20;\tmySwap01(a, b);\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\tmySwap02(&amp;a, &amp;b);\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\tmySwap03(a, b);\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单 2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 示例： 123456789101112131415161718192021222324252627282930313233//返回局部变量引用int&amp; test01() &#123;\tint a = 10; //局部变量\treturn a;&#125;//返回静态变量引用int&amp; test02() &#123;\tstatic int a = 20;\treturn a;&#125;int main() &#123;\t//不能返回局部变量的引用\tint&amp; ref = test01();\tcout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\tcout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\t//如果函数做左值，那么必须返回引用\tint&amp; ref2 = test02();\tcout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\tcout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\ttest02() = 1000;\tcout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\tcout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; ​ 2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量. 讲解示例： 1234567891011121314151617//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref)&#123;\tref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123;\tint a = 10; //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\tint&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a);\treturn 0;&#125; 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作 在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参 示例： 1234567891011121314151617181920212223//引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) &#123;\t//v += 10;\tcout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123;\t//int&amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误\t//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;\tconst int&amp; ref = 10;\t//ref = 100; //加入const后不可以修改变量\tcout &lt;&lt; ref &lt;&lt; endl;\t//函数中利用常量引用防止误操作修改实参\tint a = 10;\tshowValue(a);\tsystem(&quot;pause&quot;);\treturn 0;&#125; 3 函数提高3.1 函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。 语法： 返回值类型 函数名 （参数= 默认值）&#123;&#125; 示例： 1234567891011121314151617181920int func(int a, int b = 10, int c = 10) &#123;\treturn a + b + c;&#125;//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a = 10, int b = 10);int func2(int a, int b) &#123;\treturn a + b;&#125;int main() &#123;\tcout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\tcout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 3.2 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 语法： 返回值类型 函数名 (数据类型)&#123;&#125; 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 示例： 12345678910111213//函数占位参数 ，占位参数也可以有默认参数void func(int a, int) &#123;\tcout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;&#125;int main() &#123;\tfunc(10,10); //占位参数必须填补\tsystem(&quot;pause&quot;);\treturn 0;&#125; 3.3 函数重载3.3.1 函数重载概述作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同 注意: 函数的返回值不可以作为函数重载的条件 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041//函数重载需要函数都在同一个作用域下void func()&#123;\tcout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;&#125;void func(int a)&#123;\tcout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a)&#123;\tcout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;&#125;void func(int a ,double b)&#123;\tcout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a ,int b)&#123;\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;&#125;//函数返回值不可以作为函数重载条件//int func(double a, int b)//&#123;//\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;//&#125;int main() &#123;\tfunc();\tfunc(10);\tfunc(3.14);\tfunc(10,3.14);\tfunc(3.14 , 10); system(&quot;pause&quot;);\treturn 0;&#125; 3.3.2 函数重载注意事项 引用作为重载条件 函数重载碰到函数默认参数 示例： 123456789101112131415161718192021222324252627282930313233343536373839//函数重载注意事项//1、引用作为重载条件void func(int &amp;a)&#123;\tcout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;void func(const int &amp;a)&#123;\tcout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;//2、函数重载碰到函数默认参数void func2(int a, int b = 10)&#123;\tcout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl;&#125;void func2(int a)&#123;\tcout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;&#125;int main() &#123; int a = 10;\tfunc(a); //调用无const\tfunc(10);//调用有const\t//func2(10); //碰到默认参数产生歧义，需要避免\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4 类和对象C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D; C++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为 例如： ​\t人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌… ​\t车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调… ​\t具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类 4.1 封装4.1.1 封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： ​\t在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名&#123; 访问权限： 属性 / 行为 &#125;; 示例1：设计一个圆类，求圆的周长 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839//圆周率const double PI = 3.14;//1、封装的意义//将属性和行为作为一个整体，用来表现生活中的事物//封装一个圆类，求圆的周长//class代表设计一个类，后面跟着的是类名class Circle&#123;public: //访问权限 公共的权限\t//属性\tint m_r;//半径\t//行为\t//获取到圆的周长\tdouble calculateZC()\t&#123; //2 * pi * r //获取圆的周长 return 2 * PI * m_r;\t&#125;&#125;;int main() &#123;\t//通过圆类，创建圆的对象\t// c1就是一个具体的圆\tCircle c1;\tc1.m_r = 10; //给圆对象的半径 进行赋值操作\t//2 * pi * 10 = = 62.8\tcout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号 示例2代码： 123456789101112131415161718192021222324252627282930//学生类class Student &#123;public:\tvoid setName(string name) &#123; m_name = name;\t&#125;\tvoid setID(int id) &#123; m_id = id;\t&#125;\tvoid showStudent() &#123; cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\t&#125;public:\tstring m_name;\tint m_id;&#125;;int main() &#123;\tStudent stu;\tstu.setName(&quot;德玛西亚&quot;);\tstu.setID(250);\tstu.showStudent();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 封装意义二： 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 示例： 123456789101112131415161718192021222324252627282930313233343536373839//三种权限//公共权限 public 类内可以访问 类外可以访问//保护权限 protected 类内可以访问 类外不可以访问//私有权限 private 类内可以访问 类外不可以访问class Person&#123;\t//姓名 公共权限public:\tstring m_Name;\t//汽车 保护权限protected:\tstring m_Car;\t//银行卡密码 私有权限private:\tint m_Password;public:\tvoid func()\t&#123; m_Name = &quot;张三&quot;; m_Car = &quot;拖拉机&quot;; m_Password = 123456;\t&#125;&#125;;int main() &#123;\tPerson p;\tp.m_Name = &quot;李四&quot;;\t//p.m_Car = &quot;奔驰&quot;; //保护权限类外访问不到\t//p.m_Password = 123; //私有权限类外访问不到\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.1.2 struct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同 区别： struct 默认权限为公共 class 默认权限为私有 12345678910111213141516171819202122class C1&#123;\tint m_A; //默认是私有权限&#125;;struct C2&#123;\tint m_A; //默认是公共权限&#125;;int main() &#123;\tC1 c1;\tc1.m_A = 10; //错误，访问权限是私有\tC2 c2;\tc2.m_A = 10; //正确，访问权限是公共\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.1.3 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限 优点2：对于写权限，我们可以检测数据的有效性 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Person &#123;public:\t//姓名设置可读可写\tvoid setName(string name) &#123; m_Name = name;\t&#125;\tstring getName()\t&#123; return m_Name;\t&#125;\t//获取年龄 int getAge() &#123; return m_Age;\t&#125;\t//设置年龄\tvoid setAge(int age) &#123; if (age &lt; 0 || age &gt; 150) &#123; cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl; return; &#125; m_Age = age;\t&#125;\t//情人设置为只写\tvoid setLover(string lover) &#123; m_Lover = lover;\t&#125;private:\tstring m_Name; //可读可写 姓名 int m_Age; //只读 年龄\tstring m_Lover; //只写 情人&#125;;int main() &#123;\tPerson p;\t//姓名设置\tp.setName(&quot;张三&quot;);\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\t//年龄设置\tp.setAge(50);\tcout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\t//情人设置\tp.setLover(&quot;苍井&quot;);\t//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl; //只写属性，不可以读取\tsystem(&quot;pause&quot;);\treturn 0;&#125; 练习案例1：设计立方体类 设计立方体类(Cube) 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等。 练习案例2：点和圆的关系 设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。 4.2 对象的初始化和清理 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。 4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 ​\t一个对象或者变量没有初始状态，对其使用后果是未知 ​\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供 编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名()&#123;&#125; 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名()&#123;&#125; 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 1234567891011121314151617181920212223242526272829class Person&#123;public:\t//构造函数\tPerson()\t&#123; cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;\t&#125;\t//析构函数\t~Person()\t&#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\tPerson p;&#125;int main() &#123; test01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.2 构造函数的分类及调用两种分类方式： ​\t按参数分为： 有参构造和无参构造 ​\t按类型分为： 普通构造和拷贝构造 三种调用方式： ​\t括号法 ​\t显示法 ​\t隐式转换法 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//1、构造函数分类// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person &#123;public:\t//无参（默认）构造函数\tPerson() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//有参构造函数\tPerson(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//拷贝构造函数\tPerson(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\t&#125;\t//析构函数\t~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t&#125;public:\tint age;&#125;;//2、构造函数的调用//调用无参构造函数void test01() &#123;\tPerson p; //调用无参构造函数&#125;//调用有参的构造函数void test02() &#123;\t//2.1 括号法，常用\tPerson p1(10);\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\t//Person p2();\t//2.2 显式法\tPerson p2 = Person(10); Person p3 = Person(p2);\t//Person(10)单独写就是匿名对象 当前行结束之后，马上析构\t//2.3 隐式转换法\tPerson p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\t//Person p5(p4);&#125;int main() &#123;\ttest01();\t//test02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Person &#123;public:\tPerson() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; mAge = 0;\t&#125;\tPerson(int age) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; mAge = age;\t&#125;\tPerson(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; mAge = p.mAge;\t&#125;\t//析构函数在释放内存之前调用\t~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t&#125;public:\tint mAge;&#125;;//1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() &#123;\tPerson man(100); //p对象已经创建完毕\tPerson newman(man); //调用拷贝构造函数\tPerson newman2 = man; //拷贝构造\t//Person newman3;\t//newman3 = man; //不是调用拷贝构造函数，赋值操作&#125;//2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) &#123;&#125;void test02() &#123;\tPerson p; //无参构造函数\tdoWork(p);&#125;//3. 以值方式返回局部对象Person doWork2()&#123;\tPerson p1;\tcout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;\treturn p1;&#125;void test03()&#123;\tPerson p = doWork2();\tcout &lt;&lt; (int *)&amp;p &lt;&lt; endl;&#125;int main() &#123;\t//test01();\t//test02();\ttest03();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person &#123;public:\t//无参（默认）构造函数\tPerson() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//有参构造函数\tPerson(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//拷贝构造函数\tPerson(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\t&#125;\t//析构函数\t~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t&#125;public:\tint age;&#125;;void test01()&#123;\tPerson p1(18);\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\tPerson p2(p1);\tcout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;void test02()&#123;\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\tPerson p1; //此时如果用户自己没有提供默认构造，会出错\tPerson p2(10); //用户提供的有参\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供\t//如果用户提供拷贝构造，编译器不会提供其他构造函数\tPerson p4; //此时如果用户自己没有提供默认构造，会出错\tPerson p5(10); //此时如果用户自己没有提供有参，会出错\tPerson p6(p5); //用户自己提供拷贝构造&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Person &#123;public:\t//无参（默认）构造函数\tPerson() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//有参构造函数\tPerson(int age ,int height) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; m_age = age; m_height = new int(height); &#125;\t//拷贝构造函数 Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height); &#125;\t//析构函数\t~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; if (m_height != NULL) &#123; delete m_height; &#125;\t&#125;public:\tint m_age;\tint* m_height;&#125;;void test01()&#123;\tPerson p1(18, 180);\tPerson p2(p1);\tcout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\tcout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 4.2.6 初始化列表作用： C++提供了初始化列表语法，用来初始化属性 语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125; 示例： 123456789101112131415161718192021222324252627282930313233class Person &#123;public:\t////传统方式初始化\t//Person(int a, int b, int c) &#123;\t//\tm_A = a;\t//\tm_B = b;\t//\tm_C = c;\t//&#125;\t//初始化列表方式初始化\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;\tvoid PrintPerson() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\t&#125;private:\tint m_A;\tint m_B;\tint m_C;&#125;;int main() &#123;\tPerson p(1, 2, 3);\tp.PrintPerson();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： 12345class A &#123;&#125;class B&#123; A a；&#125; B类中有对象A作为成员，A为对象成员 那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？ 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Phone&#123;public:\tPhone(string name)\t&#123; m_PhoneName = name; cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;\t&#125;\t~Phone()\t&#123; cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\t&#125;\tstring m_PhoneName;&#125;;class Person&#123;public:\t//初始化列表可以告诉编译器调用哪一个构造函数\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\t&#123; cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\t&#125;\t~Person()\t&#123; cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\t&#125;\tvoid playGame()\t&#123; cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\t&#125;\tstring m_Name;\tPhone m_Phone;&#125;;void test01()&#123;\t//当类中成员是其他类对象时，我们称该成员为 对象成员\t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造\t//析构顺序与构造相反\tPerson p(&quot;张三&quot; , &quot;苹果X&quot;);\tp.playGame();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 示例1 ：静态成员变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person&#123;\tpublic:\tstatic int m_A; //静态成员变量\t//静态成员变量特点：\t//1 在编译阶段分配内存\t//2 类内声明，类外初始化\t//3 所有对象共享同一份数据private:\tstatic int m_B; //静态成员变量也是有访问权限的&#125;;int Person::m_A = 10;int Person::m_B = 10;void test01()&#123;\t//静态成员变量两种访问方式\t//1、通过对象\tPerson p1;\tp1.m_A = 100;\tcout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\tPerson p2;\tp2.m_A = 200;\tcout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据\tcout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\t//2、通过类名\tcout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\t//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 示例2：静态成员函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person&#123;public:\t//静态成员函数特点：\t//1 程序共享一个函数\t//2 静态成员函数只能访问静态成员变量 static void func()\t&#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量\t&#125;\tstatic int m_A; //静态成员变量\tint m_B; // private:\t//静态成员函数也是有访问权限的\tstatic void func2()\t&#123; cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\t&#125;&#125;;int Person::m_A = 10;void test01()&#123;\t//静态成员变量两种访问方式\t//1、通过对象\tPerson p1;\tp1.func();\t//2、通过类名\tPerson::func();\t//Person::func2(); //私有权限访问不到&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 1234567891011121314151617181920212223242526class Person &#123;public:\tPerson() &#123; mA = 0;\t&#125;\t//非静态成员变量占对象空间\tint mA;\t//静态成员变量不占对象空间\tstatic int mB; //函数也不占对象空间，所有函数共享一个函数实例\tvoid func() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;\t&#125;\t//静态成员函数也不占对象空间\tstatic void sfunc() &#123;\t&#125;&#125;;int main() &#123;\tcout &lt;&lt; sizeof(Person) &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this 1234567891011121314151617181920212223242526272829303132333435363738class Person&#123;public:\tPerson(int age)\t&#123; //1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age = age;\t&#125;\tPerson&amp; PersonAddPerson(Person p)\t&#123; this-&gt;age += p.age; //返回对象本身 return *this;\t&#125;\tint age;&#125;;void test01()&#123;\tPerson p1(10);\tcout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl;\tPerson p2(10);\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\tcout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.3.3 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 示例： 12345678910111213141516171819202122232425262728293031323334//空指针访问成员函数class Person &#123;public:\tvoid ShowClassName() &#123; cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\t&#125;\tvoid ShowPerson() &#123; if (this == NULL) &#123; return; &#125; cout &lt;&lt; mAge &lt;&lt; endl;\t&#125;public:\tint mAge;&#125;;void test01()&#123;\tPerson * p = NULL;\tp-&gt;ShowClassName(); //空指针，可以调用成员函数\tp-&gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.3.4 const修饰成员函数常函数： 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Person &#123;public:\tPerson() &#123; m_A = 0; m_B = 0;\t&#125;\t//this指针的本质是一个指针常量，指针的指向不可修改\t//如果想让指针指向的值也不可以修改，需要声明常函数\tvoid ShowPerson() const &#123; //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B = 100;\t&#125;\tvoid MyFunc() const &#123; //mA = 10000;\t&#125;public:\tint m_A;\tmutable int m_B; //可修改 可变的&#125;;//const修饰对象 常对象void test01() &#123;\tconst Person person; //常量对象 cout &lt;&lt; person.m_A &lt;&lt; endl;\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\t//常对象访问成员函数\tperson.MyFunc(); //常对象不能调用const的函数&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 &#x3D;&#x3D;friend&#x3D;&#x3D; 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142class Building&#123;\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\tfriend void goodGay(Building * building);public:\tBuilding()\t&#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;;\t&#125;public:\tstring m_SittingRoom; //客厅private:\tstring m_BedRoom; //卧室&#125;;void goodGay(Building * building)&#123;\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;\tBuilding b;\tgoodGay(&amp;b);&#125;int main()&#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.4.2 类做友元12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Building;class goodGay&#123;public:\tgoodGay();\tvoid visit();private:\tBuilding *building;&#125;;class Building&#123;\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\tfriend class goodGay;public:\tBuilding();public:\tstring m_SittingRoom; //客厅private:\tstring m_BedRoom;//卧室&#125;;Building::Building()&#123;\tthis-&gt;m_SittingRoom = &quot;客厅&quot;;\tthis-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;\tbuilding = new Building;&#125;void goodGay::visit()&#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;\tgoodGay gg;\tgg.visit();&#125;int main()&#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.4.3 成员函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Building;class goodGay&#123;public:\tgoodGay();\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\tvoid visit2(); private:\tBuilding *building;&#125;;class Building&#123;\t//告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\tfriend void goodGay::visit();public:\tBuilding();public:\tstring m_SittingRoom; //客厅private:\tstring m_BedRoom;//卧室&#125;;Building::Building()&#123;\tthis-&gt;m_SittingRoom = &quot;客厅&quot;;\tthis-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;\tbuilding = new Building;&#125;void goodGay::visit()&#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void goodGay::visit2()&#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\t//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;\tgoodGay gg;\tgg.visit();&#125;int main()&#123; test01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Person &#123;public:\tPerson() &#123;&#125;;\tPerson(int a, int b)\t&#123; this-&gt;m_A = a; this-&gt;m_B = b;\t&#125;\t//成员函数实现 + 号运算符重载\tPerson operator+(const Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp;\t&#125;public:\tint m_A;\tint m_B;&#125;;//全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;//\tPerson temp(0, 0);//\ttemp.m_A = p1.m_A + p2.m_A;//\ttemp.m_B = p1.m_B + p2.m_B;//\treturn temp;//&#125;//运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val) &#123;\tPerson temp;\ttemp.m_A = p2.m_A + val;\ttemp.m_B = p2.m_B + val;\treturn temp;&#125;void test() &#123;\tPerson p1(10, 10);\tPerson p2(20, 20);\t//成员函数方式\tPerson p3 = p2 + p1; //相当于 p2.operaor+(p1)\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\tPerson p4 = p3 + 10; //相当于 operator+(p3,10)\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;int main() &#123;\ttest();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的 总结2：不要滥用运算符重载 4.5.2 左移运算符重载作用：可以输出自定义数据类型 123456789101112131415161718192021222324252627282930313233343536373839404142class Person &#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public:\tPerson(int a, int b)\t&#123; this-&gt;m_A = a; this-&gt;m_B = b;\t&#125;\t//成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果\t//void operator&lt;&lt;(Person&amp; p)&#123;\t//&#125;private:\tint m_A;\tint m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;\tout &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;\treturn out;&#125;void test() &#123;\tPerson p1(10, 20);\tcout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程&#125;int main() &#123;\ttest();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：重载左移运算符配合友元可以实现输出自定义数据类型 4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyInteger &#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);public:\tMyInteger() &#123; m_Num = 0;\t&#125;\t//前置++\tMyInteger&amp; operator++() &#123; //先++ m_Num++; //再返回 return *this;\t&#125;\t//后置++\tMyInteger operator++(int) &#123; //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp;\t&#125;private:\tint m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;\tout &lt;&lt; myint.m_Num;\treturn out;&#125;//前置++ 先++ 再返回void test01() &#123;\tMyInteger myInt;\tcout &lt;&lt; ++myInt &lt;&lt; endl;\tcout &lt;&lt; myInt &lt;&lt; endl;&#125;//后置++ 先返回 再++void test02() &#123;\tMyInteger myInt;\tcout &lt;&lt; myInt++ &lt;&lt; endl;\tcout &lt;&lt; myInt &lt;&lt; endl;&#125;int main() &#123;\ttest01();\t//test02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 前置递增返回引用，后置递增返回值 4.5.4 赋值运算符重载c++编译器至少给一个类添加4个函数 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator&#x3D;, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person&#123;public:\tPerson(int age)\t&#123; //将年龄数据开辟到堆区 m_Age = new int(age);\t&#125;\t//重载赋值运算符 Person&amp; operator=(Person &amp;p)\t&#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this;\t&#125;\t~Person()\t&#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125;\t&#125;\t//年龄的指针\tint *m_Age;&#125;;void test01()&#123;\tPerson p1(18);\tPerson p2(20);\tPerson p3(30);\tp3 = p2 = p1; //赋值操作\tcout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\t//int a = 10;\t//int b = 20;\t//int c = 30;\t//c = b = a;\t//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\t//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\t//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Person&#123;public:\tPerson(string name, int age)\t&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;\t&#125;;\tbool operator==(Person &amp; p)\t&#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125;\t&#125;\tbool operator!=(Person &amp; p)\t&#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; else &#123; return true; &#125;\t&#125;\tstring m_Name;\tint m_Age;&#125;;void test01()&#123;\t//int a = 0;\t//int b = 0;\tPerson a(&quot;孙悟空&quot;, 18);\tPerson b(&quot;孙悟空&quot;, 18);\tif (a == b)\t&#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\t&#125;\telse\t&#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\t&#125;\tif (a != b)\t&#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\t&#125;\telse\t&#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.5.6 函数调用运算符重载 函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyPrint&#123;public:\tvoid operator()(string text)\t&#123; cout &lt;&lt; text &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//重载的（）操作符 也称为仿函数\tMyPrint myFunc;\tmyFunc(&quot;hello world&quot;);&#125;class MyAdd&#123;public:\tint operator()(int v1, int v2)\t&#123; return v1 + v2;\t&#125;&#125;;void test02()&#123;\tMyAdd add;\tint ret = add(10, 10);\tcout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;\t//匿名对象调用 cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.6 继承继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，例如下图中： 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Java页面class Java &#123;public:\tvoid header()\t&#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;\tvoid content()\t&#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//Python页面class Python&#123;public:\tvoid header()\t&#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;\tvoid content()\t&#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//C++页面class CPP &#123;public:\tvoid header()\t&#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;\tvoid content()\t&#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//Java页面\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\tJava ja;\tja.header();\tja.footer();\tja.left();\tja.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//Python页面\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\tPython py;\tpy.header();\tpy.footer();\tpy.left();\tpy.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//C++页面\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\tCPP cp;\tcp.header();\tcp.footer();\tcp.left();\tcp.content();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 继承实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//公共页面class BasePage&#123;public:\tvoid header()\t&#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;&#125;;//Java页面class Java : public BasePage&#123;public:\tvoid content()\t&#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//Python页面class Python : public BasePage&#123;public:\tvoid content()\t&#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//C++页面class CPP : public BasePage&#123;public:\tvoid content()\t&#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//Java页面\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\tJava ja;\tja.header();\tja.footer();\tja.left();\tja.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//Python页面\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\tPython py;\tpy.header();\tpy.footer();\tpy.left();\tpy.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//C++页面\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\tCPP cp;\tcp.header();\tcp.footer();\tcp.left();\tcp.content();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D; class A : public B; A 类称为子类 或 派生类 B 类称为父类 或 基类 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 4.6.2 继承方式继承的语法：class 子类 : 继承方式 父类 继承方式一共有三种： 公共继承 保护继承 私有继承 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Base1&#123;public: int m_A;protected:\tint m_B;private:\tint m_C;&#125;;//公共继承class Son1 :public Base1&#123;public:\tvoid func()\t&#123; m_A; //可访问 public权限 m_B; //可访问 protected权限 //m_C; //不可访问\t&#125;&#125;;void myClass()&#123;\tSon1 s1;\ts1.m_A; //其他类只能访问到公共权限&#125;//保护继承class Base2&#123;public:\tint m_A;protected:\tint m_B;private:\tint m_C;&#125;;class Son2:protected Base2&#123;public:\tvoid func()\t&#123; m_A; //可访问 protected权限 m_B; //可访问 protected权限 //m_C; //不可访问\t&#125;&#125;;void myClass2()&#123;\tSon2 s;\t//s.m_A; //不可访问&#125;//私有继承class Base3&#123;public:\tint m_A;protected:\tint m_B;private:\tint m_C;&#125;;class Son3:private Base3&#123;public:\tvoid func()\t&#123; m_A; //可访问 private权限 m_B; //可访问 private权限 //m_C; //不可访问\t&#125;&#125;;class GrandSon3 :public Son3&#123;public:\tvoid func()\t&#123; //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 //m_A; //m_B; //m_C;\t&#125;&#125;; 4.6.3 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？ 示例： 123456789101112131415161718192021222324252627282930class Base&#123;public:\tint m_A;protected:\tint m_B;private:\tint m_C; //私有成员只是被隐藏了，但是还是会继承下去&#125;;//公共继承class Son :public Base&#123;public:\tint m_D;&#125;;void test01()&#123;\tcout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 利用工具查看： 打开工具窗口后，定位到当前CPP文件的盘符 然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名 所属文件名 效果如下图： 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到 4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 问题：父类和子类的构造和析构顺序是谁先谁后？ 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142class Base &#123;public:\tBase()\t&#123; cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;\t&#125;\t~Base()\t&#123; cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;\t&#125;&#125;;class Son : public Base&#123;public:\tSon()\t&#123; cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;\t&#125;\t~Son()\t&#123; cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\tSon s;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Base &#123;public:\tBase()\t&#123; m_A = 100;\t&#125;\tvoid func()\t&#123; cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\t&#125;\tvoid func(int a)\t&#123; cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\t&#125;public:\tint m_A;&#125;;class Son : public Base &#123;public:\tSon()\t&#123; m_A = 200;\t&#125;\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\tvoid func()\t&#123; cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\t&#125;public:\tint m_A;&#125;;void test01()&#123;\tSon s;\tcout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\tcout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\ts.func();\ts.Base::func();\ts.Base::func(10);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn EXIT_SUCCESS;&#125; 总结： 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？ 静态成员和非静态成员出现同名，处理方式一致 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Base &#123;public:\tstatic void func()\t&#123; cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;\t&#125;\tstatic void func(int a)\t&#123; cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;\t&#125;\tstatic int m_A;&#125;;int Base::m_A = 100;class Son : public Base &#123;public:\tstatic void func()\t&#123; cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;\t&#125;\tstatic int m_A;&#125;;int Son::m_A = 200;//同名成员属性void test01()&#123;\t//通过对象访问\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\tSon s;\tcout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\tcout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\t//通过类名访问\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\tcout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;&#125;//同名成员函数void test02()&#123;\t//通过对象访问\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\tSon s;\ts.func();\ts.Base::func();\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\tSon::func();\tSon::Base::func();\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\tSon::Base::func(100);&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名） 4.6.7 多继承语法C++允许一个类继承多个类 语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议用多继承 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Base1 &#123;public:\tBase1()\t&#123; m_A = 100;\t&#125;public:\tint m_A;&#125;;class Base2 &#123;public:\tBase2()\t&#123; m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确\t&#125;public:\tint m_A;&#125;;//语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123;public:\tSon()\t&#123; m_C = 300; m_D = 400;\t&#125;public:\tint m_C;\tint m_D;&#125;;//多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01()&#123;\tSon s;\tcout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;\tcout &lt;&lt; s.Base1::m_A &lt;&lt; endl;\tcout &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域 4.6.8 菱形继承菱形继承概念： ​\t两个派生类继承同一个基类 ​\t又有某个类同时继承者两个派生类 ​\t这种继承被称为菱形继承，或者钻石继承 典型的菱形继承案例： 菱形继承问题： 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 示例： 1234567891011121314151617181920212223242526272829303132class Animal&#123;public:\tint m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123;\tSheepTuo st;\tst.Sheep::m_Age = 100;\tst.Tuo::m_Age = 200;\tcout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态4.7.1 多态的基本概念多态是C++面向对象三大特性之一 多态分为两类 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 下面通过案例进行讲解多态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Animal&#123;public:\t//Speak函数就是虚函数\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\tvirtual void speak()\t&#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;\t&#125;&#125;;class Cat :public Animal&#123;public:\tvoid speak()\t&#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;\t&#125;&#125;;class Dog :public Animal&#123;public:\tvoid speak()\t&#123; cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\t&#125;&#125;;//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal &amp; animal)&#123;\tanimal.speak();&#125;////多态满足条件： //1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象void test01()&#123;\tCat cat;\tDoSpeak(cat);\tDog dog;\tDoSpeak(dog);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 多态满足条件 有继承关系 子类重写父类中的虚函数 多态使用条件 父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 4.7.2 多态案例一-计算器类案例描述： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//普通实现class Calculator &#123;public:\tint getResult(string oper)\t&#123; if (oper == &quot;+&quot;) &#123; return m_Num1 + m_Num2; &#125; else if (oper == &quot;-&quot;) &#123; return m_Num1 - m_Num2; &#125; else if (oper == &quot;*&quot;) &#123; return m_Num1 * m_Num2; &#125; //如果要提供新的运算，需要修改源码\t&#125;public:\tint m_Num1;\tint m_Num2;&#125;;void test01()&#123;\t//普通实现测试\tCalculator c;\tc.m_Num1 = 10;\tc.m_Num2 = 10;\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;//多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator&#123;public :\tvirtual int getResult()\t&#123; return 0;\t&#125;\tint m_Num1;\tint m_Num2;&#125;;//加法计算器class AddCalculator :public AbstractCalculator&#123;public:\tint getResult()\t&#123; return m_Num1 + m_Num2;\t&#125;&#125;;//减法计算器class SubCalculator :public AbstractCalculator&#123;public:\tint getResult()\t&#123; return m_Num1 - m_Num2;\t&#125;&#125;;//乘法计算器class MulCalculator :public AbstractCalculator&#123;public:\tint getResult()\t&#123; return m_Num1 * m_Num2;\t&#125;&#125;;void test02()&#123;\t//创建加法计算器\tAbstractCalculator *abc = new AddCalculator;\tabc-&gt;m_Num1 = 10;\tabc-&gt;m_Num2 = 10;\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\tdelete abc; //用完了记得销毁\t//创建减法计算器\tabc = new SubCalculator;\tabc-&gt;m_Num1 = 10;\tabc-&gt;m_Num2 = 10;\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\tdelete abc; //创建乘法计算器\tabc = new MulCalculator;\tabc-&gt;m_Num1 = 10;\tabc-&gt;m_Num2 = 10;\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\tdelete abc;&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多 4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D; 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例： 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public:\t//纯虚函数\t//类中只要有一个纯虚函数就称为抽象类\t//抽象类无法实例化对象\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\tvirtual void func() = 0;&#125;;class Son :public Base&#123;public:\tvirtual void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\t&#125;;&#125;;void test01()&#123;\tBase * base = NULL;\t//base = new Base; // 错误，抽象类无法实例化对象\tbase = new Son;\tbase-&gt;func();\tdelete base;//记得销毁&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.7.4 多态案例二-制作饮品案例描述： 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//抽象制作饮品class AbstractDrinking &#123;public:\t//烧水\tvirtual void Boil() = 0;\t//冲泡\tvirtual void Brew() = 0;\t//倒入杯中\tvirtual void PourInCup() = 0;\t//加入辅料\tvirtual void PutSomething() = 0;\t//规定流程\tvoid MakeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething();\t&#125;&#125;;//制作咖啡class Coffee : public AbstractDrinking &#123;public:\t//烧水\tvirtual void Boil() &#123; cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;\t&#125;\t//冲泡\tvirtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;\t&#125;\t//倒入杯中\tvirtual void PourInCup() &#123; cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;\t&#125;\t//加入辅料\tvirtual void PutSomething() &#123; cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;\t&#125;&#125;;//制作茶水class Tea : public AbstractDrinking &#123;public:\t//烧水\tvirtual void Boil() &#123; cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;\t&#125;\t//冲泡\tvirtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;\t&#125;\t//倒入杯中\tvirtual void PourInCup() &#123; cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;\t&#125;\t//加入辅料\tvirtual void PutSomething() &#123; cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;\t&#125;&#125;;//业务函数void DoWork(AbstractDrinking* drink) &#123;\tdrink-&gt;MakeDrink();\tdelete drink;&#125;void test01() &#123;\tDoWork(new Coffee);\tcout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;\tDoWork(new Tea);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名()&#123;&#125; 纯虚析构语法： virtual ~类名() = 0; 类名::~类名()&#123;&#125; 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Animal &#123;public:\tAnimal()\t&#123; cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\t&#125;\tvirtual void Speak() = 0;\t//析构函数加上virtual关键字，变成虚析构函数\t//virtual ~Animal()\t//&#123;\t//\tcout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\t//&#125;\tvirtual ~Animal() = 0;&#125;;Animal::~Animal()&#123;\tcout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125;//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public:\tCat(string name)\t&#123; cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl; m_Name = new string(name);\t&#125;\tvirtual void Speak()\t&#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话!&quot; &lt;&lt; endl;\t&#125;\t~Cat()\t&#123; cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl; if (this-&gt;m_Name != NULL) &#123; delete m_Name; m_Name = NULL; &#125;\t&#125;public:\tstring *m_Name;&#125;;void test01()&#123;\tAnimal *animal = new Cat(&quot;Tom&quot;);\tanimal-&gt;Speak();\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\t//怎么解决？给基类增加一个虚析构函数\t//虚析构函数就是用来解决通过父类指针释放子类对象\tdelete animal;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： ​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 ​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 ​\t3. 拥有纯虚析构函数的类也属于抽象类 4.7.6 多态案例三-电脑组装案例描述： 电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;iostream&gt;using namespace std;//抽象CPU类class CPU&#123;public:\t//抽象的计算函数\tvirtual void calculate() = 0;&#125;;//抽象显卡类class VideoCard&#123;public:\t//抽象的显示函数\tvirtual void display() = 0;&#125;;//抽象内存条类class Memory&#123;public:\t//抽象的存储函数\tvirtual void storage() = 0;&#125;;//电脑类class Computer&#123;public:\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\t&#123; m_cpu = cpu; m_vc = vc; m_mem = mem;\t&#125;\t//提供工作的函数\tvoid work()\t&#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage();\t&#125;\t//提供析构函数 释放3个电脑零件\t~Computer()\t&#123; //释放CPU零件 if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; //释放显卡零件 if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; //释放内存条零件 if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125;\t&#125;private:\tCPU * m_cpu; //CPU的零件指针\tVideoCard * m_vc; //显卡零件指针\tMemory * m_mem; //内存条零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public:\tvirtual void calculate()\t&#123; cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;\t&#125;&#125;;class IntelVideoCard :public VideoCard&#123;public:\tvirtual void display()\t&#123; cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;\t&#125;&#125;;class IntelMemory :public Memory&#123;public:\tvirtual void storage()\t&#123; cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;\t&#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public:\tvirtual void calculate()\t&#123; cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;\t&#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public:\tvirtual void display()\t&#123; cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;\t&#125;&#125;;class LenovoMemory :public Memory&#123;public:\tvirtual void storage()\t&#123; cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//第一台电脑零件\tCPU * intelCpu = new IntelCPU;\tVideoCard * intelCard = new IntelVideoCard;\tMemory * intelMem = new IntelMemory;\tcout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\t//创建第一台电脑\tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\tcomputer1-&gt;work();\tdelete computer1;\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\t//第二台电脑组装\tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\tcomputer2-&gt;work();\tdelete computer2;\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\t//第三台电脑组装\tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\tcomputer3-&gt;work();\tdelete computer3;&#125; 5 文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D; 文件类型分为两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: ofstream：写操作 ifstream： 读操作 fstream ： 读写操作 5.1文本文件5.1.1写文件 写文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ofstream ofs; 打开文件 ofs.open(“文件路径”,打开方式); 写数据 ofs &lt;&lt; “写入的数据”; 关闭文件 ofs.close(); ​ 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意： 文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios:: out 示例： 12345678910111213141516171819202122#include &lt;fstream&gt;void test01()&#123;\tofstream ofs;\tofs.open(&quot;test.txt&quot;, ios::out);\tofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\tofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\tofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\tofs.close();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多 读文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ifstream ifs; 打开文件并判断文件是否打开成功 ifs.open(“文件路径”,打开方式); 读数据 四种方式读取 关闭文件 ifs.close(); 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123;\tifstream ifs;\tifs.open(&quot;test.txt&quot;, ios::in);\tif (!ifs.is_open())\t&#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return;\t&#125;\t//第一种方式\t//char buf[1024] = &#123; 0 &#125;;\t//while (ifs &gt;&gt; buf)\t//&#123;\t//\tcout &lt;&lt; buf &lt;&lt; endl;\t//&#125;\t//第二种\t//char buf[1024] = &#123; 0 &#125;;\t//while (ifs.getline(buf,sizeof(buf)))\t//&#123;\t//\tcout &lt;&lt; buf &lt;&lt; endl;\t//&#125;\t//第三种\t//string buf;\t//while (getline(ifs, buf))\t//&#123;\t//\tcout &lt;&lt; buf &lt;&lt; endl;\t//&#125;\tchar c;\twhile ((c = ifs.get()) != EOF)\t&#123; cout &lt;&lt; c;\t&#125;\tifs.close();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 5.2 二进制文件以二进制的方式对文件进行读写操作 打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D; 5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write 函数原型 ：ostream&amp; write(const char * buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:\tchar m_Name[64];\tint m_Age;&#125;;//二进制文件 写文件void test01()&#123;\t//1、包含头文件\t//2、创建输出流对象\tofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary); //3、打开文件\t//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\tPerson p = &#123;&quot;张三&quot; , 18&#125;;\t//4、写文件\tofs.write((const char *)&amp;p, sizeof(p));\t//5、关闭文件\tofs.close();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 总结： 文件输出流对象 可以通过write函数，以二进制方式写数据 5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char *buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:\tchar m_Name[64];\tint m_Age;&#125;;void test01()&#123;\tifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);\tif (!ifs.is_open())\t&#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\t&#125;\tPerson p;\tifs.read((char *)&amp;p, sizeof(p));\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125; 文件输入流对象 可以通过read函数，以二进制方式读数据","tags":["C++"],"categories":["语言"]},{"title":"Linux基础命令","path":"/2024/08/12/Linux基础命令/","content":"Linux基础命令 Linux目录结构 /根目录，是最顶级的目录 Linux有且仅有这一个顶级目录，没有Windows那些分盘分区 Linux中路径描述分区也用 / 来区分 &#x2F;home&#x2F;bob 表示根目录下的home的bob文件夹里的内容 ls命令功能：列出文件夹信息语法：ls [-l -h -a] [参数] 参数：被查看的文件夹，不提供参数，表示查看当前工作目录 -l，以列表形式查看 -h，需要配合-l，以更加人性化的方式显示文件大小 -a，显示隐藏的文件 隐藏文件、文件夹在Linux中以.开头的，均是隐藏的。默认不显示出来，需要-a选项才可查看到。 pwd命令功能：展示当前工作目录语法：pwd cd命令功能：切换工作目录语法：cd [目标目录] 参数：目标目录，要切换去的地方，不提供则默认切换到&#x3D;&#x3D;当前用户的HOME目录&#x3D;&#x3D; HOME目录每一个用户在Linux系统中的自己的专属工作目录，称之为HOME目录。 普通用户的HOME目录，默认在：/home/用户名 root用户登陆后，在/root FinalShell登录终端后，默认的工作目录就是用户的HOME目录 相对路径、绝对路径 相对路径，&#x3D;&#x3D;非&#x3D;&#x3D; /开头的称之为相对路径相对路径表示以当前目录作为起点去描述路径，如test/a.txt,表示当前工作目录内的test文件夹内的a.txt文件 绝对路径，&#x3D;&#x3D;以&#x3D;&#x3D; /开头的称之为绝对路径绝对路径从根开始描述路径 特殊路径符 .表示当前,比如.&#x2F;a.txt，表示当前文件夹内的a.txt文件 ..表示上级目录，比如../表示上级目录，../../表示上级的上级目录 ~表示用户的HOME目录，比如cd ~,即可切回用户HOME目录","tags":["Java"],"categories":["系统"]},{"title":"Maven","path":"/2024/08/02/maven/","content":"1.Maven简介&#x3D;&#x3D;Maven是一个依赖管理工具&#x3D;&#x3D;Maven是一款为 Java 项目管理构建、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。Maven就是一个软件，掌握安装、配置、以及基本功能 （项目构建、依赖管理） 的理解和使用即可~ 2.Maven的引入①jar包：&emsp;&emsp;jar包就是 &#x3D;&#x3D;Java Archive File&#x3D;&#x3D;，是 Java 的一种文档格式，是一种与平台无关的文件格式，可将多个文件合成一个“文件”。jar 包与 zip 包非常相似——准确地说，它就是 zip 包，所以叫它文件包。&emsp;&emsp;jar 与 zip 唯一的区别就是在 jar 文件的内容中，包含了一个 META-INF&#x2F;MANIFEST.MF 文件，该文件是在生成 jar 文件的时候自动创建的，作为jar里面的”详情单”，包含了该Jar包的版本、创建人和类搜索路径Class-Path等信息。&emsp;&emsp;随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。如果一个简单的项目就需要上百个文件导入后才能运行这无疑让人感到头大。这时就需要一个工具来管理…… &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;懒惰使人类进步 &emsp;&emsp;如果使用 Maven 来引入这些 jar 包只需要配置几个『依赖』 ②jar包的来源问题 这个jar包所属技术的官网。官网通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载。 第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。 jar包的名称 jar包的版本 jar包内的具体细节 而使用 Maven 后，依赖对应的 jar 包能够自动下载，方便、快捷又规范。 ③jar包的导入问题在web工程中，jar包必须存放在指定位置： 在使用Maven之后，通过配置依赖(jar包)的坐标，查找本地仓库中相应jar包，若本地仓库没有，则统一从镜像网站或中央仓库中下载： ④jar包之间的依赖&emsp;&emsp;框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。&emsp;&emsp;而实际上 jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。&emsp;&emsp;而使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量。 3.基于IDEA 进行Maven依赖管理3.1 依赖管理概念Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。 我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven 仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。 总之，Maven 的依赖管理是 Maven 软件的一个核心功能之一，使得软件包依赖的管理和使用更加智能和方便，简化了开发过程中的工作，并提高了软件质量和可维护性。 3.2 Maven工程核心信息配置和解读（GAVP）位置：pom.xml 12345678910111213141516&lt;!-- 模型版本 --&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;&lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt;&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;&lt;artifactId&gt;project&lt;/artifactId&gt;&lt;!-- 版本号 --&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;!--打包方式 默认：jar jar指的是普通的java项目打包方式！ 项目打成jar包！ war指的是web项目打包方式！项目打成war包！ pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念--&gt;&lt;packaging&gt;jar/pom/war&lt;/packaging&gt; 3.3 Maven工程依赖管理配置位置：pom.xml 依赖管理和依赖添加 123456789101112131415161718&lt;!-- 通过编写依赖jar包的gav必要属性，引入第三方依赖！ scope属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --&gt;&lt;dependencies&gt; &lt;!-- 引入具体的依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;!-- 依赖范围 --&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖版本统一提取和维护 1234567891011121314151617&lt;!--声明版本--&gt;&lt;properties&gt; &lt;!--命名随便,内部制定版本号即可！--&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--引用properties声明版本 --&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.4 依赖范围通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境 依赖范围 描述 compile 编译依赖范围，scope 元素的缺省值。使用此依赖范围的 Maven 依赖，对于三种 classpath 均有效，即该 Maven 依赖在上述三种 classpath 均会被引入。例如，log4j 在编译、测试、运行过程都是必须的。 test 测试依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath 有效。例如，Junit 依赖只有在测试阶段才需要。 provided 已提供依赖范围。使用此依赖范围的 Maven 依赖，只对编译 classpath 和测试 classpath 有效。例如，servlet-api 依赖对于编译、测试阶段而言是需要的，但是运行阶段，由于外部容器已经提供，故不需要 Maven 重复引入该依赖。 runtime 运行时依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath、运行 classpath 有效。例如，JDBC 驱动实现依赖，其在编译时只需 JDK 提供的 JDBC 接口即可，只有测试、运行阶段才需要实现了 JDBC 接口的驱动。 system 系统依赖范围，其效果与 provided 的依赖范围一致。其用于添加非 Maven 仓库的本地依赖，通过依赖元素 dependency 中的 systemPath 元素指定本地依赖的路径。鉴于使用其会导致项目的可移植性降低，一般不推荐使用。 import 导入依赖范围，该依赖范围只能与 dependencyManagement 元素配合使用，其功能是将目标 pom.xml 文件中 dependencyManagement 的配置导入合并到当前 pom.xml 的 dependencyManagement 中。 本篇知识回顾参考尚硅谷的文章，仅作为复习or快速入门使用。","tags":["Java"],"categories":["Java"]},{"title":"md入门","path":"/2024/07/18/md入门/","content":"MarkDown学习笔记 0.前言话说md的优秀学习资源还真不好找，在小破站找了半天，还是在Github发现了宝藏https://github.com/Sakiyary/Markdown-Typora-VSCode-Doc 1.标题[数个“#”+空格前置]一级标题二级标题三级标题四级标题五级标题六级标题标题会在目录与大纲分级显示，可以跳转。 在 Typora 中建议开启严格模式，即不应为#标题，应为# 标题。 应该手动补上空格，使得Markdown语法在其他文本编辑器上兼容。 2. 强调 [用 “**” 或 “__” 包围]欢迎报考西安邮电大学! (我喜欢用这种)欢迎报考西安邮电大学!或者选中想要强调的文字按Ctrl+ B。 3. 斜体 [用 “*” 或 “_” 包围]欢迎大佬来浇浇我各种知识 (我喜欢用这种)欢迎大佬来浇浇我各种知识或者选中想要强调的文字按Ctrl+ I。 例如 欢迎大佬来浇我各种知识 (PS斜体并强调[用“***”或“___”包围]) 4. 删除线 [用 “~~” 包围]我宣布个事儿, 我是Sabiyary!例如 5. *高亮 [用“&#x3D;&#x3D;”包围](注意：此为扩展语法) &#x3D;&#x3D;我喜欢黄色, 也喜欢绿色&#x3D;&#x3D;例如 &#x3D;&#x3D;我喜欢黄色，也喜欢绿色&#x3D;&#x3D; 6. 代码 [用 “&#96;” 包围]sudo rm -rf /* 例如 sudo rm -rf &#x2F;*（没事别乱敲这个！） “请输入管理员密码: (点亮的指示灯)” 7. 代码块 [按三个“&#96;”并敲回车]1234567891011// 这里就可以开始输入你要的代码了#include &lt;stdio.h&gt;int mian() &#123; print（“Hello, world! &quot;）; retrun O;&#125; // (这三个&quot;`&quot;文本编辑器会帮你自动补全 一般不用手动输)（我之前都是用这个来展示各种语法的，应该不用说明清楚吧）显示行数的话，一般要在 Typora 的设置里勾上这个显示行数的选项。代码块里可以选择语言，其会根据语言自动高亮各个语句。 在选择语言后，```会变为````+ 对应语言。 8. 引用[“&gt;” + 空格前置] 24岁, 是学生. 学生特有的无处不在(恼)引用是可以的！ 9. 无序列表 [“-“ 或 “+” + 空格前置] 一颗是枣树 (我喜欢用这种) 另一颗还是枣树 (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)三个前置符都可以，敲回车会自动补全，可以在Typora设置中调整补全的符号，敲回车后按下Tab会缩进一级。 10. 社区列表【数字+“.” + 空格前置]我来这里就为了三件事: 公平 公平 还是tm的公平!敲回车会自动补全，敲回车后按下Tab会缩进一级。 11. *上标 [用 “^” 包围](注意：此为扩展语法) C语言中int的上限是 2^31^ - 1 &#x3D; 2147483647 12. *下标 [用 “~” 包围](注意：此为扩展语法) H2O 是剧毒的!例如 H2哦是剧毒的！ 13. *注释 [“[^]” 后置](注意：此为扩展语法) 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1] [^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.需要在文末写上注释的内容 14. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]（注意：文内动画作为扩展方式） 来看看原作者的仓库罢[基础教程: 12. 下标](#12. 下标 [用 “~” 包围])支持网页链接与文内跳转，按住Ctrl并单击鼠标左键即可跳转。 15.任务列表[“-[]”+空格前置]TodoList: 刷B站 写代码 起床使用x替换[ ]中的空格来勾选任务列表。 在 Typora&#x2F;VScode 中可以直接用鼠标左键单击复选框。 16. 表格 [用“|” 相似表格相似] 学号 姓名 年龄 114514 田所 24 1919810 浩三 25 (引号的位置代表着 左对齐, 居中, 右对齐) 第一行为表头，并由第二行分割线决定景观方式与长度，第三行及之后即表格数据 17. 图片 [直接拖板进来或者复制粘贴]我还是会选择拖板或者复制粘贴啦~在Typora的设置里也可以改变图片的存储方式。 18.分割线[按三个“*”或“-”或“_”并敲回车] — (我喜欢用这种) &#x2F;&#x2F; (其实按三个及以上都可以)由于*与_均会自动补全，所以我觉得-极其方便。 19. Emoji表情 [“:” 前面]（注意：英文输入为扩展语法） :sweat_smile::drooling_face::clown_face:&#x2F;&#x2F; (敲回车或者鼠标点击, 后置的”:”一般不需要手动输)这个功能的唯一要求就是英语水平要高，或者大概记住各个表情符号的英文名字。 对于其余普通的 Markdown 文本编辑器，可以直接将 Emoji 表情复制进来，这就是直接硬编码的 (刻进DNA里） 例如 😅🤤🤡 使用好这个功能可以让你的文本非常可爱！太抽象了 进阶1. 目录 [自动生成]&#x3D;&#x3D;[TOC]&#x3D;&#x3D;(此为 Typora 特有的, 如本文档开头)若使用 VS Code 且搭配 Markdown All in One 扩展，可在 VS Code 的命令面板（即VS Code Command Palette）输入Create Table of Contents自动生成目录，可在扩展中设置中细调目录参数。 2. 内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围] 我不会 HTML 呜呜呜... 浇浇我 简单的文字居中也可以这样 我差点忘了还有下划线这东西…只要你会写，你完全可以把 Markdown 当作HTML来写。 同时，.md文件可以直接导出成一个网页。 下划线可以选中想要下划的文字单击Ctrl+ U。 3. 内联公式 [用 “$” 包围]（注意：部分编译器会不识别部分符号） $\\LaTeX$ 是最好用的论文排版语言! 不信你看! $a^n+b^n&#x3D;c^n$ 使用$包围为单条公式，点击两个$并敲回车即生成公式块。 例如 是最好用的论文排版语言！ 不信你看！ 4. *网络图表（这是学长给我的网络图床教程，我实践过……） 分享一个Typora搭配腾讯云COS&#x2F;阿里云OSS图床的例子。 新免费用户投入了6个月的时间，另外选择了七牛云或者路过图床。 5. *Typora 的常用快捷键關鍵\t效果\t關鍵\t效果Ctrl+D\t选中当前词\tCtrl+L\t选中当前句&#x2F;行Ctrl+E\t选中当前项目\tCtrl+F\t搜索当前问题Ctrl+B\t加粗当前检查\tCtrl+H\t替换当前选项Ctrl+I\t总统当前任务\tCtrl+U\t下划当前检查Ctrl+K\t将当前选中生成链接\tCtrl+J\t屏幕滚动至顶部Ctrl+W\t关闭窗口\tCtrl+N\t打开新窗口Ctrl+O\t打开文件\tCtrl+P\t搜索结果并打开Ctrl+回车\t表格下方插入行\tCtrl+,\t展开方案Ctrl+.\t切换全角&#x2F;半角标点\tCtrl+&#x2F;\t切换正常&#x2F;来源视图Ctrl+ Shift+-\t幻灯片\tCtrl+ Shift++\t放大还有一些不常用的&#x2F;三键的主板不在此首发。 6. *Typora的主题风格与检查元素Markdown 在编译后相当于 HTML。 而Typora的正常视图就是编译Markdown后的，故Typora的主题样式本质上就是CSS文件。 可以下载各种好看的主题给Typora换上，同时也可以自己调整对应的CSS文件，或者自己手搓。 在Typora中打开调试模式后即可在正常视图右击打开检查元素，在其中就可以完全将Markdown文件当成HTML来编辑。 💯 总结至此，Markdown + Typora &#x2F; VSCode的手册教程也告一段落。 不知道你看完这么长的教程&#x2F;手册，是否能体会到 Markdown 的精妙简洁之处呢？ 其实 Markdown 只是标记语言的最开始，我的感受是会了 Markdown 之后对于理解 HTML 也有帮助，对于使用Latex来写论文也有帮助。 语言标记是为了修复Word那样虽然“所见即所得”，但又过度花哨浮华，很差的兼容性与闭源的编码的缺陷。 当你能够掌握这样的“所写即所得”时，你肯定会常用 Markdown 这类语言来处理文本的妙处！","tags":["MD"],"categories":["blog1"]},{"title":"Hello World","path":"/2024/07/18/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]